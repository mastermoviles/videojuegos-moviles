
<!DOCTYPE doctype html>

<html class="no-js" lang="es">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta content="ie=edge" http-equiv="x-ua-compatible"/>
<meta content="Copiar al portapapeles" name="lang:clipboard.copy"/>
<meta content="Copiado al portapapeles" name="lang:clipboard.copied"/>
<meta content="en" name="lang:search.language"/>
<meta content="True" name="lang:search.pipeline.stopwords"/>
<meta content="True" name="lang:search.pipeline.trimmer"/>
<meta content="No se encontraron documentos" name="lang:search.result.none"/>
<meta content="1 documento encontrado" name="lang:search.result.one"/>
<meta content="# documentos encontrados" name="lang:search.result.other"/>
<meta content="[\s\-]+" name="lang:search.tokenizer"/>
<link href="assets/images/favicon.png" rel="shortcut icon"/>
<meta content="mkdocs-1.0.4, mkdocs-material-4.4.0" name="generator"/>
<title>Sprites y colisiones - VPDM - Cocos2d-x</title>
<link href="assets/stylesheets/application.0284f74d.css" rel="stylesheet"/>
<link href="assets/stylesheets/application-palette.01803549.css" rel="stylesheet"/>
<meta content="#009688" name="theme-color"/>
<script src="assets/javascripts/modernizr.74668098.js"></script>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&amp;display=fallback" rel="stylesheet"/>
<style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
<link href="assets/fonts/material-icons.css" rel="stylesheet"/>
</head>
<body data-md-color-accent="teal" data-md-color-primary="teal" dir="ltr">
<svg class="md-svg">
<defs>
</defs>
</svg>
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<a class="md-skip" href="#sprites-y-colisiones" tabindex="1">
        Saltar a contenido
      </a>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a class="md-header-nav__button md-logo" href="index.html" title="VPDM - Cocos2d-x">
<img height="24" src="imagenes/logo.png" width="24"/>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
              VPDM - Cocos2d-x
            </span>
<span class="md-header-nav__topic">
              
                Sprites y colisiones
              
            </span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input autocapitalize="off" autocomplete="off" autocorrect="off" class="md-search__input" data-md-component="query" data-md-state="active" name="query" placeholder="Búsqueda" spellcheck="false" type="text"/>
<label class="md-icon md-search__icon" for="__search"></label>
<button class="md-icon md-search__icon" data-md-component="reset" tabindex="-1" type="reset">
        
      </button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix="">
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
            Teclee para comenzar búsqueda
          </div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</nav>
</header>
<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0">
<label class="md-nav__title md-nav__title--site" for="__drawer">
<a class="md-nav__button md-logo" href="index.html" title="VPDM - Cocos2d-x">
<img height="48" src="imagenes/logo.png" width="48"/>
</a>
    VPDM - Cocos2d-x
  </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="index.html" title="Introducción">
      Introducción
    </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="videojuegos_para_moviles.html" title="Videojuegos para móviles">
      Videojuegos para móviles
    </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="introduccion_a_cocos2d-x.html" title="El motor Cocos2d-x">
      El motor Cocos2d-x
    </a>
</li>
<li class="md-nav__item md-nav__item--active">
<input class="md-toggle md-nav__toggle" data-md-toggle="toc" id="__toc" type="checkbox"/>
<label class="md-nav__link md-nav__link--active" for="__toc">
        Sprites y colisiones
      </label>
<a class="md-nav__link md-nav__link--active" href="sprites_e_interaccion.html" title="Sprites y colisiones">
      Sprites y colisiones
    </a>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Tabla de contenidos</label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#sprites" title="Sprites">
    Sprites
  </a>
<nav class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#posicion" title="Posición">
    Posición
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#fotogramas" title="Fotogramas">
    Fotogramas
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#animacion" title="Animación">
    Animación
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sprite-batch" title="Sprite batch">
    Sprite batch
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#colisiones" title="Colisiones">
    Colisiones
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#motor-del-juego" title="Motor del juego">
    Motor del juego
  </a>
<nav class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#ciclo-del-juego" title="Ciclo del juego">
    Ciclo del juego
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#actualizacion-de-la-escena" title="Actualización de la escena">
    Actualización de la escena
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#acciones" title="Acciones">
    Acciones
  </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="escenario_y_fondos.html" title="Escenario y fondos">
      Escenario y fondos
    </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="motor_de_fisicas.html" title="Motor de físicas">
      Motor de físicas
    </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="mandos.html" title="Controles del videojuego">
      Controles del videojuego
    </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="adaptacion_a_moviles.html" title="Adaptación a móviles">
      Adaptación a móviles
    </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="redes_sociales.html" title="Servicios y redes sociales para juegos">
      Servicios y redes sociales para juegos
    </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="unity.html" title="Motor Unity">
      Motor Unity
    </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="nativo.html" title="Tecnologías nativas">
      Tecnologías nativas
    </a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Tabla de contenidos</label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#sprites" title="Sprites">
    Sprites
  </a>
<nav class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#posicion" title="Posición">
    Posición
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#fotogramas" title="Fotogramas">
    Fotogramas
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#animacion" title="Animación">
    Animación
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sprite-batch" title="Sprite batch">
    Sprite batch
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#colisiones" title="Colisiones">
    Colisiones
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#motor-del-juego" title="Motor del juego">
    Motor del juego
  </a>
<nav class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#ciclo-del-juego" title="Ciclo del juego">
    Ciclo del juego
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#actualizacion-de-la-escena" title="Actualización de la escena">
    Actualización de la escena
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#acciones" title="Acciones">
    Acciones
  </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset"><a class="md-icon md-content__icon" download href="pdf/combined.pdf" title="PDF Export"></a>
<h1 id="sprites-y-colisiones">Sprites y colisiones<a class="headerlink" href="#sprites-y-colisiones" title="Permanent link">¶</a></h1>
<p>En esta sesión vamos a ver un componente básico de los videojuegos: los <em>sprites</em>. Vamos a ver
cómo tratar estos componentes de forma apropiada, cómo animarlos, moverlos por la pantalla y detectar
colisiones entre ellos.</p>
<h2 id="sprites">Sprites<a class="headerlink" href="#sprites" title="Permanent link">¶</a></h2>
<p>Los <em>sprites</em> hemos dicho que son todos aquellos objetos de<br/>
  la escena que se mueven y/o podemos interactuar con ellos de alguna forma. </p>
<p>Podemos crear un <em>sprite</em> en Cocos2D con la clase <code>Sprite</code>
a partir de la textura de dicho <em>sprite</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Sprite</span> <span class="o">*</span><span class="n">sprite</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">"personaje.png"</span><span class="p">);</span>
</pre></div>
</td></tr></table>
<p>El <em>sprite</em> podrá ser añadido a la escena como cualquier otro nodo, añadiéndolo
como hijo de alguna de las capas con <code>addChild:</code>.</p>
<h3 id="posicion">Posición<a class="headerlink" href="#posicion" title="Permanent link">¶</a></h3>
<p>Al igual que cualquier nodo, un <em>sprite</em> tiene una posición en pantalla
representada por su propiedad <code>position</code>, de tipo <code>Vec2</code> (también podemos utilizar como tipo <code>Point</code>, ya que es un alias de <code>Vec2</code>). </p>
<p>Por ejemplo, para posicionar un <em>sprite</em> en unas determinadas coordenadas
le asignaremos un valor a su propiedad <code>position</code> (esto es aplicable a 
cualquier nodo):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">sprite</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">160</span><span class="p">));</span>
</pre></div>
</td></tr></table>
<p>La posición indicada corresponde al punto central del <em>sprite</em>, aunque 
podríamos modificar esto con la propiedad <code>anchorPoint</code>, de forma similar
a las capas de CoreAnimation. El sistema de coordenadas de Cocos2D es el mismo que el
de CoreGraphics, el origen de coordenadas se encuentra en la esquina inferior 
izquierda, y las <em>y</em> son positivas hacia arriba.</p>
<p>Podemos aplicar otras transformaciones al <em>sprite</em>, como rotaciones 
(<code>rotation</code>), escalados (<code>scale</code>, <code>scaleX</code>, <code>scaleY</code>), o desencajados
(<code>skewX</code>, <code>skewY</code>). También podemos especificar su orden Z (<code>zOrder</code>). 
Recordamos que todas estas propiedades no son exclusivas de los <em>sprites</em>, sino que son
aplicables a cualquier nodo, aunque tienen un especial interés en el caso de los <em>sprites</em>.</p>
<h3 id="fotogramas">Fotogramas<a class="headerlink" href="#fotogramas" title="Permanent link">¶</a></h3>
<p>Estos objetos pueden estar animados. Para ello deberemos definir los distintos 
  fotogramas (o <em>frames</em>) de la animación. Podemos definir varias 
  animaciones para cada <em>sprite</em>, según las acciones que pueda hacer. 
  Por ejemplo, si tenemos un personaje podemos tener una animación para 
  andar hacia la derecha y otra para andar hacia la izquierda.
El <em>sprite</em> tendrá un determinado tamaño (ancho y alto), 
  y cada fotograma será una imagen de este tamaño.</p>
<p>Cambiando el fotograma que se muestra del <em>sprite</em> en cada momento podremos 
  animarlo. Para ello deberemos tener imágenes para los distintos fotogramas del <em>sprite</em>.
  Sin embargo, como hemos comentado anteriormente, la memoria de vídeo es un recurso crítico, y 
  debemos aprovechar al máximo el espacio de las texturas que se almacenan en ella. Recordemos
  que el tamaño de las texturas en memoria debe ser potencia de 2. Además, conviene evitar
  empaquetar con la aplicación un gran número de imágenes, ya que esto hará que el espacio
  que ocupan sea mayor, y que la carga de las mismas resulte más costosa.</p>
<p>Para almacenar los fotogramas de los <em>sprites</em> de forma óptima, utilizamos lo que se conoce como
<em>sprite sheets</em>. Se trata de imágenes en las que incluyen de forma conjunta todos los fotogramas
de los <em>sprites</em>, dispuestos en forma de mosaico.</p>
<p><img alt="Mosaico con los frames de un sprite" src="imagenes/juegos/sprite.gif"/></p>
<p>Podemos crear estos <em>sprite sheets</em> de forma manual, aunque encontramos herramientas que nos
facilitarán enórmemente este trabajo, como <strong>TexturePacker</strong> (http://www.texturepacker.com).
Esta herramienta cuenta con una versión básica gratuita, y opciones adicionales de pago. Además de organizar
los <em>sprites</em> de forma óptima en el espacio de una textura OpenGL, nos permite almacenar esta textura
en diferentes formatos (RGBA8888, RGBA4444, RGB565, RGBA5551, PVRTC) y aplicar efectos de mejora como 
<em>dithering</em>. Esta herramienta permite generar los <em>sprite sheets</em> en varios formatos reconocidos por los diferentes
motores de videojuegos, como por ejemplo Cocos2D o libgdx.</p>
<p><img alt="Herramienta TexturePacker" src="imagenes/juegos/texturas_packer.jpg"/></p>
<p>Con esta herramienta simplemente tendremos que arrastrar sobre ella el conjunto de imágenes con los distintos 
fotogramas de nuestros <em>sprites</em>, y nos generará una textura optimizada para OpenGL con todos ellos 
dispuestos en forma de mosaico. Cuando almacenemos esta textura generada, normalmente se guardará un fichero
<code>.png</code> con la textura, y un fichero de datos que contendrá información sobre los distintos fotogramas
que contiene la textura, y la región que ocupa cada uno de ellos.</p>
<p>Para poder utilizar los fotogramas añadidos a la textura deberemos contar con algún mecanismo que nos permita
mostrar en pantalla de forma independiente cada región de la textura anterior (cada fotograma). En 
prácticamente todos los motores para videojuegos encontraremos mecanismos para hacer esto.</p>
<p>En el caso de Cocos2D, tenemos la clase <code>SpriteFrameCache</code> que se encarga de almacenar la
caché de fotogramas de <em>sprites</em> que queramos utilizar. Con TexturePacker habremos
obtenido un fichero <code>.plist</code> (es el formato utilizado por Cocos2D) y una imagen <code>.png</code>. 
Podremos añadir fotogramas a la caché a partir de estos dos ficheros. En el fichero <code>.plist</code> se 
incluye la información de cada fotograma (tamaño, región que ocupa en la textura, etc). Cada fotograma se 
encuentra indexado por defecto mediante el nombre de la imagen original que añadimos a TexturePacker, aunque 
podríamos editar esta información de forma manual en el <code>.plist</code>.</p>
<p>La caché de fotogramas se define como <em>singleton</em>. Podemos añadir nuevos fotogramas a este
<em>singleton</em> de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">SpriteFrameCache</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="n">addSpriteFramesWithFile</span><span class="p">(</span><span class="s">"sheet.plist"</span><span class="p">);</span>
</pre></div>
</td></tr></table>
<p>En el caso anterior, utilizará como textura un fichero con el mismo nombre que el <code>.plist</code> pero
con extensión <code>.png</code>. También encontramos una versión del método anterior que también recibe como
parámetro la textura a utilizar, y de esta forma nos permite utilizar un fichero de textura 
con distinto nombre al <code>.plist</code>.</p>
<p>Una vez introducidos los fotogramas empaquetados por TexturePacker en la caché de Cocos2D, podemos crear 
<em>sprites</em> a partir de dicha caché con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Sprite</span> <span class="o">*</span><span class="n">sprite</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">"frame01.png"</span><span class="p">);</span>
</pre></div>
</td></tr></table>
<p>En el caso anterior creamos un nuevo <em>sprite</em>, pero en lugar de hacerlo directamente a partir de una
imagen, debemos hacerlo a partir del nombre de un fotograma añadido a la caché de textura. No debemos confundirnos
con esto, ya que en este caso al especificar <code>"frame01.png"</code> no buscará un fichero con este nombre
en la aplicación, sino que buscará un fotograma con ese nombre en la caché de textura. El que los fotogramas
se llamen por defecto como la imagen original que añadimos a TexturePacker puede llevarnos a confusión.</p>
<p>También podemos obtener el fotograma como un objeto <code>SpriteFrame</code>. Esta clase no define un 
<em>sprite</em>, sino el fotograma almacenado en caché. Es decir, no es un nodo que podamos almacenar en la 
escena, simplemente define la región de textura correspondiente al fotograma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">SpriteFrame</span><span class="o">*</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">SpriteFrameCache</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="n">spriteFrameByName</span><span class="p">(</span><span class="s">"frame01.png"</span><span class="p">);</span>
</pre></div>
</td></tr></table>
<p>Podremos inicializar también el <em>sprite</em> a partir del fotograma anterior, en lugar de hacerlo directamente
a partir del nombre del fotograma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Sprite</span> <span class="o">*</span><span class="n">sprite</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrame</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</pre></div>
</td></tr></table>
<h3 id="animacion">Animación<a class="headerlink" href="#animacion" title="Permanent link">¶</a></h3>
<p>Podremos definir determinadas secuencias de <em>frames</em> para crear animaciones. Las animaciones se
representan mediante la clase <code>Animation</code>, y se pueden crear a partir de la secuencia de
fotogramas que las definen. Los fotogramas deberán indicarse mediante objetos de la clase 
<code>SpriteFrame</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Animation</span> <span class="o">*</span><span class="n">animAndar</span> <span class="o">=</span> <span class="n">Animation</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
<span class="n">animAndar</span><span class="o">-&gt;</span><span class="n">addSpriteFrame</span><span class="p">(</span><span class="n">SpriteFrameCache</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="n">spriteFrameByName</span><span class="p">(</span><span class="s">"frame01.png"</span><span class="p">));</span>
<span class="n">animAndar</span><span class="o">-&gt;</span><span class="n">addSpriteFrame</span><span class="p">(</span><span class="n">SpriteFrameCache</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="n">spriteFrameByName</span><span class="p">(</span><span class="s">"frame02.png"</span><span class="p">));</span>
</pre></div>
</td></tr></table>
<p>Podemos ver que los fotogramas se pueden obtener de la caché de fotogramas definida anteriormente. Además
de proporcionar una lista de fotogramas a la animación, deberemos proporcionar su periodicidad, es decir, el
tiempo en segundos que tarda en cambiar al siguiente fotograma. Esto se hará mediante la propiedad
<code>delayPerUnit</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">animAndar</span><span class="o">-&gt;</span><span class="n">setDelayPerUnit</span><span class="p">(</span><span class="mf">0.25</span><span class="p">);</span>
</pre></div>
</td></tr></table>
<p>Una vez definida la animación, podemos añadirla a una caché de animaciones que, al igual que la caché
de texturas, también se define como <em>singleton</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">AnimationCache</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="n">addAnimation</span><span class="p">(</span><span class="n">animAndar</span><span class="p">,</span> <span class="s">"animAndar"</span><span class="p">);</span>
</pre></div>
</td></tr></table>
<p>La animación se identifica mediante la cadena que proporcionamos como parámetro
<code>name</code>. Podemos cambiar el fotograma que muestra actualmente un <em>sprite</em> con su método:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">sprite</span><span class="o">-&gt;</span><span class="n">setDisplayFrameWithAnimationName</span><span class="p">(</span><span class="s">"animAndar"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</td></tr></table>
<p>Con esto buscará en la caché de animaciones la animación especificada, y mostrará de ella
el fotograma cuyo índice proporcionemos. Más adelante cuando estudiemos el motor del juego veremos cómo 
reproducir animaciones de forma automática.</p>
<h3 id="sprite-batch"><em>Sprite batch</em><a class="headerlink" href="#sprite-batch" title="Permanent link">¶</a></h3>
<p>En OpenGL los <em>sprites</em> se dibujan realmente en un contexto 3D. Es decir, son texturas que se 
mapean sobre polígonos 3D (concretamente con una geometría rectángular). Muchas veces encontramos en
pantalla varios <em>sprites</em> que utilizan la misma textura (o distintas regiones de la misma textura,
como hemos visto en el caso de los <em>sprite sheets</em>). Podemos optimizar el dibujado de estos <em>sprites</em> 
generando la geometría de todos ellos de forma conjunta en una única operación con la GPU. Esto será
posible sólo cuando el conjunto de <em>sprites</em> a dibujar estén contenidos en una misma textura. </p>
<p>Podemos crear un <em>batch</em> de <em>sprites</em> con Cocos2D utilizando la clase </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">SpriteBatchNode</span> <span class="o">*</span><span class="n">spriteBatch</span> <span class="o">=</span> 
    <span class="n">SpriteBatchNode</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">"sheet.png"</span><span class="p">);</span>
<span class="k">this</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">spriteBatch</span><span class="p">);</span>
</pre></div>
</td></tr></table>
<p>El <em>sprite batch</em> es un tipo de nodo más que podemos añadir a nuestra capa como hemos visto, 
pero por si sólo no genera ningún contenido. Deberemos añadir como hijos los <em>sprites</em> que queremos 
que dibuje. Es imprescindible que los hijos sean de tipo <code>Sprite</code> (o subclases de ésta), y
que tengan como textura la misma textura que hemos utilizado al crear el <em>batch</em> (o regiones de 
la misma). No podremos añadir <em>sprites</em> con ninguna otra textura dentro de este <em>batch</em>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Sprite</span> <span class="o">*</span><span class="n">sprite1</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">"frame01.png"</span><span class="p">);</span>
<span class="n">sprite1</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">20</span><span class="p">));</span>
<span class="n">Sprite</span> <span class="o">*</span><span class="n">sprite2</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">"frame01.png"</span><span class="p">);</span>
<span class="n">sprite2</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span><span class="mi">20</span><span class="p">));</span>

<span class="n">spriteBatch</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">sprite1</span><span class="p">);</span>
<span class="n">spriteBatch</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">sprite2</span><span class="p">);</span>
</pre></div>
</td></tr></table>
<p>En el ejemplo anterior consideramos que el <em>frame</em> con nombre <code>"frame01.png"</code>
es un fotograma que se cargó en la caché de fotogramas a partir de la textura <code>sheet.png</code>.
De no pertenecer a dicha textura no podría cargarse dentro del <em>batch</em>.</p>
<h3 id="colisiones">Colisiones<a class="headerlink" href="#colisiones" title="Permanent link">¶</a></h3>
<p>Otro aspecto de los <em>sprites</em> es la interacción entre ellos. 
  Nos interesará saber cuándo somos tocados por un enemigo o una bala para 
  disminuir la vida, o cuándo alcanzamos nosotros a nuestro enemigo. Para ello 
  deberemos detectar las colisiones entre <em>sprites</em>. La colisión 
  con <em>sprites</em> de formas complejas puede resultar costosa de calcular. 
  Por ello se suele realizar el cálculo de colisiones con una forma aproximada 
  de los <em>sprites</em> con la que esta operación resulte más 
  sencilla. Para ello solemos utilizar el <em>bounding box</em>, es decir, un 
  rectángulo que englobe el <em>sprite</em>. La intersección de 
  rectángulos es una operación muy sencilla. </p>
<p>La clase <code>Sprite</code> contiene un método <code>getBoundingBox</code> que
nos devuelve un objeto <code>Rect</code> que representa la caja en la que el
<em>sprite</em> está contenido. Con la función <code>intersectsRect</code> podemos
comprobar de forma sencilla y eficiente si dos rectángulos colisionan:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Rect</span> <span class="n">bbPersonaje</span> <span class="o">=</span> <span class="n">spritePersonaje</span><span class="o">-&gt;</span><span class="n">getBoundingBox</span><span class="p">();</span>
<span class="n">Rect</span> <span class="n">bbEnemigo</span> <span class="o">=</span> <span class="n">spriteEnemigo</span><span class="o">-&gt;</span><span class="n">getBoundingBox</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="n">bbPersonaje</span><span class="p">.</span><span class="n">intersectsRect</span><span class="p">(</span><span class="n">bbEnemigo</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Game over</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
<h2 id="motor-del-juego">Motor del juego<a class="headerlink" href="#motor-del-juego" title="Permanent link">¶</a></h2>
<p>El componente básico del motor de un videojuego es lo que se conoce como ciclo del juego
(<em>game loop</em>). Vamos a ver a continuación en qué consiste este ciclo. </p>
<h3 id="ciclo-del-juego">Ciclo del juego<a class="headerlink" href="#ciclo-del-juego" title="Permanent link">¶</a></h3>
<p>Se trata de un bucle infinito en el que tendremos el código 
  que implementa el funcionamiento del juego. Dentro de este bucle se efectúan 
  las siguientes tareas básicas:</p>
<ul>
<li>
<p><strong>Leer la entrada</strong>: Lee la entrada del usuario para conocer 
    si el usuario ha pulsado alguna tecla desde la última iteración.</p>
</li>
<li>
<p><strong>Actualizar escena</strong>: Actualiza las posiciones de los <em>sprites</em> 
    y su fotograma actual, en caso de que estén siendo animados, la posición 
    del fondo si se haya producido <em>scroll</em>, y cualquier otro elemento 
    del juego que deba cambiar. Para hacer esta actualización se pueden 
    tomar diferentes criterios. Podemos mover el personaje según la entrada 
    del usuario, la de los enemigos según su inteligencia artificial, o 
    según las interacciones producidas entre ellos y cualquier otro objeto 
    (por ejemplo al ser alcanzados por un disparo, colisionando el <em>sprite</em> 
    del disparo con el del enemigo), etc.</p>
</li>
<li>
<p><strong>Redibujar</strong>: Tras actualizar todos los elementos del juego, 
    deberemos redibujar la pantalla para mostrar la escena tal como ha quedado 
    en el instante actual. </p>
</li>
<li>
<p><strong>Dormir</strong>: Normalmente tras cada iteración dormiremos 
    un determinado número de milisegundos para controlar la velocidad a 
    la que se desarrolla el juego. De esta forma podemos establecer a cuantos 
    fotogramas por segundo (<em>fps</em>) queremos que funcione el juego, siempre 
    que la CPU sea capaz de funcionar a esta velocidad.</p>
</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">leeEntrada</span><span class="p">();</span>
    <span class="n">actualizaEscena</span><span class="p">();</span>
    <span class="n">dibujaGraficos</span><span class="p">();</span>   
<span class="p">}</span>
</pre></div>
</td></tr></table>
<p>Este ciclo no siempre deberá comportarse siempre de la misma forma. 
  El juego podrá pasar por distintos estados, y en cada uno de ellos deberán 
  el comportamiento y los gráficos a mostrar serán distintos (por ejemplo, las pantallas
  de menú, selección de nivel, juego, <em>game over</em>, etc).
Podemos modelar esto como una máquina de estados, en la que en cada 
  momento, según el estado actual, se realicen unas funciones u otras, 
  y cuando suceda un determinado evento, se pasará a otro estado.</p>
<h3 id="actualizacion-de-la-escena">Actualización de la escena<a class="headerlink" href="#actualizacion-de-la-escena" title="Permanent link">¶</a></h3>
<p>En Cocos2D no deberemos preocuparnos de implementar el ciclo del juego, ya que de esto
se encarga el <em>singleton</em> <code>Director</code>. Los estados del juego se
controlan mediante las escenas (<code>Scene</code>). En un momento dado, el ciclo de
juego sólo actualizará y mostrará los gráficos de la escena actual. Dicha escena dibujará
los gráficos a partir de los nodos que hayamos añadido a ella como hijos.</p>
<p>Ahora nos queda ver cómo actualizar dicha escena en cada iteración del ciclo del juego, 
por ejemplo, para ir actualizando la posición de cada personaje, o comprobar si existen
colisiones entre diferentes <em>sprites</em>. La escena tiene un método 
<code>schedule</code> que permite especificar un método al que
se llamará en cada iteración del ciclo. De esa forma, podremos especificar en dicho método la forma de actualizar la escena:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">scene</span><span class="o">-&gt;</span><span class="n">schedule</span><span class="p">(</span><span class="n">CC_SCHEDULE_SELECTOR</span><span class="p">(</span><span class="n">Game</span><span class="o">::</span><span class="n">update</span><span class="p">));</span>
</pre></div>
</td></tr></table>
<p>Tendremos que definir un método <code>update</code> donde introduciremos el código
que se encargará de actualizar la escena. Como parámetro recibe el tiempo transcurrido desde
la anterior actualización (desde la anterior iteración del ciclo del juego). Deberemos aprovechar
este dato para actualizar los movimientos a partir de él, y así conseguir un movimiento fluido
y constante:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">update</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_sprite</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">_sprite</span><span class="o">-&gt;</span><span class="n">getPosition</span><span class="p">()</span> <span class="o">+</span> <span class="n">Vec2</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
<p>En este caso estamos moviendo el <em>sprite</em> en <em>x</em> a una velocidad de 100 pixeles por
segundo (el tiempo transcurrido se proporciona en segundos). </p>
<blockquote>
<p>Es importante remarcar que tanto el dibujado como las actualizaciones sólo se 
llevarán a cabo cuando la escena en la que están sea la escena que está ejecutando actualmente
el <code>Director</code>. Así es como se controla el estado del juego.</p>
</blockquote>
<p>Existe otra versión del método <code>schedule</code> que nos permite proporcionar el método a llamar mediante una función lambda. En este caso deberemos indicar también un identificador para nuestra función, para así poder cancelar su planificación:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">scene</span><span class="o">-&gt;</span><span class="n">schedule</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>        
<span class="p">},</span> <span class="s">"ia"</span><span class="p">);</span>
</pre></div>
</td></tr></table>
<p>A esta planificación le hemos dado el identificador <code>"ia"</code>. Podremos cancelarla llamando a <code>unschedule("ia")</code>. </p>
<p>Si no queremos tener que especificar la función de forma <em>inline</em>, también podemos especificarla de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">scene</span><span class="o">-&gt;</span><span class="n">schedule</span><span class="p">(</span><span class="n">CC_CALLBACK_1</span><span class="p">(</span><span class="n">Game</span><span class="o">::</span><span class="n">update</span><span class="p">,</span> <span class="k">this</span><span class="p">),</span> <span class="s">"ia"</span><span class="p">);</span>
</pre></div>
</td></tr></table>
<h3 id="acciones">Acciones<a class="headerlink" href="#acciones" title="Permanent link">¶</a></h3>
<p>En el punto anterior hemos visto cómo actualizar la escena de forma manual como se hace habitualmente
en el ciclo del juego. Sin embargo, con Cocos2D tenemos formas más sencillas de animar los nodos de 
la escena, son lo que se conoce como <strong>acciones</strong>. Estas acciones nos permiten definir
determinados comportamientos, como trasladarse a un determinado punto, y aplicarlos sobre un nodo
para que realice dicha acción de forma automática, sin tener que actualizar su posición manualmente
en cada iteración (<em>tick</em>) del juego.</p>
<p>Todas las acciones derivan de la clase <code>Action</code>. Encontramos acciones instantáneas 
(como por ejemplo situar un <em>sprite</em> en una posición determinada), o acciones con una duración
(mover al <em>sprite</em> hasta la posición destino gradualmente).</p>
<p>Por ejemplo, para mover un nodo a la posición <em>(200, 50)</em> en 3 segundos, podemos definir una 
acción como la siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">MoveTo</span> <span class="o">*</span><span class="n">actionMoveTo</span> <span class="o">=</span> <span class="n">MoveTo</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Vec2</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">50</span><span class="p">));</span>
</pre></div>
</td></tr></table>
<p>Para ejecutarla, deberemos aplicarla sobre el nodo que queremos mover:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">sprite</span><span class="o">-&gt;</span><span class="n">runAction</span><span class="p">(</span><span class="n">actionMoveTo</span><span class="p">);</span>
</pre></div>
</td></tr></table>
<p>Podemos ejecutar varias acciones de forma simultánea sobre un mismo nodo. Si queremos detener todas
las acciónes que pudiera haber en marcha hasta el momento, podremos hacerlo con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">sprite</span><span class="o">-&gt;</span><span class="n">stopAllActions</span><span class="p">();</span>
</pre></div>
</td></tr></table>
<p>Además, tenemos la posibilidad de encadenar varias acciones mediante el tipo especial de acción
<code>Sequence</code>. En el siguiente ejemplo primero situamos el <em>sprite</em> de forma
inmediata en <em>(0, 50)</em>, y después lo movermos a <em>(200, 50)</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Place</span> <span class="o">*</span><span class="n">actionPlace</span> <span class="o">=</span> <span class="n">Place</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">));</span>
<span class="n">MoveTo</span> <span class="o">*</span><span class="n">actionMoveTo</span> <span class="o">=</span> <span class="n">MoveTo</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Vec2</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">50</span><span class="p">));</span>

<span class="n">Sequence</span> <span class="o">*</span><span class="n">actionSequence</span> <span class="o">=</span> 
    <span class="n">Sequence</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">actionPlace</span><span class="p">,</span> <span class="n">actionMoveTo</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="n">sprite</span><span class="o">-&gt;</span><span class="n">runAction</span><span class="p">(</span><span class="n">actionSequence</span><span class="p">);</span>
</pre></div>
</td></tr></table>
<p>Incluso podemos hacer que una acción (o secuencia de acciones) se repita un determinado número
de veces, o de forma indefinida:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">RepeatForever</span> <span class="o">*</span><span class="n">actionRepeat</span> <span class="o">=</span> 
    <span class="n">RepeatForever</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">actionSequence</span><span class="p">);</span>
<span class="n">sprite</span><span class="o">-&gt;</span><span class="n">runAction</span><span class="p">(</span><span class="n">actionRepeat</span><span class="p">);</span>
</pre></div>
</td></tr></table>
<p>De esta forma, el <em>sprite</em> estará continuamente moviéndose de <em>(0,50)</em> a <em>(200,50)</em>.
Cuando llegue a la posición final volverá a aparecer en la inicial y continuará la animación.</p>
<p>Podemos aprovechar este mecanismo de acciones para definir las animaciones de fotogramas de los
<em>sprites</em>, con una acción de tipo <code>Animate</code>. Crearemos la acción de animación
a partir de una animación de la caché de animaciones:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Animate</span> <span class="o">*</span><span class="n">animate</span> <span class="o">=</span> <span class="n">Animate</span><span class="o">::</span><span class="n">create</span><span class="p">(</span>
    <span class="n">AnimationCache</span><span class="o">::</span><span class="n">sharedAnimationCache</span><span class="p">()</span>
        <span class="o">-&gt;</span><span class="n">animationByName</span><span class="p">(</span><span class="s">"animAndar"</span><span class="p">));</span>

<span class="n">sprite</span><span class="o">-&gt;</span><span class="n">runAction</span><span class="p">(</span><span class="n">RepeatForever</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">animate</span><span class="p">));</span>
</pre></div>
</td></tr></table>
<p>Con esto estaremos reproduciendo continuamente la secuencia de fotogramas definida en la animación,
utilizando la periodicidad (<em>delayPerUnit</em>) que especificamos al crear dicha animación.</p>
<p>Encontramos también acciones que nos permiten realizar tareas personalizadas, proporcionando mediante una pareja
<em>target-selector</em> la función a la que queremos que se llame cuando se produzca la acción:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">CallFunc</span> <span class="o">*</span><span class="n">actionCall</span> <span class="o">=</span> 
    <span class="n">CallFunc</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">CC_CALLBACK_0</span><span class="p">(</span><span class="n">Game</span><span class="o">::</span><span class="n">accionCallback</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</pre></div>
</td></tr></table>
<p>Deberemos definir en nuestra clase el método de <em>callback</em> a llamar. En el caso del
ejemplo anterior sería:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">accionCallback</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
<p>Otra opción es pasar directamente una función <em>lambda</em> como parámetro:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">CallFunc</span><span class="o">::</span><span class="n">create</span><span class="p">([</span><span class="o">=</span><span class="p">]</span> <span class="p">{</span>
    <span class="p">...</span>            
<span class="p">});</span>
</pre></div>
</td></tr></table>
<p>También encontramos variantes de esta acción que nos permiten pasarle al <em>callback</em>
como parámetro datos propios o el nodo sobre el que se ha ejecutado la acción (<code>CallFuncN</code> recibe el nodo como parámetro, y <code>CallFundND</code> recibe el nodo y un puntero a datos genéricos). Cuanto tengamos que pasar un <em>callback</em> con parámetros utilizaremos <code>CC_CALLBACK_1</code>, <code>CC_CALLBACK_2</code> y <code>CC_CALLBACK_3</code>, para 1, 2 y 3 parámetros respectivamente.</p>
<p>Encontramos gran cantidad de acciones disponibles, que nos permitirán crear diferentes efectos (fundido, tinte,
rotación, escalado), e incluso podríamos crear nuestras propias acciones mediante subclases de <code>Action</code>.</p>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a class="md-flex md-footer-nav__link md-footer-nav__link--prev" href="introduccion_a_cocos2d-x.html" rel="prev" title="El motor Cocos2d-x">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
                  Anterior
                </span>
                El motor Cocos2d-x
              </span>
</div>
</a>
<a class="md-flex md-footer-nav__link md-footer-nav__link--next" href="escenario_y_fondos.html" rel="next" title="Escenario y fondos">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
                  Siguiente
                </span>
                Escenario y fondos
              </span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
</div>
</div>
</div>
</footer>
</div>
<script src="assets/javascripts/application.245445c6.js"></script>
<script>app.initialize({version:"1.0.4",url:{base:"."}})</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>