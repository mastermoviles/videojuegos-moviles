



<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copiar al portapapeles">
      
        <meta name="lang:clipboard.copied" content="Copiado al portapapeles">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No se encontraron documentos">
      
        <meta name="lang:search.result.one" content="1 documento encontrado">
      
        <meta name="lang:search.result.other" content="# documentos encontrados">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.4.0">
    
    
      
        <title>Adaptación a diferentes dispositivos - Videojuegos para Dispositivos Móviles</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/application.0284f74d.css">
      
        <link rel="stylesheet" href="assets/stylesheets/application-palette.01803549.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
      <script src="assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#adaptacion-a-moviles" tabindex="1" class="md-skip">
        Saltar a contenido
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="index.html" title="Videojuegos para Dispositivos Móviles" class="md-header-nav__button md-logo">
          
            <img src="imagenes/logo.png" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              Videojuegos para Dispositivos Móviles
            </span>
            <span class="md-header-nav__topic">
              
                Adaptación a diferentes dispositivos
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Teclee para comenzar búsqueda
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="index.html" title="Videojuegos para Dispositivos Móviles" class="md-nav__button md-logo">
      
        <img src="imagenes/logo.png" width="48" height="48">
      
    </a>
    Videojuegos para Dispositivos Móviles
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="index.html" title="Presentación" class="md-nav__link">
      Presentación
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="videojuegos_para_moviles.html" title="Introducción a los videojuegos móviles" class="md-nav__link">
      Introducción a los videojuegos móviles
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Fundamentos de los motores
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Fundamentos de los motores
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="fundamentos-motores.html" title="Escena y nodos" class="md-nav__link">
      Escena y nodos
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="motor_de_fisicas.html" title="Físicas" class="md-nav__link">
      Físicas
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="sprites_e_interaccion.html" title="_Sprites_" class="md-nav__link">
      _Sprites_
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="escenario_y_fondos.html" title="Fondo y _scroll_" class="md-nav__link">
      Fondo y _scroll_
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Motores para  móviles
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Motores para  móviles
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="spritekit.html" title="SpriteKit" class="md-nav__link">
      SpriteKit
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="scenekit.html" title="SceneKit" class="md-nav__link">
      SceneKit
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="cocos2d-x.html" title="Cocos2d-x" class="md-nav__link">
      Cocos2d-x
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="unity.html" title="Unity" class="md-nav__link">
      Unity
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="box2d.html" title="Box2D" class="md-nav__link">
      Box2D
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="mandos.html" title="Controles del videojuego" class="md-nav__link">
      Controles del videojuego
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Adaptación a diferentes dispositivos
      </label>
    
    <a href="adaptacion_a_moviles.html" title="Adaptación a diferentes dispositivos" class="md-nav__link md-nav__link--active">
      Adaptación a diferentes dispositivos
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#resoluciones-de-recursos-diseno-y-pantalla" title="Resoluciones de recursos, diseño y pantalla" class="md-nav__link">
    Resoluciones de recursos, diseño y pantalla
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gestion-de-recursos" title="Gestión de recursos" class="md-nav__link">
    Gestión de recursos
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#estrategias-de-adaptacion" title="Estrategias de adaptación" class="md-nav__link">
    Estrategias de adaptación
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#estrategia-no_border" title="Estrategia NO_BORDER" class="md-nav__link">
    Estrategia NO_BORDER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estrategias-fixed_width-y-fixed_height" title="Estrategias FIXED_WIDTH y FIXED_HEIGHT" class="md-nav__link">
    Estrategias FIXED_WIDTH y FIXED_HEIGHT
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#posicionamiento-de-los-elementos-de-la-gui" title="Posicionamiento de los elementos de la GUI" class="md-nav__link">
    Posicionamiento de los elementos de la GUI
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#componentes-de-la-gui-de-cocos2d-x" title="Componentes de la GUI de cocos2d-x" class="md-nav__link">
    Componentes de la GUI de cocos2d-x
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#imagenes-nine-patch" title="Imágenes nine-patch" class="md-nav__link">
    Imágenes nine-patch
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alineacion-con-los-bordes-de-la-pantalla" title="Alineación con los bordes de la pantalla" class="md-nav__link">
    Alineación con los bordes de la pantalla
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#menus" title="Menús" class="md-nav__link">
    Menús
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#depuracion-del-cambio-de-densidad-de-pantalla" title="Depuración del cambio de densidad de pantalla" class="md-nav__link">
    Depuración del cambio de densidad de pantalla
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#compilacion-condicional" title="Compilación condicional" class="md-nav__link">
    Compilación condicional
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#optimizacion-de-texturas" title="Optimización de texturas" class="md-nav__link">
    Optimización de texturas
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="redes_sociales.html" title="Logros y marcadores" class="md-nav__link">
      Logros y marcadores
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#resoluciones-de-recursos-diseno-y-pantalla" title="Resoluciones de recursos, diseño y pantalla" class="md-nav__link">
    Resoluciones de recursos, diseño y pantalla
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gestion-de-recursos" title="Gestión de recursos" class="md-nav__link">
    Gestión de recursos
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#estrategias-de-adaptacion" title="Estrategias de adaptación" class="md-nav__link">
    Estrategias de adaptación
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#estrategia-no_border" title="Estrategia NO_BORDER" class="md-nav__link">
    Estrategia NO_BORDER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estrategias-fixed_width-y-fixed_height" title="Estrategias FIXED_WIDTH y FIXED_HEIGHT" class="md-nav__link">
    Estrategias FIXED_WIDTH y FIXED_HEIGHT
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#posicionamiento-de-los-elementos-de-la-gui" title="Posicionamiento de los elementos de la GUI" class="md-nav__link">
    Posicionamiento de los elementos de la GUI
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#componentes-de-la-gui-de-cocos2d-x" title="Componentes de la GUI de cocos2d-x" class="md-nav__link">
    Componentes de la GUI de cocos2d-x
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#imagenes-nine-patch" title="Imágenes nine-patch" class="md-nav__link">
    Imágenes nine-patch
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alineacion-con-los-bordes-de-la-pantalla" title="Alineación con los bordes de la pantalla" class="md-nav__link">
    Alineación con los bordes de la pantalla
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#menus" title="Menús" class="md-nav__link">
    Menús
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#depuracion-del-cambio-de-densidad-de-pantalla" title="Depuración del cambio de densidad de pantalla" class="md-nav__link">
    Depuración del cambio de densidad de pantalla
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#compilacion-condicional" title="Compilación condicional" class="md-nav__link">
    Compilación condicional
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#optimizacion-de-texturas" title="Optimización de texturas" class="md-nav__link">
    Optimización de texturas
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="adaptacion-a-moviles">Adaptación a móviles<a class="headerlink" href="#adaptacion-a-moviles" title="Permanent link">&para;</a></h1>
<p>Una de las principales problemáticas en el desarrollo de dispositivos móviles es la
gran diferencia de tamaños de pantalla existentes, con distinta resolución y relación de aspecto. Esto plantea diferentes problemas:</p>
<ul>
<li><strong>Tamaño de los recursos</strong>: Con esto nos referimos a la resolución que deberían tener recursos como los <em>sprites</em> o <em>tilemaps</em>. Un enfoque sencillo podría ser proporcionar estos recursos a resolución máxima, para así aprovechar las pantallas de mayor resolución. El problema es que los dispositivos con menor resolución disponen también de una menor memoria de vídeo, por lo que es probable que no puedan albergar las texturas necesarias en resolución máxima. Por este motivo será conveniente proporcionar diferentes versiones de los recursos para diferentes resoluciones de pantalla.</li>
<li><strong>Sistema de coordenadas</strong>: Debemos evitar utilizar un sistema de coordenadas en pixels, ya que el tamaño de la pantalla cambiará en cada dispositivo. Lo que se hará es utilizar siempre un sistema de coordenadas del mismo tamaño independientemente de la resolución del dispositivo en el que se vaya a ejecutar el juego. Hablaremos en este caso de un sistema de coordenadas en puntos (en lugar de pixels). El tamaño de cada punto dependerá de la resolución real de la pantalla del dispositivo utilizado.</li>
<li><strong>Relación de aspecto</strong>: A pesar de trabajar en puntos para que las dimensiones del sistema de coordenadas utilizado sean siempre las mismas, tenemos el problema de que la relación de aspecto puede ser distinta. Para resolver esto podemos añadir un borde cuando la relación de aspecto del dispositivo no coincide con la que se ha utilizado en el diseño, estirar la pantalla a pesar de deformar la imagen, o bien recortarla en alguna de sus dimensiones. Esta última opción será la más adecuada, pero deberemos llevar cuidado de hacerlo de forma correcta y diseñar el juego de forma que sobre suficiente espacio como para que se pueda aplicar el recorte sin problemas.</li>
</ul>
<p>Vamos a ver a continuación cómo implementar todo lo anterior en Cocos2d-x.</p>
<h2 id="resoluciones-de-recursos-diseno-y-pantalla">Resoluciones de recursos, diseño y pantalla<a class="headerlink" href="#resoluciones-de-recursos-diseno-y-pantalla" title="Permanent link">&para;</a></h2>
<p>Para resolver el problema de los distintos tamaños de pantalla en Cocos2d-x lo que haremos será definir tres resoluciones distintas:</p>
<ul>
<li><strong>Resolución de recursos</strong>: Resolución para la que están preparados los recursos utilizados.</li>
<li><strong>Resolución de diseño</strong>: Resolución para la que hemos diseñado el juego. Será esta resolución la que utilizaremos en el código del juego (resolución en puntos).</li>
<li><strong>Resolución de pantalla</strong>: Resolución real de la pantalla del dispositivo.</li>
</ul>
<p>En el objeto <code>AppDelegate</code> se inicializa el juego. Este es un buen punto para configurar las resoluciones anteriores. Por ejemplo, podemos definir esta configuración de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Size</span> <span class="n">screenSize</span> <span class="o">=</span> <span class="n">director</span><span class="o">-&gt;</span><span class="n">getOpenGLView</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getFrameSize</span><span class="p">();</span>
<span class="n">Size</span> <span class="nf">designSize</span><span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">320</span><span class="p">);</span>
<span class="n">Size</span> <span class="nf">resourceSize</span><span class="p">(</span><span class="mi">960</span><span class="p">,</span> <span class="mi">640</span><span class="p">);</span>

<span class="c1">// Establecemos la resolución de recursos</span>
<span class="n">director</span><span class="o">-&gt;</span><span class="n">setContentScaleFactor</span><span class="p">(</span><span class="n">resourceSize</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="n">designSize</span><span class="p">.</span><span class="n">width</span><span class="p">);</span>

<span class="c1">// Establecemos la resolución de diseño (puntos)</span>
<span class="n">cocos2d</span><span class="o">::</span><span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getOpenGLView</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setDesignResolutionSize</span><span class="p">(</span>
                                     <span class="mi">320</span><span class="p">,</span> <span class="mi">480</span><span class="p">,</span> <span class="n">ResolutionPolicy</span><span class="o">::</span><span class="n">FIXED_WIDTH</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>En este ejemplo hemos especificado:</p>
<ul>
<li><strong>Resolución de recursos</strong>: 960 x 640</li>
<li><strong>Resolución de diseño</strong>: 480 x 320</li>
</ul>
<p>Las reglas que seguiremos para trabajar con estas resoluciones son:</p>
<ul>
<li>En el código del juego siempre utilizaremos la <strong>resolución de diseño</strong>. Es decir, en el ejemplo anterior consideraremos que siempre tenemos una resolución de 480 x 320 puntos al posicionar <em>sprites</em>, ubicar elementos del HUD, mostrar elementos del escenario, etc. El contenido que hayamos dibujado en el espacio de diseño se estirará para ocupar toda la pantalla.</li>
</ul>
<p><img alt="Resolución de diseño y resolución de pantalla" src="imagenes/adaptacion/pantalla_disenyo.png" /></p>
<ul>
<li>La <strong>resolución de recursos</strong> nos indica la resolución de pantalla para la que están preparados los recursos en el caso ideal, es decir, en el que cada píxel de la imagen del recurso corresponde exactamente a un píxel en pantalla. En el caso de nuestro ejemplo, la resolución para la que están preparados los recursos es el doble que la resolución de diseño. Es decir, un <em>sprite</em> cuya imagen tenga 80 x 80 pixels que esté pensado para que se dibuje con su tamaño original en una pantalla de 960 x 640, en un espacio de diseño de 480 x 320 ocuparía un espacio de 40 x 40 puntos. Decimos en este caso que su <em>factor de escala</em> es 2.0, ya cada punto de nuestro espacio de diseño corresponde a 2 x 2 pixels de la imagen del recurso. Si la resolución real de pantalla fuera de 480 x 320, coincidiendo con la resolución de diseño, la imagen del <em>sprite</em> tendrá que escalarse a mitad de tamaño (reduciendo la definición de la imagen original a la mitad, ya que la definición del <em>sprite</em> es mayor de lo que nos permite mostrar la pantalla); en el caso de tener una resolución de pantalla de 960 x 640 el <em>sprite</em> se mostraría en su tamaño real con todos sus <em>pixels</em> (aunque en el código lo posicionemos y obtengamos su tamaño en puntos); y si contamos con una pantalla de 1920 x 1280 el <em>sprite</em> tendría que escalarse al doble de su tamaño (en este caso la resolución del <em>sprite</em> no sería suficiente para aprovechar toda la definición de la pantalla).</li>
</ul>
<p><img alt="Resolución de recursos" src="imagenes/adaptacion/pantalla_recursos.png" /></p>
<p>Con esto podemos ver que aunque trabajemos con una resolución de diseño pequeña, esto no implica que el juego se vaya a ver con poca resolución. Ésta resolución de diseño simplemente es un sistema de coordenadas de referencia para situar los objetos en la escena. La resolución que realmente determinará la definición de los gráficos del juego es la resolución de recursos.</p>
<p>Con el método <code>Director::setContentScaleFactor</code> estableceremos la relación existente entre la relación de recursos y la de diseño. Por ejemplo, si la resolución de recursos es el doble que la de diseño, el factor de escala será 2. En caso de que la relación de aspecto de estas resoluciones no coincidiese, tendríamos que decidir si tomar como referencia el alto o el ancho de la imagen a la hora de calcular el factor de escala.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// Tomamos como referencia el ancho</span>
<span class="n">director</span><span class="o">-&gt;</span><span class="n">setContentScaleFactor</span><span class="p">(</span><span class="n">resourceSize</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="n">designSize</span><span class="p">.</span><span class="n">width</span><span class="p">);</span>

<span class="c1">// Tomamos como referencia el alto</span>
<span class="n">director</span><span class="o">-&gt;</span><span class="n">setContentScaleFactor</span><span class="p">(</span><span class="n">resourceSize</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="n">designSize</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<h2 id="gestion-de-recursos">Gestión de recursos<a class="headerlink" href="#gestion-de-recursos" title="Permanent link">&para;</a></h2>
<p>En el apartado anterior hemos visto cómo establecer la resolución de los recursos. Sin embargo, como ya hemos comentado anteriormente, es difícil tener una única resolución de recursos que sea adecuada para todos los dispositivos: dispositivos de alta densidad necesitan recursos con mayor resolución para aprovechar la densidad de pantalla, y dispositivos con menor densidad de pantalla normalmente tienen una memoria de vídeo más limitada donde puede que no quepan los recursos necesarios. Por ello es conveniente suministrar diferentes versiones de los recursos.</p>
<p>Para soportar distintas versiones de un mismo recurso lo que haremos es guardarlo en diferentes directorios pero con el mismo nombre de fichero.
Por ejemplo, podemos crear un directorio <code>sd</code> para la versión normal y otro directorio <code>hd</code> para la versión para dispositivos de alta resolución. Ambos directorios tendrán los mismos ficheros de texturas, pero con distintas resoluciones. Lo que deberemos hacer es indicar al motor dónde buscar los recursos en función de la resolución:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Size</span> <span class="n">screenSize</span> <span class="o">=</span> <span class="n">director</span><span class="o">-&gt;</span><span class="n">getOpenGLView</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getFrameSize</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">searchPaths</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">screenSize</span><span class="p">.</span><span class="n">height</span> <span class="o">&gt;</span> <span class="mi">320</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// iPhone retina</span>
    <span class="n">searchPaths</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;hd&quot;</span><span class="p">);</span>
    <span class="n">searchPaths</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;comun&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span> <span class="c1">// iPhone</span>
    <span class="n">searchPaths</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;sd&quot;</span><span class="p">);</span>
    <span class="n">searchPaths</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;comun&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">FileUtils</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setSearchPaths</span><span class="p">(</span><span class="n">searchPaths</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>En el ejemplo anterior, en el caso del iPhone retina buscará primero los recursos en el directorio <code>hd</code>, y si no los encuentra ahí buscará en <code>comun</code>. En caso caso de tener menor resolución buscará primero en <code>sd</code> y después en <code>comun</code>.</p>
<p>Una vez decidida la versión de los recursos que se va a utilizar, deberemos indicar al motor la resolución de recursos correcta para que así los escale de forma adecuada:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Size</span> <span class="n">screenSize</span> <span class="o">=</span> <span class="n">director</span><span class="o">-&gt;</span><span class="n">getOpenGLView</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getFrameSize</span><span class="p">();</span>
<span class="n">Size</span> <span class="n">designSize</span> <span class="o">=</span> <span class="n">Size</span><span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">320</span><span class="p">);</span>
<span class="n">Size</span> <span class="n">resourceSize</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">searchPaths</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">screenSize</span><span class="p">.</span><span class="n">height</span> <span class="o">&gt;</span> <span class="mi">320</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// iPhone retina</span>
    <span class="n">searchPaths</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;hd&quot;</span><span class="p">);</span>
    <span class="n">searchPaths</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;comun&quot;</span><span class="p">);</span>
    <span class="n">resourceSize</span> <span class="o">=</span> <span class="n">Size</span><span class="p">(</span><span class="mi">960</span><span class="p">,</span> <span class="mi">640</span><span class="p">);</span>          
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span> <span class="c1">// iPhone</span>
    <span class="n">searchPaths</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;sd&quot;</span><span class="p">);</span>
    <span class="n">searchPaths</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;comun&quot;</span><span class="p">);</span>
    <span class="n">resourceSize</span> <span class="o">=</span> <span class="n">Size</span><span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">320</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">FileUtils</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setSearchPaths</span><span class="p">(</span><span class="n">searchPaths</span><span class="p">);</span>
<span class="n">director</span><span class="o">-&gt;</span><span class="n">setContentScaleFactor</span><span class="p">(</span><span class="n">resourceSize</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="n">designSize</span><span class="p">.</span><span class="n">width</span><span class="p">);</span>

<span class="n">director</span><span class="o">-&gt;</span><span class="n">getOpenGLView</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setDesignResolutionSize</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span> <span class="mi">480</span><span class="p">,</span> <span class="n">ResolutionPolicy</span><span class="o">::</span><span class="n">FIXED_WIDTH</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<h2 id="estrategias-de-adaptacion">Estrategias de adaptación<a class="headerlink" href="#estrategias-de-adaptacion" title="Permanent link">&para;</a></h2>
<p>Con el método <code>setDesignResolutionSize</code> establecemos la resolución de diseño a utilizar en el juego. Además el tercer parámetro permite indicar la forma de adaptar la resolución de diseño a la resolución de pantalla cuando la relación de aspecto de ambas resoluciones no coincida. Encontramos las siguientes estrategias:</p>
<ul>
<li><code>ResolutionPolicy::SHOW_ALL</code>: Hace que todo el contenido de la resolución de diseño quede dentro de la pantalla, dejando franjas negras en los laterales si la relación de aspecto no es la misma. Estas franjas negras hacen que desperdiciemos espacio de pantalla y causan un efecto bastante negativo, por lo que a pesar de la sencillez de esta estrategia, <strong>no será recomendable</strong> si buscamos un producto con un buen acabado.</li>
<li><code>ResolutionPolicy::EXACT_FIT</code>: Hace que el contenido dentro de la resolución de diseño se estire para adaptarse a la resolución de pantalla, deformando el contenido si la relación de aspecto no es la misma. Aunque en este caso se llene la pantalla, la deformación de la imagen también causará muy mal efecto y por lo tanto debemos <strong>evitar utilizar esta técnica</strong>.</li>
<li><code>ResolutionPolicy::NO_BORDER</code>: Ajusta el contenido de la resolución de diseño a la resolución de pantalla, sin dejar borde y sin deformar el contenido, pero dejando parte de éste fuera de la pantalla si la relación de aspecto no coincide. En este caso no habrá problema si implementamos el juego de forma correcta, ayudándonos de los métodos <code>Director::getInstance()-&gt;getVisibleSize()</code> y <code>Director::getInstance()-&gt;getVisibleOrigin()</code> que nos darán el tamaño y el origen, respectivamente, de la zona visible de nuestra resolución de diseño. De esta forma deberemos asegurarnos de dibujar todos los componentes del HUD dentro de esta zona, y a la hora de implementar <em>scroll</em> lo alinearemos de forma correcta con el origen de la zona visible.</li>
<li><code>ResolutionPolicy::FIXED_HEIGHT</code>, <code>ResolutionPolicy::FIXED_WIDTH</code> modifican la resolución de diseño para que tenga la misma relación de aspecto que la resolución de pantalla, manteniendo fija la altura o la anchura de diseño respectivamente. Podremos consultar la resolución de diseño con <code>Director::getInstance()-&gt;getWinSize()</code>. En estos casos toda la resolución de diseño es visible en pantalla, pero ésta puede variar en altura o en anchura, según la estrategia indicada.</li>
</ul>
<p><img alt="Ejemplos de estrategias con una pantalla 4:3" src="imagenes/adaptacion/pantalla_4_3.png" /></p>
<p><img alt="Ejemplos de estrategias en una pantalla 16:9" src="imagenes/adaptacion/pantalla_16_9.png" /></p>
<p>¿Qué estrategia debemos utilizar? Dependerá de lo que busquemos en nuestro juego, pero normalmente nos quedaremos con <code>NO_BORDER</code>, <code>FIXED_HEIGHT</code> o <code>FIXED_WIDTH</code>.</p>
<h3 id="estrategia-no_border">Estrategia NO_BORDER<a class="headerlink" href="#estrategia-no_border" title="Permanent link">&para;</a></h3>
<p>Se trata de una estrategia adecuada por ejemplo para juegos de rol con vista cenital y <em>scroll</em> en cualquier dirección. El personaje estará centrado en pantalla y se podrá mover en cualquier dirección, así que nos da igual la parte que quede cortada siempre que en el caso de haber HUD nos aseguremos de dibujarlo dentro de la zona visible.</p>
<p>Para conseguir dibujar el HUD de forma adecuada con esta estrategia es importante tener en cuenta las propiedades <code>visibleOrigin</code> y <code>visibleSize</code>, que nos indicarán la zona de nuestra <em>espacio de diseño</em> que va a ser visible realmente en pantalla.</p>
<p><img alt="Zona visible con NO_BORDER" src="imagenes/adaptacion/pantalla_visible_size.png" /></p>
<h3 id="estrategias-fixed_width-y-fixed_height">Estrategias FIXED_WIDTH y FIXED_HEIGHT<a class="headerlink" href="#estrategias-fixed_width-y-fixed_height" title="Permanent link">&para;</a></h3>
<p>Estas dos estrategias, a diferencia de todas las demás, tienen la particularidad de modificar la resolución de diseño, manteniendo inalterado siempre al menos el ancho (<code>FIXED_WIDTH</code>) o el alto (<code>FIXED_HEIGHT</code>). Podemos consultar la resolución de diseño que ha resultado tras la modificación con la propiedad <code>winSize</code>.</p>
<p><img alt="Cambios en resolución de diseño" src="imagenes/adaptacion/pantalla_fixed.png" /></p>
<p>Si tenemos por ejemplo un plataformas de avance horizontal, normalmente querremos que la altura sea fija, por lo que <code>FIXED_HEIGHT</code> podría ser la opción más adecuada.</p>
<p><img alt="Juego de avance horizontal" src="imagenes/adaptacion/pantalla_fixed_height.png" /></p>
<p>Si por el contrario es un juego que avanza verticalmente (por ejemplo juegos de naves), será más adecuado <code>FIXED_WIDTH</code>.</p>
<p><img alt="Juego de avance vertical" src="imagenes/adaptacion/pantalla_fixed_width.png" /></p>
<h2 id="posicionamiento-de-los-elementos-de-la-gui">Posicionamiento de los elementos de la GUI<a class="headerlink" href="#posicionamiento-de-los-elementos-de-la-gui" title="Permanent link">&para;</a></h2>
<p>Hemos visto diferentes estrategias para adaptar el videojuego al tamaño de la pantalla del móvil, intentando preservar en la medida de lo posible la resolución de diseño. Esto es relativamente sencillo para juegos que cuentan con escenarios con <em>scroll</em> lateral, vertical, o ambos. Sin embargo, un elemento con el que deberemos llevar especial cuidado son los componentes de la GUI, como es el caso del HUD (marcador de puntuación, vidas restantes, energía, etc) y los menús del juego.</p>
<h3 id="componentes-de-la-gui-de-cocos2d-x">Componentes de la GUI de cocos2d-x<a class="headerlink" href="#componentes-de-la-gui-de-cocos2d-x" title="Permanent link">&para;</a></h3>
<p>En cocos2d-x encontramos una API bastante completa de elementos para la GUI, a la que tendremos acceso importando el fichero <code>ui/CocosGUI.h</code> y que está contenida bajo el espacio de nombres <code>ui</code>. En ella encontramos elementos como botones, listas, etiquetas de texto, paneles de <em>scroll</em>, imágenes o <em>sliders</em>, y podremos utilizarlos de la misma forma que el resto de nodos, aunque en estos casos normalmente contaremos con la posibilidad de programar eventos para las acciones que pueda realizar cada uno de estos <em>widgets</em>, como por ejemplo el evento de <em>click</em> de un botón.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">ui</span><span class="o">::</span><span class="n">Button</span> <span class="o">*</span><span class="n">button</span> <span class="o">=</span> <span class="n">ui</span><span class="o">::</span><span class="n">Button</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
<span class="n">button</span><span class="o">-&gt;</span><span class="n">loadTextures</span><span class="p">(</span><span class="s">&quot;boton_normal.png&quot;</span><span class="p">,</span> <span class="s">&quot;boton_pressed.png&quot;</span><span class="p">);</span>
<span class="n">button</span><span class="o">-&gt;</span><span class="n">setTitleText</span><span class="p">(</span><span class="s">&quot;Pause&quot;</span><span class="p">);</span>
<span class="n">button</span><span class="o">-&gt;</span><span class="n">setTitleFontName</span><span class="p">(</span><span class="s">&quot;Marker Felt&quot;</span><span class="p">);</span>
<span class="n">addChild</span><span class="p">(</span><span class="n">button</span><span class="p">);</span>

<span class="n">button</span><span class="o">-&gt;</span><span class="n">addTouchEventListener</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Ref</span><span class="o">*</span> <span class="n">sender</span><span class="p">,</span> <span class="n">ui</span><span class="o">::</span><span class="n">Widget</span><span class="o">::</span><span class="n">TouchEventType</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">type</span><span class="o">==</span><span class="n">ui</span><span class="o">::</span><span class="n">Widget</span><span class="o">::</span><span class="n">TouchEventType</span><span class="o">::</span><span class="n">ENDED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pausar</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</td></tr></table>

<h3 id="imagenes-nine-patch">Imágenes nine-patch<a class="headerlink" href="#imagenes-nine-patch" title="Permanent link">&para;</a></h3>
<p>Algunos elementos de la GUI de cocos2d-x, como los botones, soportan trabajar con imágenes <em>nine-patch</em>, con lo cual podemos hacer botones independientes del tamaño de su contenido. Para activar el modo <em>nine_patch</em>, deberemos proporcionar los límites de la región central (estirable) de la imagen mediante el método <code>setCapInsets</code>. Tras esto activaremos el modo <em>nine-patch</em> con <code>setScale9Enabled</code>. Ahora podremos cambiar el tamaño del contenido del <em>widget</em> <code>setContentSize</code> sin que se deformen las esquinas de la imagen.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">button</span><span class="o">-&gt;</span><span class="n">setCapInsets</span><span class="p">(</span><span class="n">Rect</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">26</span><span class="p">));</span>
<span class="n">button</span><span class="o">-&gt;</span><span class="n">setContentSize</span><span class="p">(</span><span class="n">button</span><span class="o">-&gt;</span><span class="n">getTitleRenderer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">()</span> <span class="o">+</span> <span class="n">Size</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">));</span>
<span class="n">button</span><span class="o">-&gt;</span><span class="n">setScale9Enabled</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<h3 id="alineacion-con-los-bordes-de-la-pantalla">Alineación con los bordes de la pantalla<a class="headerlink" href="#alineacion-con-los-bordes-de-la-pantalla" title="Permanent link">&para;</a></h3>
<p>Muchos elementos del HUD deberán estar alineados con las esquinas de la pantalla. Por ejemplo, nos puede interesar tener un botón de pausa en la esquina superior izquierda, y nuestra puntuación en la esquina superior derecha. Para alinear estos elementos de forma correcta, lo más adecuado será ajustar convenientemente la propiedad <code>anchorPoint</code> del nodo, que contendrá unas coordenadas relativas (de 0 a 1) al tamaño del nodo, indicando qué punto del nodo coincidirá con la posición donde lo ubiquemos en pantalla (<code>position</code>). En el eje de las <em>x</em>, el valor <code>0</code> hace referencia al lado izquierda, <code>0.5</code> al centro, y <code>1</code> al lado derecho. En el eje de las <em>y</em>, el valor <code>0</code> representa la parte inferior del nodo, <code>0.5</code> la mitad, y <code>1</code> la parte superior.  </p>
<p><img alt="HUD del juego" src="imagenes/adaptacion/gui.png" /></p>
<p>Por ejemplo, para un elemento que vaya a estar en la esquina superior izquierda, un valor correcto para el <code>anchorPoint</code> sería <code>(0,1)</code>, para que así cuando lo ubiquemos en dicha posición sea su esquina superior izquierda la que coincida con la esquina de la pantalla.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Size</span> <span class="n">visibleSize</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getVisibleSize</span><span class="p">();</span>
<span class="n">Vec2</span> <span class="n">origin</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getVisibleOrigin</span><span class="p">();</span>

<span class="n">button</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">));</span>
<span class="n">button</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">visibleSize</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="mi">5</span><span class="p">));</span>    
</pre></div>
</td></tr></table>

<p>Por otro lado, si queremos que el elemento quede alineado en la esquina superior derecha, será mejor especificar como <code>anchorPoint</code> el valor <code>(1,1)</code>, para que así al ubicarlo en dicha posición sea su esquina superior derecha. Aunque el nodo cambie de tamaño, su esquina superior derecha siempre se mantendrá en el mismo punto en pantalla.</p>
<p>Para los elementos con texto variable, como por ejemplo la puntuación, cuando los ajustemos a la derecha será conveniente que reservemos espacio suficiente para todos los valores que queramos que pueda tomar, para que así al ir aumentando el número de dígitos de la puntuación no se vaya desplazando el texto. En este caso puede ser recomendable utilizar una fuente monoespaciada y rellenar con ceros el número máximo de dígitos que queramos que pueda tener. Por ejemplo, <code>SCORE: 00010</code>.</p>
<h3 id="menus">Menús<a class="headerlink" href="#menus" title="Permanent link">&para;</a></h3>
<p>A parte del HUD, los menús del juego son otro elemento con el que deberemos llevar especial cuidado. En este caso lo normal será tener centrados los <em>items</em> del menú en pantalla, habitualmente con una disposición vertical. Los botones del menú (y todos los botones de la interfaz en general) deberán tener un tamaño suficiente para abarcar la yema del dedo en cualquier dispositivo. Esto nos llevará a tener en el móvil botones que ocuparán gran parte de la pantalla. Si trasladamos la aplicación a un <em>tablet</em>, la estrategia de cocos2d-x será la de escalar la pantalla, lo cual puede producir que los menús se vean innecesariamente grandes.</p>
<p>Podemos plantearnos la posibilidad de implementar menús alternativos para teléfonos y <em>tablets</em>, que aprovechen en cada caso la pantalla de forma adecuada, o limitar el tamaño de los elementos del menú cuando el tamaño físico de la pantalla sea mayor al de un móvil, para así evitar ocupar más espacio de pantalla que el necesario para poderlos pulsar fácilmente.</p>
<p><img alt="Menú principal para iPhone" src="imagenes/adaptacion/menu-iphone.png" /></p>
<p><img alt="Menú principal para iPad" src="imagenes/adaptacion/menu-ipad.PNG" /></p>
<h2 id="depuracion-del-cambio-de-densidad-de-pantalla">Depuración del cambio de densidad de pantalla<a class="headerlink" href="#depuracion-del-cambio-de-densidad-de-pantalla" title="Permanent link">&para;</a></h2>
<p>Para comprobar que nuestra aplicación se adapta de forma correcta podemos utilizar diferentes tamaños de ventana durante el desarrollo. Sin embargo, también será necesario comprobar lo que ocurre al tener diferentes densidades de pantalla, teniendo algunos dispositivos resoluciones superiores a la de nuestra máquina de desarrollo.</p>
<p>Para resolver este problema podemos utilizar la función <code>GLView::setFrameZoomFactor</code>. Con esta función podemos aplicar un factor de <em>zoom</em> al contenido de la ventana. De esta forma podemos tener altas resoluciones, como los 2048x1536 pixeles de un iPad retina, dentro del espacio de nuestra pantalla.</p>
<p>Esta función deberá invocarse únicamente en el código específico de la plataforma de desarrollo (Windows, Linux o Mac). Por ejemplo, en el caso de Mac añadiremos las siguientes líneas al fichero <code>AppDelegate.cpp</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">bool</span> <span class="n">AppDelegate</span><span class="o">::</span><span class="n">applicationDidFinishLaunching</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// initialize director</span>
    <span class="k">auto</span> <span class="n">director</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">glview</span> <span class="o">=</span> <span class="n">director</span><span class="o">-&gt;</span><span class="n">getOpenGLView</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">glview</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">glview</span> <span class="o">=</span> <span class="n">GLViewImpl</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;Mi Juego&quot;</span><span class="p">);</span>
        <span class="n">director</span><span class="o">-&gt;</span><span class="n">setOpenGLView</span><span class="p">(</span><span class="n">glview</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Depuracion multi-resolucion</span>
    <span class="n">GLView</span><span class="o">*</span> <span class="n">eglView</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getOpenGLView</span><span class="p">();</span>
    <span class="n">eglView</span><span class="o">-&gt;</span><span class="n">setFrameSize</span><span class="p">(</span><span class="mi">1536</span><span class="p">,</span> <span class="mi">2048</span><span class="p">);</span>
    <span class="n">eglView</span><span class="o">-&gt;</span><span class="n">setFrameZoomFactor</span><span class="p">(</span><span class="mf">0.4f</span><span class="p">);</span>

    <span class="c1">// Soporte multi-resolucion</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getOpenGLView</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setDesignResolutionSize</span><span class="p">(</span>
                                         <span class="mi">768</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">ResolutionPolicy</span><span class="o">::</span><span class="n">FIXED_WIDTH</span><span class="p">);</span>

    <span class="c1">// turn on display FPS</span>
    <span class="n">director</span><span class="o">-&gt;</span><span class="n">setDisplayStats</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

    <span class="c1">// set FPS. the default value is 1.0/60 if you don&#39;t call this</span>
    <span class="n">director</span><span class="o">-&gt;</span><span class="n">setAnimationInterval</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mi">60</span><span class="p">);</span>

    <span class="c1">// create a scene. it&#39;s an autorelease object</span>
    <span class="k">auto</span> <span class="n">scene</span> <span class="o">=</span> <span class="n">TitleScene</span><span class="o">::</span><span class="n">createScene</span><span class="p">();</span>

    <span class="c1">// run</span>
    <span class="n">director</span><span class="o">-&gt;</span><span class="n">runWithScene</span><span class="p">(</span><span class="n">scene</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h2 id="compilacion-condicional">Compilación condicional<a class="headerlink" href="#compilacion-condicional" title="Permanent link">&para;</a></h2>
<p>En muchos casos tendremos que poner código que sólo queremos que se incluya para una plataforma determinada. Podemos hacer que se determine en tiempo de compilación si se debe incluir dicho código o no. Para ello podemos incluir bloques condicionales que hagan que sólo se incluya el código al compilar si compilamos para la plataforma indicada.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#if (CC_TARGET_PLATFORM == &lt;plataforma&gt;)</span>
    <span class="p">...</span> <span class="c1">// Código condicional</span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></table>

<p>Por ejemplo, en el caso anterior en el que buscábamos emular diferentes resoluciones de móvil en la plataforma Mac para así depurar la adaptación al tamaño de pantalla, podemos hacer que este código para la depuración sólo se incluya para la plataforma Mac:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#if (CC_TARGET_PLATFORM == CC_PLATFORM_MAC)</span>
    <span class="c1">// Depuracion multi-resolucion</span>
    <span class="n">GLView</span><span class="o">*</span> <span class="n">eglView</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getOpenGLView</span><span class="p">();</span>
    <span class="n">eglView</span><span class="o">-&gt;</span><span class="n">setFrameSize</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span> <span class="mi">480</span><span class="p">);</span>
    <span class="n">eglView</span><span class="o">-&gt;</span><span class="n">setFrameZoomFactor</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></table>

<p>Podemos introducir código condicional para las diferentes plataformas soportadas:</p>
<ul>
<li><code>CC_PLATFORM_IOS</code></li>
<li><code>CC_PLATFORM_ANDROID</code></li>
<li><code>CC_PLATFORM_WP8</code></li>
<li><code>CC_PLATFORM_BLACKBERRY</code>  </li>
<li><code>CC_PLATFORM_WIN32</code>  </li>
<li><code>CC_PLATFORM_LINUX</code>  </li>
<li><code>CC_PLATFORM_MAC</code>  </li>
</ul>
<p>Esto nos permitirá por ejemplo incluir servicios que sólo estarán disponibles en una determinada plataforma, como es el caso de Game Center en iOS.</p>
<h2 id="optimizacion-de-texturas">Optimización de texturas<a class="headerlink" href="#optimizacion-de-texturas" title="Permanent link">&para;</a></h2>
<p>Aunque utilicemos un motor o librería de alto nivel para implementar nuestro videojuego, como puede ser Unity o Cocos2d-x, por debajo estas librerías siempre estarán utilizando OpenGL. Concretamente, en los dispositivos móviles utilizarán OpenGL ES, una versión reducida de OpenGL pensada para este tipo de dispositivos. Según las características del dispositivo se utilizará OpenGL ES 1.0 o OpenGL ES 2.0. Las primeras generaciones de iPhone soportaban únicamente OpenGL ES 1.0, mientras que actualmente se pueden utilizar ambas versiones de la librería. Actualmente podemos encontrar OpenGL ES 2.0 en prácticamente la totalidad de dispositivos Android e iOS disponibles. Por este motivo será importante tener algunas nociones sobre cómo gestiona los gráficos OpenGL.</p>
<p>Los gráficos a mostrar en pantalla se almacenan en memoria de vídeo como texturas. La memoria de vídeo es un recurso crítico (se suele compartir con la RAM del dispositivo), por lo que deberemos optimizar las texturas para ocupar la mínima cantidad de memoria posible. Para aprovechar al máximo la memoria, se recomienda que las texturas tengan de tamaño una potencia de 2 (por ejemplo 128x128, 256x256, 512x512, 1024x1024, o 2048x2048), ya que son las dimensiones con las que trabaja la memoria de vídeo. En OpenGL ES 1.0 el tamaño máximo de las texturas es de 1024x1024, mientras que en OpenGL ES 2.0 este tamaño se amplía hasta 2048x2048,</p>
<p>Existen diferentes formatos de textura:</p>
<ul>
<li><code>RGB8888</code>: 32 bits por pixel. Contiene un canal <em>alpha</em> de 8 bits, con el que podemos dar a cada pixel 256 posibles niveles de transparencia. Permite representar más de 16 millones de colores (8 bits para cada canal RGB).</li>
<li><code>RGB4444</code>: 16 bits por pixel. Contiene un canal <em>alpha</em> de 4 bits, con el que podemos dar a cada pixel 16 posibles niveles de transparencia. Permite representar 4.096 colores (4 bits para cada canal RGB). Esto permite representar colores planos, pero no será capaz de representar correctamente los degradados.</li>
<li><code>RGB565</code>: 16 bits por pixel. No permite transparencia. Permite representar 65.536 colores, con 6 bits para el canal verde (G), y 5 bits para los canales rojo (R) y azul (B). Este tipo de textura será la más adecuada para fondos.</li>
<li><code>RGB5551</code>: 16 bits por pixel. Permite transparencia de un sólo bit, es decir, que un pixel puede ser transparente u opaco, pero no permite niveles intermedios. Permite representar 32.768 colores (5 bits para cada canal RGB).</li>
</ul>
<p>Debemos evitar en la medida de lo posible utilizar el tipo <code>RGB8888</code>, debido no sólo al espacio
que ocupa en memoria y en disco (aumentará significativamente el tamaño del paquete), sino también a que el rendimiento del videojuego disminuirá al utilizar este tipo de texturas. Escogeremos un tipo u otro según nuestras necesidades. Por ejemplo, si nuestros gráficos utilizan colores planos, <code>RGB4444</code> puede ser una buena opción. Para fondos en los que no necesitemos transparencia la opción más adecuada sería <code>RGB565</code>. Si nuestros gráficos tienen un borde sólido y no necesitamos transparencia parcial, pero si total, podemos utilizar <code>RGB5551</code>.</p>
<p><img alt="RGB8888 vs RGB4444" src="imagenes/juegos/texturas_rgb.jpg" /></p>
<p>En caso de necesitar utilizar <code>RGB4444</code> con texturas en las que tenemos degradado, podemos
aplicar a la textura el efecto <em>dithering</em> para que el degradado se represente de una forma más adecuada utilizando un reducido número de colores. Esto se consigue mezclando píxeles de distintos colores y modificando la proporción de cada color conforme avanza el degradado, evitando así el efecto de degradado escalonado que obtendríamos al representar las texturas con un menor número de colores.</p>
<p><img alt="Mejora de texturas con dithering" src="imagenes/juegos/texturas_dithering.jpg" /></p>
<p>También tenemos la posibilidad de utilizar formatos de textura comprimidos para aprovechar al máximo el espacio y obtener un mayor rendimiento. En iPhone el formato de textura soportado es PVRTC. Existen variantes de 2 y 4 bits de este formato. Se trata de un formato de compresión con pérdidas.</p>
<p><img alt="Compresión de texturas con pérdidas" src="imagenes/juegos/texturas_pvrtc.jpg" /></p>
<p>En Android los dispositivos con OpenGL ES 1.0 no tenían ningún formato estándar de compresión. Según el dispositivo podíamos encontrar distintos formatos: ATITC, PVRTC, DXT. Sin embargo, todos los dispositivos con soporte para OpenGL ES 2.0 soportan el formato ETC1. Podemos convertir nuestras texturas a este formato con la herramienta <code>$ANDROID_SDK_HOME/tools/etc1tool</code>, incluida con el SDK de Android. Un inconveniente de este formato es que no soporta canal <em>alpha</em>.</p>
<p>Además de seleccionar el formato adecuado para la textura, deberemos aprovechar al máximo el espacio disponible dentro de ella (dentro de una textura podemos incluir imágenes de diferentes <em>sprites</em> y fotogramas de los mismos). Herramientas especializadas como Texture Packer nos permitirán al mismo tiempo empaquetar nuestros <em>sprites</em> de forma óptima en una textura, y especificar el formato de textura a utilizar. En motores como Unity encontramos herramientas integradas que nos permiten realizar esta tarea.</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="mandos.html" title="Controles del videojuego" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Anterior
                </span>
                Controles del videojuego
              </span>
            </div>
          </a>
        
        
          <a href="redes_sociales.html" title="Logros y marcadores" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Siguiente
                </span>
                Logros y marcadores
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="assets/javascripts/application.245445c6.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>