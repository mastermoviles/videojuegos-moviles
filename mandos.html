



<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copiar al portapapeles">
      
        <meta name="lang:clipboard.copied" content="Copiado al portapapeles">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No se encontraron documentos">
      
        <meta name="lang:search.result.one" content="1 documento encontrado">
      
        <meta name="lang:search.result.other" content="# documentos encontrados">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.4.0">
    
    
      
        <title>Controles del videojuego - Videojuegos para Dispositivos Móviles</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/application.0284f74d.css">
      
        <link rel="stylesheet" href="assets/stylesheets/application-palette.01803549.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
      <script src="assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#controles-del-videojuego" tabindex="1" class="md-skip">
        Saltar a contenido
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="index.html" title="Videojuegos para Dispositivos Móviles" class="md-header-nav__button md-logo">
          
            <img src="imagenes/logo.png" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              Videojuegos para Dispositivos Móviles
            </span>
            <span class="md-header-nav__topic">
              
                Controles del videojuego
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Teclee para comenzar búsqueda
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="index.html" title="Videojuegos para Dispositivos Móviles" class="md-nav__button md-logo">
      
        <img src="imagenes/logo.png" width="48" height="48">
      
    </a>
    Videojuegos para Dispositivos Móviles
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="index.html" title="Presentación" class="md-nav__link">
      Presentación
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="videojuegos_para_moviles.html" title="Introducción a los videojuegos móviles" class="md-nav__link">
      Introducción a los videojuegos móviles
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Fundamentos de los motores
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Fundamentos de los motores
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="fundamentos-motores.html" title="Escena y nodos" class="md-nav__link">
      Escena y nodos
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="motor_de_fisicas.html" title="Físicas" class="md-nav__link">
      Físicas
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="sprites_e_interaccion.html" title="Sprites" class="md-nav__link">
      Sprites
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="escenario_y_fondos.html" title="Fondo y scroll" class="md-nav__link">
      Fondo y scroll
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Motores para  móviles
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Motores para  móviles
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="spritekit.html" title="SpriteKit" class="md-nav__link">
      SpriteKit
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="scenekit.html" title="SceneKit" class="md-nav__link">
      SceneKit
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="cocos2d-x.html" title="Cocos2d-x" class="md-nav__link">
      Cocos2d-x
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="unity.html" title="Unity" class="md-nav__link">
      Unity
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="box2d.html" title="Box2D" class="md-nav__link">
      Box2D
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Controles del videojuego
      </label>
    
    <a href="mandos.html" title="Controles del videojuego" class="md-nav__link md-nav__link--active">
      Controles del videojuego
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#teclado-en-cocos2d-x" title="Teclado en Cocos2d-x" class="md-nav__link">
    Teclado en Cocos2d-x
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pantalla-tactil" title="Pantalla táctil" class="md-nav__link">
    Pantalla táctil
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pantalla-tactil-en-cocos2d-x" title="Pantalla táctil en Cocos2d-x" class="md-nav__link">
    Pantalla táctil en Cocos2d-x
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eventos-de-la-pantalla-tactil-en-cocos2d-x" title="Eventos de la pantalla táctil en Cocos2d-x" class="md-nav__link">
    Eventos de la pantalla táctil en Cocos2d-x
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prioridad-de-los-eventos" title="Prioridad de los eventos" class="md-nav__link">
    Prioridad de los eventos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#consumo-de-eventos" title="Consumo de eventos" class="md-nav__link">
    Consumo de eventos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodo-objetivo-del-listener" title="Nodo objetivo del listener" class="md-nav__link">
    Nodo objetivo del listener
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pantalla-multitactil" title="Pantalla multitáctil" class="md-nav__link">
    Pantalla multitáctil
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#acelerometro" title="Acelerómetro" class="md-nav__link">
    Acelerómetro
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mandos" title="Mandos" class="md-nav__link">
    Mandos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#buenas-practicas-para-juegos-basados-en-control-pad" title="Buenas prácticas para juegos basados en control pad" class="md-nav__link">
    Buenas prácticas para juegos basados en control pad
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mandos-virtuales" title="Mandos virtuales" class="md-nav__link">
    Mandos virtuales
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#controles-virtuales" title="Controles virtuales" class="md-nav__link">
    Controles virtuales
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pad-virtual" title="Pad virtual" class="md-nav__link">
    Pad virtual
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stick-virtual" title="Stick virtual" class="md-nav__link">
    Stick virtual
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stick-virtual-con-posicionamiento-automatico" title="Stick virtual con posicionamiento automático" class="md-nav__link">
    Stick virtual con posicionamiento automático
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mandos-fisicos" title="Mandos físicos" class="md-nav__link">
    Mandos físicos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tipos-de-mandos-fisicos" title="Tipos de mandos físicos" class="md-nav__link">
    Tipos de mandos físicos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#controladores-fisicos-en-cocos2d-x" title="Controladores físicos en Cocos2d-x" class="md-nav__link">
    Controladores físicos en Cocos2d-x
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#controles-fisicos-en-ios-nativo" title="Controles físicos en iOS nativo" class="md-nav__link">
    Controles físicos en iOS nativo
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="adaptacion_a_moviles.html" title="Adaptación a diferentes dispositivos" class="md-nav__link">
      Adaptación a diferentes dispositivos
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="redes_sociales.html" title="Logros y marcadores" class="md-nav__link">
      Logros y marcadores
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#teclado-en-cocos2d-x" title="Teclado en Cocos2d-x" class="md-nav__link">
    Teclado en Cocos2d-x
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pantalla-tactil" title="Pantalla táctil" class="md-nav__link">
    Pantalla táctil
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pantalla-tactil-en-cocos2d-x" title="Pantalla táctil en Cocos2d-x" class="md-nav__link">
    Pantalla táctil en Cocos2d-x
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eventos-de-la-pantalla-tactil-en-cocos2d-x" title="Eventos de la pantalla táctil en Cocos2d-x" class="md-nav__link">
    Eventos de la pantalla táctil en Cocos2d-x
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prioridad-de-los-eventos" title="Prioridad de los eventos" class="md-nav__link">
    Prioridad de los eventos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#consumo-de-eventos" title="Consumo de eventos" class="md-nav__link">
    Consumo de eventos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodo-objetivo-del-listener" title="Nodo objetivo del listener" class="md-nav__link">
    Nodo objetivo del listener
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pantalla-multitactil" title="Pantalla multitáctil" class="md-nav__link">
    Pantalla multitáctil
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#acelerometro" title="Acelerómetro" class="md-nav__link">
    Acelerómetro
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mandos" title="Mandos" class="md-nav__link">
    Mandos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#buenas-practicas-para-juegos-basados-en-control-pad" title="Buenas prácticas para juegos basados en control pad" class="md-nav__link">
    Buenas prácticas para juegos basados en control pad
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mandos-virtuales" title="Mandos virtuales" class="md-nav__link">
    Mandos virtuales
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#controles-virtuales" title="Controles virtuales" class="md-nav__link">
    Controles virtuales
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pad-virtual" title="Pad virtual" class="md-nav__link">
    Pad virtual
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stick-virtual" title="Stick virtual" class="md-nav__link">
    Stick virtual
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stick-virtual-con-posicionamiento-automatico" title="Stick virtual con posicionamiento automático" class="md-nav__link">
    Stick virtual con posicionamiento automático
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mandos-fisicos" title="Mandos físicos" class="md-nav__link">
    Mandos físicos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tipos-de-mandos-fisicos" title="Tipos de mandos físicos" class="md-nav__link">
    Tipos de mandos físicos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#controladores-fisicos-en-cocos2d-x" title="Controladores físicos en Cocos2d-x" class="md-nav__link">
    Controladores físicos en Cocos2d-x
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#controles-fisicos-en-ios-nativo" title="Controles físicos en iOS nativo" class="md-nav__link">
    Controles físicos en iOS nativo
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="controles-del-videojuego">Controles del videojuego<a class="headerlink" href="#controles-del-videojuego" title="Permanent link">&para;</a></h1>
<p>La principal forma de control del móvil es la pantalla táctil, por lo que los videojuegos diseñados específicamente para móviles normalmente se adaptan a esta forma de entrada. Encontramos también algunos juegos diseñados para ser manejados mediante el acelerómetro. Sin embargo, cuando se quiere trasladar a móvil un juego diseñado originalmente para otro sistema en el que contamos con teclado, ratón o <em>joystick</em> deberemos adaptar su forma de manejo, ya que en la mayoría de casos no contamos con dichos mecanismos de entrada en móviles. </p>
<p>Vamos a ver los diferentes mecanismos de entrada que podemos utilizar en los videojuegos para móviles, y una serie de buenas prácticas a la hora de implementar el control de estos videojuegos.</p>
<h2 id="teclado-en-cocos2d-x">Teclado en Cocos2d-x<a class="headerlink" href="#teclado-en-cocos2d-x" title="Permanent link">&para;</a></h2>
<p>Cocos2d-x soporta eventos de teclado, pero éstos no funcionan en plataformas móviles. Aunque nuestro proyecto esté orientado exclusivamente a estas plataformas, si el control de nuestro juego se realiza mediante mando es recomendable que implementemos también la posibilidad de controlarlo mediante teclado. Esto será de gran utilidad durante el desarrollo, ya que no existe forma de emular un mando, y la forma más parecida al mando para manejar nuestro juego en las pruebas que hagamos durante el desarrollo es el control mediante teclado. </p>
<p>Para leer los eventos de teclado desde Cocos2d-x podemos utilizar la clase <code>EventListenerKeyboard</code> como se muestra a continuación: </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">bool</span> <span class="n">MiEscena</span><span class="o">::</span><span class="n">init</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">Layer</span><span class="o">::</span><span class="n">init</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>       

    <span class="n">configuraTeclado</span><span class="p">();</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">MiEscena</span><span class="o">::</span><span class="n">configurarTeclado</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">_listener</span> <span class="o">=</span> <span class="n">EventListenerKeyboard</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>

    <span class="c1">// Registramos callbacks</span>
    <span class="n">_listener</span><span class="o">-&gt;</span><span class="n">onKeyPressed</span> <span class="o">=</span> <span class="n">CC_CALLBACK_2</span><span class="p">(</span><span class="n">MiEscena</span><span class="o">::</span><span class="n">onConnectController</span><span class="p">,</span><span class="k">this</span><span class="p">);</span>
    <span class="n">_listener</span><span class="o">-&gt;</span><span class="n">onReleased</span> <span class="o">=</span> <span class="n">CC_CALLBACK_2</span><span class="p">(</span><span class="n">MiEscena</span><span class="o">::</span><span class="n">onDisconnectedController</span><span class="p">,</span><span class="k">this</span><span class="p">);</span>

    <span class="c1">// Añadimos el listener el mando al gestor de eventos</span>
    <span class="n">_eventDispatcher</span><span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span><span class="n">_listener</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">MiEscena</span><span class="o">::</span><span class="n">onKeyDown</span><span class="p">(</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span> <span class="n">code</span><span class="p">,</span> <span class="n">Event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>   

<span class="kt">void</span> <span class="n">MiEscena</span><span class="o">::</span><span class="n">onKeyUp</span><span class="p">(</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span> <span class="n">code</span><span class="p">,</span> <span class="n">Event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Por ejemplo, para reconocer los controles izquierda-derecha mediante las teclas A-D podríamos escribir los métodos <code>onKeyDown</code> y <code>onKeyUp</code> como se muestra a continuación:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">MiEscena</span><span class="o">::</span><span class="n">onKeyDown</span><span class="p">(</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span> <span class="n">code</span><span class="p">,</span> <span class="n">Event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">switch</span><span class="p">(</span><span class="n">keyCode</span><span class="p">){</span>
        <span class="k">case</span> <span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span><span class="o">::</span><span class="nl">KEY_A</span><span class="p">:</span>
            <span class="n">_izquierdaPulsado</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span><span class="o">::</span><span class="nl">KEY_D</span><span class="p">:</span>
            <span class="n">_derechaPulsado</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>  

<span class="kt">void</span> <span class="n">MiEscena</span><span class="o">::</span><span class="n">onKeyUp</span><span class="p">(</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span> <span class="n">code</span><span class="p">,</span> <span class="n">Event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">switch</span><span class="p">(</span><span class="n">keyCode</span><span class="p">){</span>
        <span class="k">case</span> <span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span><span class="o">::</span><span class="nl">KEY_A</span><span class="p">:</span>
            <span class="n">_izquierdaPulsado</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span><span class="o">::</span><span class="nl">KEY_D</span><span class="p">:</span>
            <span class="n">_derechaPulsado</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>  
</pre></div>
</td></tr></table>

<h2 id="pantalla-tactil">Pantalla táctil<a class="headerlink" href="#pantalla-tactil" title="Permanent link">&para;</a></h2>
<p>Como hemos comentado, es el mecanismo más habitual de entrada en los videojuegos para móviles. En muchos tipos de videojuegos esta es la forma de control más natural. Por ejemplo, tenemos <em>puzzles</em> en los que tenemos que interactuar con diferentes elementos del escenario tocando sobre ellos. También en el género <em>tower defense</em> resulta natural posicionar nuestras diferentes unidades tocando sobre la pantalla, o de forma más amplia en el género de la estrategia interactuar con nuestros recursos y unidades pulsando sobre ellos.</p>
<p>La pantalla táctil tiene ciertas similitudes con el control mediante ratón, pudiendo trasladar muchos juegos que originalmente se controlaban mediante ratón a dispositivos táctiles. Sin embargo, debemos tener en cuenta algunas diferencias importantes. Los juegos en los que el ratón se utiliza para el control de la cámara y para apuntar deslizándolo (como es el caso fundamentalmente de los <em>First Person Shooters</em>), encontraremos una pérdida al pasarlos a la pantalla táctil, y no será trivial implementarlo de forma correcta. Sin embargo, aquellos en los que se utilice para seleccionar elementos mediante el puntero ganarán con la pantalla táctil, ya que será más rápido pulsar sobre estos elementos con el dedo que tener que deslizar el puntero del ratón. Además, tenemos que tener en cuenta una ventaja muy importante de la pantalla táctil sobre el ratón: es multitáctil. Esto quiere decir que podemos tener al mismo tiempo varios contactos en pantalla, cosa que con el ratón no es posible. Esto nos da un gran abanico de posibilidades a la hora de implementar el control en nuestros videojuegos.</p>
<h3 id="pantalla-tactil-en-cocos2d-x">Pantalla táctil en Cocos2d-x<a class="headerlink" href="#pantalla-tactil-en-cocos2d-x" title="Permanent link">&para;</a></h3>
<p>Vamos a ver la forma de implementar este mecanismo de control en Cocos2d-x. Para la detección de eventos de la pantalla táctil crearemos un <em>listener</em> de tipo <code>EventListenerTouch</code>:</p>
<p>Encontramos dos variantes:</p>
<ul>
<li><code>EventListenerTouchOneByOne</code>: Procesa los eventos de la pantalla táctil de uno en uno. Cada vez que se reciba un evento será sobre un único contacto (<code>Touch</code>). Es más sencillo de implementar, y resultará adecuado para aquellos juegos en los que no necesitemos detectar más de un contacto al mismo tiempo.</li>
<li><code>EventListenerTouchAllAtOnce</code>: En este caso podremos recibir en cada evento información de varios contactos (recibiremos una lista de objetos <code>Touch</code>). Será más complicado de gestionar, pero nos permitirá implementar juegos que hagan uso de la pantalla multitáctil. </li>
</ul>
<p>Una vez seleccionado el <em>listener</em> que más nos interese para nuestro videojuego, lo inicializaremos de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">auto</span> <span class="n">listener</span> <span class="o">=</span> <span class="n">EventListenerTouchOneByOne</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
</pre></div>
</td></tr></table>

<h3 id="eventos-de-la-pantalla-tactil-en-cocos2d-x">Eventos de la pantalla táctil en Cocos2d-x<a class="headerlink" href="#eventos-de-la-pantalla-tactil-en-cocos2d-x" title="Permanent link">&para;</a></h3>
<p>Hablaremos de un <strong>gesto</strong> táctil para referirnos a la secuencia que consiste en tocar sobre la pantalla, deslizar el dedo, y levantarlo de la pantalla. Durante el gesto se producirán tres tipos de eventos:</p>
<ul>
<li><code>onTouchBegan</code>: Evento de comienzo de un gesto. En este evento podemos decidir si queremos procesar el resto del gesto o no. En caso de no estar interesados en este gesto ya no recibiremos ningún evento más del mismo (ni de movimiento ni de finalización).</li>
<li><code>onTouchMoved</code>: Evento de continuación del gesto. Mientras desplacemos el contacto por la pantalla recibiremos eventos de movimiento con sus nuevas coordenadas.</li>
<li><code>onTouchEnded</code>: Evento de finalización del gesto. Al levantar el dedo de la pantalla el gesto finalizará. </li>
</ul>
<p>Podemos indicar <em>callbacks</em> para estos eventos mediante funciones <em>lambda</em>, o utilizandos la macro <code>CC_CALLBACK_2</code>. </p>
<p>Comenzamos con el evento de comienzo del gesto. La función <em>callback</em> deberá devolver un <em>booleano</em> indicando si estamos interesados en el gesto o no. Por ejemplo, podemos considerar que nos interesa el gesto si hemos pulsado sobre un determinado <em>sprite</em>, y que no nos interesa en caso contrario.<br />
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchBegan</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">estaSobreSprite</span><span class="p">(</span><span class="n">touch</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> 
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> 
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></p>
<p>De forma similar definiremos los eventos de movimiento y finalización, aunque en estos casos no deberemos devolver ningún valor:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchMoved</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">){</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchEnded</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">){</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<h3 id="prioridad-de-los-eventos">Prioridad de los eventos<a class="headerlink" href="#prioridad-de-los-eventos" title="Permanent link">&para;</a></h3>
<p>Una vez definidos los eventos, añadimos el <em>listener</em> a la escena:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">m_node</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span><span class="n">listener</span><span class="p">,</span> <span class="n">m_sprite</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>En este caso <code>m_node</code> sería el nodo principal que contiene nuestra escena, y <code>m_sprite</code> el nodo que queremos que actúe como objetivo (<em>target</em>) de nuestro <em>listener</em>. </p>
<p>Podemos añadir el <em>listener</em>  con dos sistemas de prioridad distintos:</p>
<ul>
<li><strong>Prioridad de grafo de la escena</strong>: La prioridad en la que se ejecutan los diferentes <em>listeners</em> viene determinada por el orden de los nodos en el grafo de la escena. El nodo que pasamos como <em>target</em> al añadir el <em>listener</em> será el que determine dicha prioridad. Se ejecutarán antes los eventos definidos sobre nodos que queden delante de otros en la pantalla (es decir, primero aquellos que tengan mayor Z). </li>
<li><strong>Prioridad fija</strong>: En este caso la prioridad se especifica mediante un valor fijo al añadir el <em>listener</em>.</li>
</ul>
<h3 id="consumo-de-eventos">Consumo de eventos<a class="headerlink" href="#consumo-de-eventos" title="Permanent link">&para;</a></h3>
<p>Al crear un <em>listener</em> podemos indicar que consuma los eventos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">listener</span><span class="o">-&gt;</span><span class="n">setSwallowTouches</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Si hacemos esto, en caso de que nuestro <em>listener</em> devuelva <code>true</code> en <code>onTouchBegan</code> consumirá el evento y éste no pasará a otros <em>listeners</em> de menor prioridad. En caso contrario, el evento se propagará al siguiente <em>listener</em></p>
<h3 id="nodo-objetivo-del-listener">Nodo objetivo del <em>listener</em><a class="headerlink" href="#nodo-objetivo-del-listener" title="Permanent link">&para;</a></h3>
<p>Hemos visto que al utilizar prioridad basada en el grafo de la escena cada <em>listener</em> tiene un nodo objetivo. Podemos aprovechar esto para utilizar dicho nodo como nodo sobre el que estamos interesados en pulsar:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchBegan</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
    <span class="n">Point</span> <span class="n">locationInNode</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">convertToNodeSpace</span><span class="p">(</span><span class="n">touch</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">());</span>

    <span class="n">Size</span> <span class="n">s</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">();</span>
    <span class="n">Rect</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">rect</span><span class="p">.</span><span class="n">containsPoint</span><span class="p">(</span><span class="n">locationInNode</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>Con <code>Event::getCurrentTarget</code> podemos obtener el nodo que actúa de <em>target</em>. Podemos convertir las coordenadas globales del <em>touch</em> a coordenadas locales del nodo <em>target</em>, y en caso de estar dentro del área que ocupa dicho nodo entonces devolvemos <code>true</code> para seguir procesando eventos de este gesto. De esta forma podemos hacer por ejemplo que al pulsar sobre nuestro <em>sprite</em> podamos arrastrarlo por la pantalla, mientras que si pulsamos fuera este <em>listener</em> no hará nada. </p>
<h3 id="pantalla-multitactil">Pantalla multitáctil<a class="headerlink" href="#pantalla-multitactil" title="Permanent link">&para;</a></h3>
<p>Cocos2d-x soporta pantalla multitáctil, pero por defecto se encuentra deshabilitada en iOS. Para habilitar el soporte para recibir varios contactos simultáneos en esta plataforma, deberemos abrir el fichero <code>AppController.mm</code> y localizar la siguiente línea:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">[</span><span class="n">eaglView</span> <span class="nl">setMultipleTouchEnabled</span><span class="p">:</span><span class="nb">NO</span><span class="p">];</span>
</pre></div>
</td></tr></table>

<p>La modificaremos de forma que si que esté habilitado el soporte para múltiples contactos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">[</span><span class="n">eaglView</span> <span class="nl">setMultipleTouchEnabled</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</pre></div>
</td></tr></table>

<p>En Android no será necesario que hagamos nada, el soporte para pantalla multitáctil está habilitado por defecto.</p>
<h2 id="acelerometro">Acelerómetro<a class="headerlink" href="#acelerometro" title="Permanent link">&para;</a></h2>
<p>Encontramos también algunos juegos en los que el mecanismo de control más natural es el uso del acelerómetro. Por ejemplo juegos que cambian la gravedad en la escena según la inclinación del móvil, como es el caso de los juegos en los que manejamos una bola a través de un laberinto, o juegos de conducción en los que la inclinación del móvil hace de volante. </p>
<p>En Cocos2d-x implementaremos soporte para el acelerómetro mediante un <em>listener</em> de tipo <code>EventListenerAcceleration</code>. Para que este <em>listener</em> funcione, en primer lugar deberemos activar el uso del acelerómetro:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Device</span><span class="o">::</span><span class="n">setAccelerometerEnabled</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Una vez hecho esto, creamos el <em>listener</em> especificando directamente un <em>callback</em> mediante una función <em>lambda</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">auto</span> <span class="n">listener</span> <span class="o">=</span> <span class="n">EventListenerAcceleration</span><span class="o">::</span><span class="n">create</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="n">Acceleration</span><span class="o">*</span> <span class="n">acc</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
   <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>También podemos utilizar la macro <code>CC_CALLBACK_2</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">auto</span> <span class="n">listener</span> <span class="o">=</span> <span class="n">EventListenerAcceleration</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">CC_CALLBACK_2</span><span class="p">(</span><span class="n">Game</span><span class="o">::</span><span class="n">onAcceleration</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">onAcceleration</span><span class="p">(</span><span class="n">Acceleration</span><span class="o">*</span> <span class="n">acc</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Por último, añadiremos el <em>listener</em> al gestor de eventos de la escena:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">m_node</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span><span class="n">listener</span><span class="p">,</span> <span class="n">m_node</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Es importante tener en cuenta que en los juegos que se manejen mediante acelerómetro, al no ser necesario tocar la pantalla, no debemos permitir que esta se apague de forma automática por inactividad. Esto no se puede hacer directamente con Cocos2d-x, sino que tendremos que especificarlo de forma nativa para cada plataforma.</p>
<h2 id="mandos">Mandos<a class="headerlink" href="#mandos" title="Permanent link">&para;</a></h2>
<p>Los juegos diseñados para videoconsolas o máquinas recreativas se manejan normalmente mediante <em>joystick</em> o <em>pad</em>. Al portar uno de estos juegos a móvil podemos optar por:</p>
<ul>
<li>Adaptar el control de videojuego a pantalla táctil. Esto implica grandes cambios en el diseño del juego y en el <em>gameplay</em> y no siempre es posible hacerlo.</li>
<li>Añadir un <em>pad</em> virtual en pantalla. Permite mantener el mismo mecanismo de control que el juego original, pero resulta más complicado de manejar que con un mando real.</li>
<li>Añadir soporte para mandos físicos. Nos permitirá trasladar la misma experiencia de juego que la versión de videoconsola/recreativa pero necesita que el usuario cuente con este dispositivo. Se pierde una de las ventajas de los juegos móviles, que es el llevarlos siempre con nosotros.  </li>
</ul>
<p>Vamos ahora a centrarnos en este tipo de juegos y en la forma de diseñar un control adecuado para ellos. Veremos tanto la forma de incorporar un <em>pad</em> virtual como la forma de añadir soporte para diferentes tipos de mandos físicos. Dentro de estos mandos encontramos tanto mandos soportados por las APIs oficiales de iOS y Android, como mandos con APIs de terceros, como por ejemplo iCade.</p>
<h3 id="buenas-practicas-para-juegos-basados-en-control-pad">Buenas prácticas para juegos basados en <em>control pad</em><a class="headerlink" href="#buenas-practicas-para-juegos-basados-en-control-pad" title="Permanent link">&para;</a></h3>
<p>Si queremos implementar un juego cuyo manejo esté basado en <em>control pad</em>, será recomendable seguir las siguientes prácticas:</p>
<ul>
<li>Permitir el manejo del juego mediante <em>pad</em> virtual en pantalla si no se dispone de mando real.</li>
<li>Añadir compatibilidad con mandos reales. Se recomienda añadir soporte para las APIs oficiales y para aquellos mandos más utilizados, como iCade.</li>
<li>En caso de tener conectado un mando real, ocultar el <em>pad</em> virtual para que no moleste en pantalla.</li>
<li>Respetaremos la función estándar de cada botón. El botón de <em>pausa</em> del mando debe permitir pausar el juego en cualquier momento. Determinados botones se suelen utilizar para realizar las mismas acciones en todos los juegos (saltos, ataque, acción, etc). Deberemos intentar seguir estas convenciones.</li>
<li>La pantalla del móvil no debe apagarse mientras utilizamos el juego con el mando externo.</li>
</ul>
<h2 id="mandos-virtuales">Mandos virtuales<a class="headerlink" href="#mandos-virtuales" title="Permanent link">&para;</a></h2>
<p>Cuando la mecanica de nuestro juego exige que se controles mediante un mando tradicional, y no contamos con ningún mando <em>hardware</em> que podamos utilizar, la única solución será introducir en nuestro juego un mando virtual en pantalla. </p>
<p>Vamos a ver diferentes tipos de mandos que podemos implementar en pantalla, emulando controles tanto digitales como analógicos.</p>
<h3 id="controles-virtuales">Controles virtuales<a class="headerlink" href="#controles-virtuales" title="Permanent link">&para;</a></h3>
<p>Antes de implementar un mecanismo de control concreto, es conveniente generar una estructura de clases que haga de fachada y nos permita implementar el control del videojuego de forma genérica, sin hacer referencia expresa al teclado, mandos físicos, o mandos virtuales. </p>
<p>En esta sección proponemos un sistema de control virtual basado en herencia. Implementaremos una clase <code>VirtualControls</code> que nos dará la información necesaria para leer los controles que necesite nuestro videojuego. Por ejemplo, si necesitamos un <em>joystick</em> analógico con dos ejes (horizontal y vertical) y tres botones digitales, nuestra clase nos dará información sobre estos controles virtuales, sin determinar qué mecanismo concreto se utiliza para implementarlos. Esto será responsabilidad de las subclases de <code>VirtualControls</code>, que serán las que implementen el mapeo entre un mecanismo de control concreto y los controles virtuales definidos en <code>VirtualControls</code>. De esta forma, simplemente cambiando la subclase de <code>VirtualControls</code> que instanciamos podremos cambiar la forma de controlar el videojuego.</p>
<p>Vamos a ver un ejemplo de implementación de sistema genérico de control. En primer lugar definiremos los botones y ejes virtuales que necesitamos reconocer en el videojuego:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#define kNUM_BUTTONS  3</span>
<span class="cp">#define kNUM_AXIS    2</span>

<span class="k">enum</span> <span class="n">Button</span> <span class="p">{</span>
    <span class="n">BUTTON_ACTION</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">BUTTON_LEFT</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">BUTTON_RIGHT</span><span class="o">=</span><span class="mi">2</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">Axis</span> <span class="p">{</span>
    <span class="n">AXIS_HORIZONTAL</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">AXIS_VERTICAL</span><span class="o">=</span><span class="mi">1</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>En este caso hemos definido tres botones (acción, izquierda y derecha), y dos ejes (horizontal y vertical), aunque podríamos adaptar esto a las necesidades de cada juego. Indicamos mediante constantes el número de botones y ejes, e identificamos cada uno mediante elementos mediante enumeraciones.</p>
<p>Los <strong>botones</strong> tendrán como estado un <em>booleano</em> (pulsado o no pulsado), mientras que los <strong>ejes</strong> tendrán como valor un valor de tipo <em>float</em> entre -1 y 1 (palanca totalmente inclinada en un sentido o en el contrario), y valdrá 0 si está en reposo. </p>
<p>Mostramos a continuación la estructura completa que podría tener la clase que implemente el <em>control virtual</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">VirtualControls</span><span class="o">:</span> <span class="k">public</span> <span class="n">Ref</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="kt">bool</span> <span class="n">init</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">preloadResources</span><span class="p">(){};</span>
    <span class="k">virtual</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">getNode</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="nb">NULL</span><span class="p">;};</span>

    <span class="kt">bool</span> <span class="nf">isButtonPressed</span><span class="p">(</span><span class="n">Button</span> <span class="n">button</span><span class="p">);</span>
    <span class="kt">float</span> <span class="nf">getAxis</span><span class="p">(</span><span class="n">Axis</span> <span class="n">axis</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Button</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">onButtonPressed</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Button</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">onButtonReleased</span><span class="p">;</span>

    <span class="c1">// Keyboard controls</span>
    <span class="kt">void</span> <span class="nf">onKeyPressed</span><span class="p">(</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span> <span class="n">keyCode</span><span class="p">,</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">Event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">onKeyReleased</span><span class="p">(</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span> <span class="n">keyCode</span><span class="p">,</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">Event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">addKeyboardListeners</span><span class="p">(</span><span class="n">cocos2d</span><span class="o">::</span><span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

    <span class="n">CREATE_FUNC</span><span class="p">(</span><span class="n">VirtualControls</span><span class="p">);</span>

<span class="k">protected</span><span class="o">:</span>

    <span class="kt">bool</span> <span class="n">buttonState</span><span class="p">[</span><span class="n">kNUM_BUTTONS</span><span class="p">];</span>
    <span class="kt">float</span> <span class="n">axisState</span><span class="p">[</span><span class="n">kNUM_AXIS</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>Como vemos, la clase controla el estado de los botones (pulsados o sin pulsar) y el de los ejes, que oscilará entre <code>-1</code> (totalmente a la izquierda) y <code>1</code> (totalmente a la derecha). Deberemos poder leer el estado de estos controles virtuales en cualquier momento. Para ello hemos incorporado las propiedades <code>buttonState</code> y <code>axisState</code>, en las que almacenamos este estado, y proporcionamos los métodos <code>isButtonPressed</code> y <code>getAxis</code> para consultarlos.</p>
<p>Definimos también los eventos <code>onButtonPressed</code> y <code>onButtonReleased</code> para los cuales podremos definir <em>callbacks</em>. De esta forma podremos tener constancia de que un botón ha sido pulsado o soltado, sin tener que comprobar continuamente su estado.</p>
<p>Además, incluimos la posibilidad de devolver un nodo (método <code>getNode</code>) que nos permita pintar controles virtuales en pantalla (de momento estará vacío), y también un método para cargar los recursos necesarios para pintar estos controles (<code>preloadResources</code>). Estos métodos se definirán en las subclases de <code>VirtualControls</code>.</p>
<p>Vamos a ver a continuación cómo implementar cada método de esta clase. En primer lugar, el método para su inicialización (<code>init</code>) simplemente establecerá el estado de los botones a "no pulsado" (<code>false</code>) y los ejes en reposo (<code>0</code>):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">bool</span> <span class="n">VirtualControls</span><span class="o">::</span><span class="n">init</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">kNUM_BUTTONS</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buttonState</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">kNUM_AXIS</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">axisState</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>También será necesario definir los métodos para poder leer el estado de los controles (botones y ejes):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">bool</span> <span class="n">VirtualControls</span><span class="o">::</span><span class="n">isButtonPressed</span><span class="p">(</span><span class="n">Button</span> <span class="n">button</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">buttonState</span><span class="p">[</span><span class="n">button</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="n">VirtualControls</span><span class="o">::</span><span class="n">getAxis</span><span class="p">(</span><span class="n">Axis</span> <span class="n">axis</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">clampf</span><span class="p">(</span><span class="n">axisState</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>De momento sólo hemos definido en esta clase los controles que se utilizarán en el juego y lo métodos para consultarlos, pero de momento no se ha establecido la forma de darles valor a estos controles. Esto es algo que deberá implementar cada subclase concreta. Sin embargo, para depuración puede ser conveniente poder activar al control por teclado.</p>
<p>Vamos a hacer que la clase base implemente controles de teclado para depuración. En primer lugar actualizamos la definición de la clase <code>VirtualControls</code>. Añadimos a ella los <em>callbacks</em> necesarios para recibir los controles de teclado, y un método para activar el control por teclado en nuestro juego (<code>addKeyboardListeners</code>):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">VirtualControls</span><span class="o">:</span> <span class="k">public</span> <span class="n">Ref</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="p">...</span>    

    <span class="c1">// Keyboard controls</span>
    <span class="kt">void</span> <span class="n">onKeyPressed</span><span class="p">(</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span> <span class="n">keyCode</span><span class="p">,</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">Event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">onKeyReleased</span><span class="p">(</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span> <span class="n">keyCode</span><span class="p">,</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">Event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">addKeyboardListeners</span><span class="p">(</span><span class="n">cocos2d</span><span class="o">::</span><span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>A continuación, en la implementación de la clase introducimos el código de los <em>callbacks</em> de los eventos de teclado: las teclas <em>Cursor Izquierda</em> y <em>Cursor Derecha</em> modificarán el valor del eje horizontal (al mismo tiempo que el estado de los botones <code>BUTTON_LEFT</code> y <code>BUTTON_RIGHT</code>), y la tecla espacio modificará el estado del botón <code>BUTTON_ACTION</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">VirtualControls</span><span class="o">::</span><span class="n">onKeyPressed</span><span class="p">(</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span> <span class="n">keyCode</span><span class="p">,</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">Event</span> <span class="o">*</span><span class="n">event</span><span class="p">){</span>

    <span class="k">if</span><span class="p">(</span><span class="n">onButtonPressed</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">keyCode</span> <span class="o">==</span> <span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span><span class="o">::</span><span class="n">KEY_LEFT_ARROW</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">onButtonPressed</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_LEFT</span><span class="p">);</span>
            <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_HORIZONTAL</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">1.0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">keyCode</span> <span class="o">==</span> <span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span><span class="o">::</span><span class="n">KEY_RIGHT_ARROW</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">onButtonPressed</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_RIGHT</span><span class="p">);</span>
            <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_HORIZONTAL</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">keyCode</span><span class="o">==</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span><span class="o">::</span><span class="n">KEY_SPACE</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">onButtonPressed</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_ACTION</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="n">VirtualControls</span><span class="o">::</span><span class="n">onKeyReleased</span><span class="p">(</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span> <span class="n">keyCode</span><span class="p">,</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">Event</span> <span class="o">*</span><span class="n">event</span><span class="p">){</span>

    <span class="k">if</span><span class="p">(</span><span class="n">onButtonReleased</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">keyCode</span> <span class="o">==</span> <span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span><span class="o">::</span><span class="n">KEY_LEFT_ARROW</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">onButtonReleased</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_LEFT</span><span class="p">);</span>
            <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_HORIZONTAL</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">keyCode</span> <span class="o">==</span> <span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span><span class="o">::</span><span class="n">KEY_RIGHT_ARROW</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">onButtonReleased</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_RIGHT</span><span class="p">);</span>
            <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_HORIZONTAL</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">1.0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">keyCode</span><span class="o">==</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span><span class="o">::</span><span class="n">KEY_SPACE</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">onButtonReleased</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_ACTION</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>De esta forma mapeamos la lectura del teclado sobre nuestro sistema de control virtual. Debemos añadir también un método que cree el <em>listener</em> necesario para escuchar los eventos de teclado, y programarlo para que avise a los <em>callbacks</em> definidos anteriormente. Esto lo podemos hacer de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">VirtualControls</span><span class="o">::</span><span class="n">addKeyboardListeners</span><span class="p">(</span><span class="n">cocos2d</span><span class="o">::</span><span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//Creo listeners del teclado</span>
    <span class="k">auto</span> <span class="n">listener</span> <span class="o">=</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">EventListenerKeyboard</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
    <span class="n">listener</span><span class="o">-&gt;</span><span class="n">onKeyPressed</span> <span class="o">=</span> <span class="n">CC_CALLBACK_2</span><span class="p">(</span><span class="n">VirtualControls</span><span class="o">::</span><span class="n">onKeyPressed</span><span class="p">,</span><span class="k">this</span><span class="p">);</span>
    <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span>
       <span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span><span class="n">listener</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

    <span class="n">listener</span> <span class="o">=</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">EventListenerKeyboard</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
    <span class="n">listener</span><span class="o">-&gt;</span><span class="n">onKeyReleased</span> <span class="o">=</span> <span class="n">CC_CALLBACK_2</span><span class="p">(</span><span class="n">VirtualControls</span><span class="o">::</span><span class="n">onKeyReleased</span><span class="p">,</span><span class="k">this</span><span class="p">);</span>
    <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span>
       <span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span><span class="n">listener</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Mostramos a continuación el código completo de la clase <code>VirtualControls</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// VirtualControls.h</span>

<span class="cp">#define kNUM_BUTTONS    1</span>
<span class="cp">#define kNUM_AXIS    2</span>

<span class="k">enum</span> <span class="n">Button</span> <span class="p">{</span>
    <span class="n">BUTTON_ACTION</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">BUTTON_LEFT</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">BUTTON_RIGHT</span><span class="o">=</span><span class="mi">2</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">Axis</span> <span class="p">{</span>
    <span class="n">AXIS_HORIZONTAL</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">AXIS_VERTICAL</span><span class="o">=</span><span class="mi">1</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">VirtualControls</span><span class="o">:</span> <span class="k">public</span> <span class="n">Ref</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="kt">bool</span> <span class="n">init</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">preloadResources</span><span class="p">(){};</span>
    <span class="k">virtual</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">getNode</span><span class="p">(){</span><span class="k">return</span> <span class="nb">NULL</span><span class="p">;};</span>

    <span class="kt">bool</span> <span class="nf">isButtonPressed</span><span class="p">(</span><span class="n">Button</span> <span class="n">button</span><span class="p">);</span>
    <span class="kt">float</span> <span class="nf">getAxis</span><span class="p">(</span><span class="n">Axis</span> <span class="n">axis</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Button</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">onButtonPressed</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Button</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">onButtonReleased</span><span class="p">;</span>

    <span class="c1">// Keyboard controls</span>
    <span class="kt">void</span> <span class="nf">onKeyPressed</span><span class="p">(</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span> <span class="n">keyCode</span><span class="p">,</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">Event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">onKeyReleased</span><span class="p">(</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span> <span class="n">keyCode</span><span class="p">,</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">Event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">addKeyboardListeners</span><span class="p">(</span><span class="n">cocos2d</span><span class="o">::</span><span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

    <span class="n">CREATE_FUNC</span><span class="p">(</span><span class="n">VirtualControls</span><span class="p">);</span>

<span class="k">protected</span><span class="o">:</span>

    <span class="kt">bool</span> <span class="n">buttonState</span><span class="p">[</span><span class="n">kNUM_BUTTONS</span><span class="p">];</span>
    <span class="kt">float</span> <span class="n">axisState</span><span class="p">[</span><span class="n">kNUM_AXIS</span><span class="p">];</span>
<span class="p">};</span>



<span class="c1">// VirtualControls.cpp</span>

<span class="kt">bool</span> <span class="n">VirtualControls</span><span class="o">::</span><span class="n">init</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">kNUM_BUTTONS</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buttonState</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">kNUM_AXIS</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">axisState</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">VirtualControls</span><span class="o">::</span><span class="n">isButtonPressed</span><span class="p">(</span><span class="n">Button</span> <span class="n">button</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">buttonState</span><span class="p">[</span><span class="n">button</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="n">VirtualControls</span><span class="o">::</span><span class="n">getAxis</span><span class="p">(</span><span class="n">Axis</span> <span class="n">axis</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">clampf</span><span class="p">(</span><span class="n">axisState</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Keyboard input support</span>

<span class="kt">void</span> <span class="n">VirtualControls</span><span class="o">::</span><span class="n">addKeyboardListeners</span><span class="p">(</span><span class="n">cocos2d</span><span class="o">::</span><span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//Creo listeners del teclado</span>
    <span class="k">auto</span> <span class="n">listener</span> <span class="o">=</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">EventListenerKeyboard</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
    <span class="n">listener</span><span class="o">-&gt;</span><span class="n">onKeyPressed</span> <span class="o">=</span> <span class="n">CC_CALLBACK_2</span><span class="p">(</span><span class="n">VirtualControls</span><span class="o">::</span><span class="n">onKeyPressed</span><span class="p">,</span><span class="k">this</span><span class="p">);</span>
    <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span>
        <span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span><span class="n">listener</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

    <span class="n">listener</span> <span class="o">=</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">EventListenerKeyboard</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
    <span class="n">listener</span><span class="o">-&gt;</span><span class="n">onKeyReleased</span> <span class="o">=</span> <span class="n">CC_CALLBACK_2</span><span class="p">(</span><span class="n">VirtualControls</span><span class="o">::</span><span class="n">onKeyReleased</span><span class="p">,</span><span class="k">this</span><span class="p">);</span>
    <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span>
        <span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span><span class="n">listener</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">VirtualControls</span><span class="o">::</span><span class="n">onKeyPressed</span><span class="p">(</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span> <span class="n">keyCode</span><span class="p">,</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">Event</span> <span class="o">*</span><span class="n">event</span><span class="p">){</span>

    <span class="k">if</span><span class="p">(</span><span class="n">onButtonPressed</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">keyCode</span> <span class="o">==</span> <span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span><span class="o">::</span><span class="n">KEY_LEFT_ARROW</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">onButtonPressed</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_LEFT</span><span class="p">);</span>
            <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_HORIZONTAL</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">1.0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">keyCode</span> <span class="o">==</span> <span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span><span class="o">::</span><span class="n">KEY_RIGHT_ARROW</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">onButtonPressed</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_RIGHT</span><span class="p">);</span>
            <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_HORIZONTAL</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">keyCode</span><span class="o">==</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span><span class="o">::</span><span class="n">KEY_SPACE</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">onButtonPressed</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_ACTION</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="n">VirtualControls</span><span class="o">::</span><span class="n">onKeyReleased</span><span class="p">(</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span> <span class="n">keyCode</span><span class="p">,</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">Event</span> <span class="o">*</span><span class="n">event</span><span class="p">){</span>

    <span class="k">if</span><span class="p">(</span><span class="n">onButtonReleased</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">keyCode</span> <span class="o">==</span> <span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span><span class="o">::</span><span class="n">KEY_LEFT_ARROW</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">onButtonReleased</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_LEFT</span><span class="p">);</span>
            <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_HORIZONTAL</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">keyCode</span> <span class="o">==</span> <span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span><span class="o">::</span><span class="n">KEY_RIGHT_ARROW</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">onButtonReleased</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_RIGHT</span><span class="p">);</span>
            <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_HORIZONTAL</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">1.0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">keyCode</span><span class="o">==</span><span class="n">EventKeyboard</span><span class="o">::</span><span class="n">KeyCode</span><span class="o">::</span><span class="n">KEY_SPACE</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">onButtonReleased</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_ACTION</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>   
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>A continuación veremos cómo crear subclases de <code>VirtualControls</code> que nos permitan implementar formar alternativas de control, con un mando dibujado sobre pantalla. Además de incorporar un mando virtual en pantalla, podremos aprovechar esta estructura de clases para implementar otros mecanismos de control alternativos como acelerómetro o mandos físicos.</p>
<h3 id="pad-virtual">Pad virtual<a class="headerlink" href="#pad-virtual" title="Permanent link">&para;</a></h3>
<p>El <em>pad</em> virtual consiste en dibujar la cruceta de control digital sobre la pantalla y mediante los eventos de la pantalla táctil detectar cuándo se pulsa sobre él. Esta es la forma más sencilla de implementar un control virtual, y será suficiente en el caso de juegos que sólo requieran controles digitales.</p>
<p>Aprovecharemos la clase <code>VirtualControls</code> introducida en el apartado anterior, y crearemos una subclase que lea la entrada a partir de un <em>pad</em> virtual en pantalla, y mapee dicha entrada sobre los eventos de control virtuales genéricos definidos en la <code>VirtualControls</code> (ejes horizontal y vertical y estado de los botones).</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">VirtualPad</span><span class="o">:</span> <span class="k">public</span> <span class="n">VirtualControls</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="kt">bool</span> <span class="n">init</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">preloadResources</span><span class="p">();</span>
    <span class="n">Node</span><span class="o">*</span> <span class="nf">getNode</span><span class="p">();</span>

    <span class="n">CREATE_FUNC</span><span class="p">(</span><span class="n">VirtualPad</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>Crearemos los diferentes botones del <em>pad</em> virtual como <em>sprites</em>, los posicionaremos en pantalla, y programaremos los eventos necesarios para detectar cuándo pulsamos sobre ellos. Vamos a ver un ejemplo sencillo con tres botones, un <em>pad</em> direccional con botones para movernos a la izquierda y derecha, y un botón de acción:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">private</span><span class="o">:</span> 
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Sprite</span> <span class="o">*</span><span class="n">m_buttonAction</span><span class="p">;</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Sprite</span> <span class="o">*</span><span class="n">m_buttonLeft</span><span class="p">;</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Sprite</span> <span class="o">*</span><span class="n">m_buttonRight</span><span class="p">;</span>
    <span class="p">...</span>
</pre></div>
</td></tr></table>

<p>Además, añadimos un <em>listener</em> para leer los eventos de la pantalla táctil que se produzcan sobre los controles anteriores: </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">private</span><span class="o">:</span> 
    <span class="p">...</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">EventListenerTouchOneByOne</span> <span class="o">*</span><span class="n">m_listener</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<p>Vamos a pasar ahora a ver la implementación de la clase <code>VirtualPad</code>. En primer lugar, podemos proporcionar un método para cargar los recursos necesarios para dibujar el mando en pantalla. Podemos cargarlos desde un <em>sprite sheet</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">VirtualPad</span><span class="o">::</span><span class="n">preloadResources</span><span class="p">(){</span>

    <span class="c1">//Cache de sprites</span>
    <span class="k">auto</span> <span class="n">spriteFrameCache</span> <span class="o">=</span> <span class="n">SpriteFrameCache</span><span class="o">::</span><span class="n">getInstance</span><span class="p">();</span>

    <span class="c1">//Si no estaba el spritesheet en la caché lo cargo</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">spriteFrameCache</span><span class="o">-&gt;</span><span class="n">getSpriteFrameByName</span><span class="p">(</span><span class="s">&quot;boton-direccion.png&quot;</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">spriteFrameCache</span><span class="o">-&gt;</span><span class="n">addSpriteFramesWithFile</span><span class="p">(</span><span class="s">&quot;mando.plist&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>A continuación vamos a ver cómo crear la interfaz del <em>pad</em> virtual en pantalla, posicionando de forma correcta los gráficos que hemos cargado y añadiendo los correspondiente <em>listeners</em> de pantalla táctil sobre ellos. Algo que debemos tener en cuenta al posicionar los controles es que éstos siempre deben quedar en la parte visible de la pantalla. Por ejemplo, al inicializar nuestro <em>pad</em> virtual podemos posicionar los botones de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Size</span> <span class="n">visibleSize</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getVisibleSize</span><span class="p">();</span>
<span class="n">Vec2</span> <span class="n">visibleOrigin</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getVisibleOrigin</span><span class="p">();</span>

<span class="n">m_buttonLeft</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;boton-direccion.png&quot;</span><span class="p">);</span>
<span class="n">m_buttonLeft</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="n">m_buttonLeft</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">visibleOrigin</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">kPAD_MARGIN</span><span class="p">,</span> <span class="n">visibleOrigin</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">kPAD_MARGIN</span><span class="p">);</span>
<span class="n">m_buttonLeft</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
<span class="n">m_buttonLeft</span><span class="o">-&gt;</span><span class="n">setTag</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_LEFT</span><span class="p">);</span>

<span class="n">m_buttonRight</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;boton-direccion.png&quot;</span><span class="p">);</span>
<span class="n">m_buttonRight</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="n">m_buttonRight</span><span class="o">-&gt;</span><span class="n">setScaleX</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">m_buttonRight</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
<span class="n">m_buttonRight</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">visibleOrigin</span><span class="p">.</span><span class="n">x</span><span class="o">+</span> <span class="n">kPAD_MARGIN</span> <span class="o">+</span> 
                           <span class="n">m_buttonLeft</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">().</span><span class="n">width</span> <span class="o">+</span> 
                           <span class="n">kPAD_MARGIN</span><span class="p">,</span> <span class="n">visibleOrigin</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">kPAD_MARGIN</span><span class="p">);</span>
<span class="n">m_buttonRight</span><span class="o">-&gt;</span><span class="n">setTag</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_RIGHT</span><span class="p">);</span>

<span class="n">m_buttonAction</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;boton-accion.png&quot;</span><span class="p">);</span>
<span class="n">m_buttonAction</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="n">m_buttonAction</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">visibleOrigin</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">visibleSize</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">kPAD_MARGIN</span><span class="p">,</span> 
                            <span class="n">visibleOrigin</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">kPAD_MARGIN</span><span class="p">);</span>
<span class="n">m_buttonAction</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
<span class="n">m_buttonAction</span><span class="o">-&gt;</span><span class="n">setTag</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_ACTION</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>En este ejemplo vemos además que hacemos los botones <strong>semitransparentes</strong>. Esta es una práctica habitual, que hará que los botones virtuales afecten menos al apartado visual de nuestro videojuego.</p>
<p><img alt="Pad virtual" src="imagenes/mandos/virtual-pad.png" /></p>
<p>También podemos observar que hemos aprovechado la propiedad <em>tag</em> de los botones para identificarlos mediante los elementos de la enumeración <code>Button</code>. Veremos que esto será de especial interés cuando procesemos los eventos, para saber a qué botón virtual corresponde cada botón en pantalla.</p>
<p>Una vez hemos creado los <em>sprites</em> de los botones los añadiremos a la pantalla:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">m_node</span><span class="o">=</span> <span class="n">Node</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
<span class="n">m_node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">m_buttonLeft</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">m_node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">m_buttonRight</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">m_node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">m_buttonAction</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">m_node</span><span class="o">-&gt;</span><span class="n">setLocalZOrder</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Tras esto, debemos definir un <em>listener</em> de eventos táctiles para detectar cuándo pulsamos sobre ellos: </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">m_listener</span> <span class="o">=</span> <span class="n">EventListenerTouchOneByOne</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
<span class="n">m_listener</span><span class="o">-&gt;</span><span class="n">setSwallowTouches</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Aprovecharemos las funciones <code>onButttonPressed</code> y <code>onButtonReleased</code> definidas en la superclase <code>VirtualControls</code> para avisar al <em>callback</em> que tuviesen asignado (si hubiese alguno) de que un botón ha sido pulsado o liberado, y actualizaremos también el estado de los botones (<code>buttonState</code>).</p>
<p>Empezamos detectando cuando comienza un contacto en pantalla. Si se ha pulsado sobre unos de los botones, lo marcaremos como <em>pulsado</em> y llamamos a los <em>callbacks</em> correspondientes (si no son <code>NULL</code>):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">m_listener</span><span class="o">-&gt;</span><span class="n">onTouchBegan</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
    <span class="n">Point</span> <span class="n">locationInNode</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">convertToNodeSpace</span><span class="p">(</span><span class="n">touch</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">());</span>

    <span class="n">Size</span> <span class="n">s</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">();</span>
    <span class="n">Rect</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">rect</span><span class="p">.</span><span class="n">containsPoint</span><span class="p">(</span><span class="n">locationInNode</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">buttonState</span><span class="p">[</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">()]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="c1">// Solo llama al callback si no es NULL</span>
        <span class="k">if</span><span class="p">(</span><span class="n">onButtonPressed</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">onButtonPressed</span><span class="p">((</span><span class="n">PadButton</span><span class="p">)</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="n">target</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">255</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>En este caso <code>target</code> se refiere al botón sobre el que se ha definido el <em>listener</em>. Comprobamos si hemos pulsado sobre el área del botón (<code>target</code>) y en tal caso anotamos que dicho botón está pulsado y avisamos al <em>callback</em> correspondiente, en caso de que se haya asignado uno.</p>
<p>De forma similar podemos programar el evento de finalización del contacto, y en ese caso marcamos el botón como <em>no pulsado</em> y llamamos al <em>callback</em> correspondiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">m_listener</span><span class="o">-&gt;</span><span class="n">onTouchEnded</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
    <span class="n">target</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
    <span class="n">buttonState</span><span class="p">[</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">()]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="c1">// Solo llama al callback si no es NULL</span>
    <span class="k">if</span><span class="p">(</span><span class="n">onButtonReleased</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">onButtonReleased</span><span class="p">((</span><span class="n">PadButton</span><span class="p">)</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>Obtenemos el botón (<code>target</code>) sobre el que se ha definido el <em>listener</em> y anotamos que el botón ya no está pulsado, además de llamar al <em>callback</em> correspondiente en caso de estar asignado.</p>
<p>Por último, añadiremos el <em>listener</em> sobre cada uno de los botones. Podemos observar que hay una instancia del <em>listener</em> para cada botón, con lo que en cada uno de ellos el <code>target</code> será un único botón concreto:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">m_node</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span><span class="n">m_listener</span><span class="p">,</span> <span class="n">m_buttonLeft</span><span class="p">);</span>
<span class="n">m_node</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span><span class="n">m_listener</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">(),</span> <span class="n">m_buttonRight</span><span class="p">);</span>
<span class="n">m_node</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span><span class="n">m_listener</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">(),</span> <span class="n">m_buttonAction</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Mostramos a continuación el código completo de esta implementación sencilla de un <em>pad</em> virtual:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// VirtualPad.h</span>

<span class="cp">#define kPAD_MARGIN   20</span>

<span class="k">class</span> <span class="nc">VirtualPad</span><span class="o">:</span> <span class="k">public</span> <span class="n">VirtualControls</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="kt">bool</span> <span class="n">init</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">preloadResources</span><span class="p">();</span>
    <span class="n">Node</span><span class="o">*</span> <span class="nf">getNode</span><span class="p">();</span>

    <span class="n">CREATE_FUNC</span><span class="p">(</span><span class="n">VirtualPad</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Sprite</span> <span class="o">*</span><span class="n">m_buttonAction</span><span class="p">;</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Sprite</span> <span class="o">*</span><span class="n">m_buttonLeft</span><span class="p">;</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Sprite</span> <span class="o">*</span><span class="n">m_buttonRight</span><span class="p">;</span>

    <span class="n">cocos2d</span><span class="o">::</span><span class="n">EventListenerTouchOneByOne</span> <span class="o">*</span><span class="n">m_listener</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">// VirtualPad.cpp</span>

<span class="kt">bool</span> <span class="n">VirtualPad</span><span class="o">::</span><span class="n">init</span><span class="p">(){</span>
    <span class="n">VirtualControls</span><span class="o">::</span><span class="n">init</span><span class="p">();</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">VirtualPad</span><span class="o">::</span><span class="n">preloadResources</span><span class="p">(){</span>

    <span class="c1">//Cache de sprites</span>
    <span class="k">auto</span> <span class="n">spriteFrameCache</span> <span class="o">=</span> <span class="n">SpriteFrameCache</span><span class="o">::</span><span class="n">getInstance</span><span class="p">();</span>

    <span class="c1">//Si no estaba el spritesheet en la caché lo cargo</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">spriteFrameCache</span><span class="o">-&gt;</span><span class="n">getSpriteFrameByName</span><span class="p">(</span><span class="s">&quot;boton-direccion.png&quot;</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">spriteFrameCache</span><span class="o">-&gt;</span><span class="n">addSpriteFramesWithFile</span><span class="p">(</span><span class="s">&quot;mando.plist&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Node</span><span class="o">*</span> <span class="n">VirtualPad</span><span class="o">::</span><span class="n">getNode</span><span class="p">(){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">m_node</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">Size</span> <span class="n">visibleSize</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getVisibleSize</span><span class="p">();</span>
        <span class="n">Vec2</span> <span class="n">visibleOrigin</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getVisibleOrigin</span><span class="p">();</span>

        <span class="n">m_buttonLeft</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;boton-direccion.png&quot;</span><span class="p">);</span>
        <span class="n">m_buttonLeft</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
        <span class="n">m_buttonLeft</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">visibleOrigin</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">kPAD_MARGIN</span><span class="p">,</span> 
                                  <span class="n">visibleOrigin</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">kPAD_MARGIN</span><span class="p">);</span>
        <span class="n">m_buttonLeft</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
        <span class="n">m_buttonLeft</span><span class="o">-&gt;</span><span class="n">setTag</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_LEFT</span><span class="p">);</span>

        <span class="n">m_buttonRight</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;boton-direccion.png&quot;</span><span class="p">);</span>
        <span class="n">m_buttonRight</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
        <span class="n">m_buttonRight</span><span class="o">-&gt;</span><span class="n">setScaleX</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">m_buttonRight</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
        <span class="n">m_buttonRight</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">visibleOrigin</span><span class="p">.</span><span class="n">x</span><span class="o">+</span> <span class="n">kPAD_MARGIN</span> <span class="o">+</span> 
                                   <span class="n">m_buttonLeft</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">().</span><span class="n">width</span> <span class="o">+</span> 
                                   <span class="n">kPAD_MARGIN</span><span class="p">,</span> <span class="n">visibleOrigin</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">kPAD_MARGIN</span><span class="p">);</span>
        <span class="n">m_buttonRight</span><span class="o">-&gt;</span><span class="n">setTag</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_RIGHT</span><span class="p">);</span>

        <span class="n">m_buttonAction</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;boton-accion.png&quot;</span><span class="p">);</span>
        <span class="n">m_buttonAction</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
        <span class="n">m_buttonAction</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">visibleOrigin</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">visibleSize</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> 
                                    <span class="n">kPAD_MARGIN</span><span class="p">,</span> <span class="n">visibleOrigin</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">kPAD_MARGIN</span><span class="p">);</span>
        <span class="n">m_buttonAction</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
        <span class="n">m_buttonAction</span><span class="o">-&gt;</span><span class="n">setTag</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_ACTION</span><span class="p">);</span>

        <span class="n">m_node</span><span class="o">=</span> <span class="n">Node</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">m_buttonLeft</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">m_buttonRight</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">m_buttonAction</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">setLocalZOrder</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

        <span class="n">m_listener</span> <span class="o">=</span> <span class="n">EventListenerTouchOneByOne</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
        <span class="n">m_listener</span><span class="o">-&gt;</span><span class="n">setSwallowTouches</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

        <span class="n">m_listener</span><span class="o">-&gt;</span><span class="n">onTouchBegan</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>

            <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
            <span class="n">Point</span> <span class="n">locationInNode</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">convertToNodeSpace</span><span class="p">(</span><span class="n">touch</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">());</span>

            <span class="n">Size</span> <span class="n">s</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">();</span>
            <span class="n">Rect</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>

            <span class="k">if</span><span class="p">(</span><span class="n">rect</span><span class="p">.</span><span class="n">containsPoint</span><span class="p">(</span><span class="n">locationInNode</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">buttonState</span><span class="p">[</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">()]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">onButtonPressed</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">onButtonPressed</span><span class="p">((</span><span class="n">Button</span><span class="p">)</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">());</span>
                <span class="p">}</span>
                <span class="n">target</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">255</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="n">m_listener</span><span class="o">-&gt;</span><span class="n">onTouchEnded</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
            <span class="n">target</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
            <span class="n">buttonState</span><span class="p">[</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">()]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">onButtonReleased</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">onButtonReleased</span><span class="p">((</span><span class="n">Button</span><span class="p">)</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span>
           <span class="n">m_listener</span><span class="p">,</span> <span class="n">m_buttonLeft</span><span class="p">);</span>
        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span>
           <span class="n">m_listener</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">(),</span> <span class="n">m_buttonRight</span><span class="p">);</span>
        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span>
           <span class="n">m_listener</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">(),</span> <span class="n">m_buttonAction</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="k">return</span> <span class="n">m_node</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="stick-virtual">Stick virtual<a class="headerlink" href="#stick-virtual" title="Permanent link">&para;</a></h3>
<p>El <em>stick</em> virtual emula el <em>stick</em> analógico de un mando. Podremos pulsar sobre él y arrastrar para así graduar cuánto queremos moverlo en una determinada dirección. En el caso del <em>pad</em> por ejemplo la dirección izquierda puede estar pulsada o no estarlo. En el <em>stick</em> podemos moverlo más o menos a la izquierda. Podremos leer el estado del <em>stick</em> analógico a partir del valor de sus ejes vertical y horizontal, que tomarán valores reales entre <code>-1</code> y <code>1</code>.</p>
<p>Para crear el aspecto visual de nuestro <em>stick</em> analógico utilizaremos dos <em>sprites</em>, uno para la base, que no se moverá nunca, y otro para la "palanca", que se desplazará conforme la arrastremos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">private</span><span class="o">:</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Sprite</span> <span class="o">*</span><span class="n">m_stickLeft</span><span class="p">;</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Sprite</span> <span class="o">*</span><span class="n">m_stickLeftBase</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<p>Además, para facilitar la gestión del <em>stick</em> almacenaremos su posición central y el radio en el que puede moverse:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">private</span><span class="o">:</span>
    <span class="p">...</span>

    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Size</span> <span class="n">m_radioStick</span><span class="p">;</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Point</span> <span class="n">m_centerStick</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<p>Una vez definidas estas propiedades de la clase de nuestro <em>stick</em> vamos a pasar a implementar el código. Inicializaremos los <em>sprites</em> que componen el <em>stick</em> de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Size</span> <span class="n">visibleSize</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getVisibleSize</span><span class="p">();</span>
<span class="n">Vec2</span> <span class="n">visibleOrigin</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getVisibleOrigin</span><span class="p">();</span>

<span class="n">m_stickLeftBase</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;base-stick.png&quot;</span><span class="p">);</span>
<span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">visibleOrigin</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">kSTICK_MARGIN</span><span class="p">,</span> <span class="n">visibleOrigin</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">kSTICK_MARGIN</span><span class="p">);</span>
<span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>

<span class="n">m_stickLeft</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;bola-stick.png&quot;</span><span class="p">);</span>
<span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">));</span>
<span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>

<span class="n">m_radioStick</span> <span class="o">=</span> <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="n">m_centerStick</span> <span class="o">=</span> <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">getPosition</span><span class="p">()</span> <span class="o">+</span> <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">m_centerStick</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Como podemos ver, posicionamos en primer lugar la base del <em>stick</em> en la esquina inferior-izquierda de la pantalla, haciéndola semiopaca. Tras esto, creamos la palanca y la posicionamos justo en el centro de la base. Definimos <code>m_centerStick</code> como la posición central de la base de la palanca, y <code>m_radioStick</code> como el radio en el que la palanca podrá moverse. Este radio se obtiene a partir de la media anchura y altura de la base, restándole la media anchura y altura de la palanca, para que así esta última quede siempre dentro de la base al desplazarla.</p>
<p><img alt="Stick virtual" src="imagenes/mandos/virtual-stick.png" /></p>
<p>Una vez creado y configurado el <em>stick</em>, lo añadimos a la pantalla:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">m_node</span><span class="o">=</span> <span class="n">Node</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
<span class="n">m_node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">m_stickLeftBase</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">m_node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">m_stickLeft</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">m_node</span><span class="o">-&gt;</span><span class="n">setLocalZOrder</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>A continuación, definiremos un <em>listener</em> de eventos táctiles para controlar el <em>stick</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">EventListenerTouchOneByOne</span><span class="o">*</span> <span class="n">listener</span> <span class="o">=</span> <span class="n">EventListenerTouchOneByOne</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
<span class="n">listener</span><span class="o">-&gt;</span><span class="n">setSwallowTouches</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>En el evento del comienzo del contacto comprobaremos si estamos tocando dentro de la palanca, y en tal caso devolveremos <code>true</code> para seguir procesando el gesto. En caso contrario, devolvemos <code>false</code> para ignorar los siguientes eventos de movimiento de dicho contacto.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchBegan</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
    <span class="n">Point</span> <span class="n">locationInNode</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">convertToNodeSpace</span><span class="p">(</span><span class="n">touch</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">());</span>

    <span class="n">Size</span> <span class="n">s</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">();</span>
    <span class="n">Rect</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">rect</span><span class="p">.</span><span class="n">containsPoint</span><span class="p">(</span><span class="n">locationInNode</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">target</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">255</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>El evento más importante será el de movimiento del contacto:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchMoved</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
    <span class="n">Point</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">touch</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">()</span><span class="o">-</span><span class="n">touch</span><span class="o">-&gt;</span><span class="n">getStartLocation</span><span class="p">();</span>

    <span class="n">Point</span> <span class="nf">max</span><span class="p">(</span><span class="n">m_radioStick</span><span class="p">);</span>
    <span class="n">Point</span> <span class="nf">min</span><span class="p">(</span><span class="n">Point</span><span class="o">::</span><span class="n">ZERO</span><span class="o">-</span><span class="n">m_radioStick</span><span class="p">);</span>
    <span class="n">offset</span><span class="p">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>

    <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_VERTICAL</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">max</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_HORIZONTAL</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">max</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>

    <span class="n">target</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">m_centerStick</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>En este caso calculamos el desplazamiento (<em>offset</em>) de la posición a la que hemos movido el dedo respecto a la posición del contacto que inició el gesto (<code>getStartLocation()</code>). En función de dicho desplazamiento calculamos el valor de cada uno de los ejes, no permitiendo que se salga nunca del radio permitido (esto lo hacemos con la función <code>clamp</code>, para hacer que <code>offset</code> nunca pueda ser mayor que la posición máxima ni menor que la mínima). </p>
<p>Por último, en el evento de finalización del gesto volveremos a poner ambos ejes en la posición central (0,0):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchEnded</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
    <span class="n">target</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
    <span class="n">target</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">m_centerStick</span><span class="p">);</span>

    <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_VERTICAL</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_HORIZONTAL</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>Añadiremos el <em>listener</em> al gestor de eventos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">m_node</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span><span class="n">listener</span><span class="p">,</span> <span class="n">m_stickLeft</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Para terminar incluimos el código completo de la clase que implementa el <em>stick</em> analógico y un botón digital:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// VirtualStick.h</span>

<span class="cp">#define kSTICK_MARGIN   20</span>

<span class="k">class</span> <span class="nc">VirtualStick</span><span class="o">:</span> <span class="k">public</span> <span class="n">VirtualControls</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="kt">bool</span> <span class="n">init</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">preloadResources</span><span class="p">();</span>
    <span class="n">Node</span><span class="o">*</span> <span class="nf">getNode</span><span class="p">();</span>

    <span class="n">CREATE_FUNC</span><span class="p">(</span><span class="n">VirtualStick</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Sprite</span> <span class="o">*</span><span class="n">m_buttonAction</span><span class="p">;</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Sprite</span> <span class="o">*</span><span class="n">m_stickLeft</span><span class="p">;</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Sprite</span> <span class="o">*</span><span class="n">m_stickLeftBase</span><span class="p">;</span>

    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Size</span> <span class="n">m_radioStick</span><span class="p">;</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Point</span> <span class="n">m_centerStick</span><span class="p">;</span>    
<span class="p">};</span>


<span class="c1">// VirtualStick.cpp</span>

<span class="kt">bool</span> <span class="n">VirtualStick</span><span class="o">::</span><span class="n">init</span><span class="p">(){</span>
    <span class="n">VirtualControls</span><span class="o">::</span><span class="n">init</span><span class="p">();</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">VirtualStick</span><span class="o">::</span><span class="n">preloadResources</span><span class="p">(){</span>

    <span class="c1">//Cache de sprites</span>
    <span class="k">auto</span> <span class="n">spriteFrameCache</span> <span class="o">=</span> <span class="n">SpriteFrameCache</span><span class="o">::</span><span class="n">getInstance</span><span class="p">();</span>

    <span class="c1">//Si no estaba el spritesheet en la caché lo cargo</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">spriteFrameCache</span><span class="o">-&gt;</span><span class="n">getSpriteFrameByName</span><span class="p">(</span><span class="s">&quot;boton-direccion.png&quot;</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">spriteFrameCache</span><span class="o">-&gt;</span><span class="n">addSpriteFramesWithFile</span><span class="p">(</span><span class="s">&quot;mando.plist&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Node</span><span class="o">*</span> <span class="n">VirtualStick</span><span class="o">::</span><span class="n">getNode</span><span class="p">(){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">m_node</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">Size</span> <span class="n">visibleSize</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getVisibleSize</span><span class="p">();</span>
        <span class="n">Vec2</span> <span class="n">visibleOrigin</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getVisibleOrigin</span><span class="p">();</span>

        <span class="n">m_stickLeftBase</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;base-stick.png&quot;</span><span class="p">);</span>
        <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
        <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">visibleOrigin</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">kSTICK_MARGIN</span><span class="p">,</span>
                                     <span class="n">visibleOrigin</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">kSTICK_MARGIN</span><span class="p">);</span>
        <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>

        <span class="n">m_stickLeft</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;bola-stick.png&quot;</span><span class="p">);</span>
        <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">));</span>
        <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>

        <span class="n">m_radioStick</span> <span class="o">=</span> <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> 
                       <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
        <span class="n">m_centerStick</span> <span class="o">=</span> <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">getPosition</span><span class="p">()</span> <span class="o">+</span> 
                        <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
        <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">m_centerStick</span><span class="p">);</span>

        <span class="n">m_buttonAction</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;boton-accion.png&quot;</span><span class="p">);</span>
        <span class="n">m_buttonAction</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
        <span class="n">m_buttonAction</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">visibleOrigin</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">visibleSize</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> 
                                    <span class="n">kSTICK_MARGIN</span><span class="p">,</span> <span class="n">visibleOrigin</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">kSTICK_MARGIN</span><span class="p">);</span>
        <span class="n">m_buttonAction</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
        <span class="n">m_buttonAction</span><span class="o">-&gt;</span><span class="n">setTag</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_ACTION</span><span class="p">);</span>

        <span class="n">m_node</span><span class="o">=</span> <span class="n">Node</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">m_stickLeftBase</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">m_stickLeft</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">m_buttonAction</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">setLocalZOrder</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

        <span class="n">EventListenerTouchOneByOne</span><span class="o">*</span> <span class="n">listener</span> <span class="o">=</span> <span class="n">EventListenerTouchOneByOne</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
        <span class="n">listener</span><span class="o">-&gt;</span><span class="n">setSwallowTouches</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

        <span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchBegan</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>

            <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
            <span class="n">Point</span> <span class="n">locationInNode</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">convertToNodeSpace</span><span class="p">(</span><span class="n">touch</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">());</span>

            <span class="n">Size</span> <span class="n">s</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">();</span>
            <span class="n">Rect</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>

            <span class="k">if</span><span class="p">(</span><span class="n">rect</span><span class="p">.</span><span class="n">containsPoint</span><span class="p">(</span><span class="n">locationInNode</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">buttonState</span><span class="p">[</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">()]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">onButtonPressed</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">onButtonPressed</span><span class="p">((</span><span class="n">Button</span><span class="p">)</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">());</span>
                <span class="p">}</span>
                <span class="n">target</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">255</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchEnded</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
            <span class="n">target</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
            <span class="n">buttonState</span><span class="p">[</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">()]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">onButtonReleased</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">onButtonReleased</span><span class="p">((</span><span class="n">Button</span><span class="p">)</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span>
           <span class="n">listener</span><span class="p">,</span> <span class="n">m_buttonAction</span><span class="p">);</span>

        <span class="c1">// Listener stick</span>
        <span class="n">listener</span> <span class="o">=</span> <span class="n">EventListenerTouchOneByOne</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
        <span class="n">listener</span><span class="o">-&gt;</span><span class="n">setSwallowTouches</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

        <span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchBegan</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>

            <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
            <span class="n">Point</span> <span class="n">locationInNode</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">convertToNodeSpace</span><span class="p">(</span><span class="n">touch</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">());</span>

            <span class="n">Size</span> <span class="n">s</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">();</span>
            <span class="n">Rect</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>

            <span class="k">if</span><span class="p">(</span><span class="n">rect</span><span class="p">.</span><span class="n">containsPoint</span><span class="p">(</span><span class="n">locationInNode</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">target</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">255</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchMoved</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
            <span class="n">Point</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">touch</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">()</span><span class="o">-</span><span class="n">touch</span><span class="o">-&gt;</span><span class="n">getStartLocation</span><span class="p">();</span>

            <span class="n">Point</span> <span class="nf">max</span><span class="p">(</span><span class="n">m_radioStick</span><span class="p">);</span>
            <span class="n">Point</span> <span class="nf">min</span><span class="p">(</span><span class="n">Point</span><span class="o">::</span><span class="n">ZERO</span><span class="o">-</span><span class="n">m_radioStick</span><span class="p">);</span>
            <span class="n">offset</span><span class="p">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>

            <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_VERTICAL</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">max</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
            <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_HORIZONTAL</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">max</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>

            <span class="n">target</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">m_centerStick</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
        <span class="p">};</span>

        <span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchEnded</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
            <span class="n">target</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
            <span class="n">target</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">m_centerStick</span><span class="p">);</span>

            <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_VERTICAL</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_HORIZONTAL</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span>
           <span class="n">listener</span><span class="p">,</span> <span class="n">m_stickLeft</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="k">return</span> <span class="n">m_node</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="stick-virtual-con-posicionamiento-automatico">Stick virtual con posicionamiento automático<a class="headerlink" href="#stick-virtual-con-posicionamiento-automatico" title="Permanent link">&para;</a></h3>
<p>El <em>stick</em> virtual tiene el problema de no tener <em>feedback</em> físico, por lo que si tenemos la atención centrada en la escena del juego es posible que no sepamos si estamos tocando en el centro del mando o no, al intentar hacer un moviemiento. Para evitar esto podemos hacer que al tocar sobre la pantalla el <em>stick</em> se sitúe automáticamente centrado en la posición donde hemos tocado. Así sabremos que siempre tocamos en el centro, y sólo tendremos que arrastrar.</p>
<p>Una posible estrategia para implementar este tipo de <em>sticks</em> es dividir el tamaño de la pantalla en dos: el lado izquierdo dedicado al <em>stick</em> analógico, y el lado derecho a los botones de acción. Al pulsar en cualquier lugar del lado izquierdo crearemos un <em>stick</em> analógico en dicha posición, y al arrastrar moveremos sus ejes. Al pulsar en el lado derecho realizaremos una acción (por ejemplo saltar). Deberemos crear una variante adecuada para nuestro tipo de juego. </p>
<p><img alt="Stick virtual con autoposicionamiento" src="imagenes/mandos/virtual-stick-auto.png" /></p>
<p>Crearemos los <em>sprites</em> necesarios para el <em>stick</em> analógico autoposicionado de forma similar al caso anterior, pero con la diferencia de que en este caso los haremos invisibles y no les daremos ninguna posición inicial:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Size</span> <span class="n">visibleSize</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getVisibleSize</span><span class="p">();</span>
<span class="n">Vec2</span> <span class="n">visibleOrigin</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getVisibleOrigin</span><span class="p">();</span>

<span class="n">m_stickLeftBase</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;base-stick.png&quot;</span><span class="p">);</span>
<span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">));</span>
<span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

<span class="n">m_stickLeft</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;bola-stick.png&quot;</span><span class="p">);</span>
<span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">));</span>
<span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

<span class="n">m_radioStick</span> <span class="o">=</span> <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<p>Los añadimos a la pantalla:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">m_node</span><span class="o">=</span> <span class="n">Node</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
<span class="n">m_node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">m_stickLeftBase</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">m_node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">m_stickLeft</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">m_node</span><span class="o">-&gt;</span><span class="n">setLocalZOrder</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Y creamos un <em>listener</em> para los eventos de la pantalla táctil:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">EventListenerTouchOneByOne</span><span class="o">*</span> <span class="n">listener</span> <span class="o">=</span> <span class="n">EventListenerTouchOneByOne</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
<span class="n">listener</span><span class="o">-&gt;</span><span class="n">setSwallowTouches</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Donde si que introduciremos notables diferencias es en los eventos del <em>listener</em>. En primer lugar, <code>onTouchBegan</code> comprobará si tocamos en la mitad izquierda de la pantalla, y en tal caso hará aparecer el <em>stick</em> en la posición donde hemos tocado y devolverá <code>true</code> para seguir procesando el gesto. En caso contrario devuelve <code>false</code> para ignorar los siguientes eventos de movimento de dicho gesto (en tal caso se deja que lo procese el <em>listener</em> encargado de los botones de acción a la derecha):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchBegan</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
    <span class="n">m_centerStick</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">convertToNodeSpace</span><span class="p">(</span><span class="n">touch</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">());</span>
    <span class="n">Size</span> <span class="n">winSize</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getWinSize</span><span class="p">();</span>

    <span class="k">if</span><span class="p">(</span><span class="n">m_centerStick</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">winSize</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">m_centerStick</span><span class="p">);</span>
        <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
        <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">m_centerStick</span><span class="p">);</span>
        <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>Destacamos que en este caso utilizamos también la propiedad <code>m_centerStick</code>, pero no le damos una posición fija en la actualización, sino que la modificamos cada vez que comenzamos un nuevo gesto táctil en <code>onTouchBegan</code>.</p>
<p>En segundo lugar, <code>onTouchMoved</code> se comporará igual que en el caso del <em>stick</em> con posición fija:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchMoved</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Point</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">touch</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">()</span><span class="o">-</span><span class="n">touch</span><span class="o">-&gt;</span><span class="n">getStartLocation</span><span class="p">();</span>

    <span class="n">Point</span> <span class="nf">max</span><span class="p">(</span><span class="n">m_radioStick</span><span class="p">);</span>
    <span class="n">Point</span> <span class="nf">min</span><span class="p">(</span><span class="n">Point</span><span class="o">::</span><span class="n">ZERO</span><span class="o">-</span><span class="n">m_radioStick</span><span class="p">);</span>
    <span class="n">offset</span><span class="p">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>

    <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_VERTICAL</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">max</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_HORIZONTAL</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">max</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>

    <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">m_centerStick</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>Por último, <code>onTouchEnded</code> tiene como diferencia que en este caso volveremos a ocultar el <em>stick</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchEnded</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

    <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_VERTICAL</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_HORIZONTAL</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>A continuación incluimos el código completo de las clases que incorporan el <em>stick</em> analógico con posicionamiento automático, combinado con un botón de acción en la parte derecha:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// VirtualStickAuto.h</span>

<span class="cp">#define kAUTOSTICK_MARGIN   20</span>

<span class="k">class</span> <span class="nc">VirtualStickAuto</span><span class="o">:</span> <span class="k">public</span> <span class="n">VirtualControls</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="kt">bool</span> <span class="n">init</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">preloadResources</span><span class="p">();</span>
    <span class="n">Node</span><span class="o">*</span> <span class="nf">getNode</span><span class="p">();</span>

    <span class="n">CREATE_FUNC</span><span class="p">(</span><span class="n">VirtualStickAuto</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Sprite</span> <span class="o">*</span><span class="n">m_buttonAction</span><span class="p">;</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Sprite</span> <span class="o">*</span><span class="n">m_stickLeft</span><span class="p">;</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Sprite</span> <span class="o">*</span><span class="n">m_stickLeftBase</span><span class="p">;</span>

    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Size</span> <span class="n">m_radioStick</span><span class="p">;</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Point</span> <span class="n">m_centerStick</span><span class="p">;</span>    
<span class="p">};</span>


<span class="c1">// VirtualStickAuto.cpp</span>

<span class="kt">bool</span> <span class="n">VirtualStickAuto</span><span class="o">::</span><span class="n">init</span><span class="p">(){</span>
    <span class="n">VirtualControls</span><span class="o">::</span><span class="n">init</span><span class="p">();</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">VirtualStickAuto</span><span class="o">::</span><span class="n">preloadResources</span><span class="p">(){</span>

    <span class="c1">//Cache de sprites</span>
    <span class="k">auto</span> <span class="n">spriteFrameCache</span> <span class="o">=</span> <span class="n">SpriteFrameCache</span><span class="o">::</span><span class="n">getInstance</span><span class="p">();</span>

    <span class="c1">//Si no estaba el spritesheet en la caché lo cargo</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">spriteFrameCache</span><span class="o">-&gt;</span><span class="n">getSpriteFrameByName</span><span class="p">(</span><span class="s">&quot;boton-direccion.png&quot;</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">spriteFrameCache</span><span class="o">-&gt;</span><span class="n">addSpriteFramesWithFile</span><span class="p">(</span><span class="s">&quot;mando.plist&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Node</span><span class="o">*</span> <span class="n">VirtualStickAuto</span><span class="o">::</span><span class="n">getNode</span><span class="p">(){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">m_node</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">Size</span> <span class="n">visibleSize</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getVisibleSize</span><span class="p">();</span>
        <span class="n">Vec2</span> <span class="n">visibleOrigin</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getVisibleOrigin</span><span class="p">();</span>

        <span class="n">m_stickLeftBase</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;base-stick.png&quot;</span><span class="p">);</span>
        <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">));</span>
        <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

        <span class="n">m_stickLeft</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;bola-stick.png&quot;</span><span class="p">);</span>
        <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">));</span>
        <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

        <span class="n">m_radioStick</span> <span class="o">=</span> <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> 
                       <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>

        <span class="n">m_buttonAction</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;boton-accion.png&quot;</span><span class="p">);</span>
        <span class="n">m_buttonAction</span><span class="o">-&gt;</span><span class="n">setAnchorPoint</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
        <span class="n">m_buttonAction</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
        <span class="n">m_buttonAction</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">visibleOrigin</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">visibleSize</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> 
                                    <span class="n">kAUTOSTICK_MARGIN</span><span class="p">,</span> <span class="n">visibleOrigin</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">kAUTOSTICK_MARGIN</span><span class="p">);</span>
        <span class="n">m_buttonAction</span><span class="o">-&gt;</span><span class="n">setTag</span><span class="p">(</span><span class="n">Button</span><span class="o">::</span><span class="n">BUTTON_ACTION</span><span class="p">);</span>

        <span class="n">m_node</span><span class="o">=</span> <span class="n">Node</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">m_stickLeftBase</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">m_stickLeft</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">m_buttonAction</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">setLocalZOrder</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

        <span class="n">EventListenerTouchOneByOne</span><span class="o">*</span> <span class="n">listener</span> <span class="o">=</span> <span class="n">EventListenerTouchOneByOne</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
        <span class="n">listener</span><span class="o">-&gt;</span><span class="n">setSwallowTouches</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

        <span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchBegan</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>

            <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
            <span class="n">Point</span> <span class="n">locationInNode</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">convertToNodeSpace</span><span class="p">(</span><span class="n">touch</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">());</span>

            <span class="n">Size</span> <span class="n">s</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">getContentSize</span><span class="p">();</span>
            <span class="n">Rect</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>

            <span class="k">if</span><span class="p">(</span><span class="n">rect</span><span class="p">.</span><span class="n">containsPoint</span><span class="p">(</span><span class="n">locationInNode</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">buttonState</span><span class="p">[</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">()]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">onButtonPressed</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">onButtonPressed</span><span class="p">((</span><span class="n">Button</span><span class="p">)</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">());</span>
                <span class="p">}</span>
                <span class="n">target</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">255</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchEnded</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
            <span class="n">target</span><span class="o">-&gt;</span><span class="n">setOpacity</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
            <span class="n">buttonState</span><span class="p">[</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">()]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">onButtonReleased</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">onButtonReleased</span><span class="p">((</span><span class="n">Button</span><span class="p">)</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span>
           <span class="n">listener</span><span class="p">,</span> <span class="n">m_buttonAction</span><span class="p">);</span>

        <span class="c1">// Listener stick</span>
        <span class="n">listener</span> <span class="o">=</span> <span class="n">EventListenerTouchOneByOne</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
        <span class="n">listener</span><span class="o">-&gt;</span><span class="n">setSwallowTouches</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

        <span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchBegan</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>

            <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Sprite</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">getCurrentTarget</span><span class="p">());</span>
            <span class="n">m_centerStick</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">convertToNodeSpace</span><span class="p">(</span><span class="n">touch</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">());</span>
            <span class="n">Size</span> <span class="n">winSize</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getWinSize</span><span class="p">();</span>

            <span class="k">if</span><span class="p">(</span><span class="n">m_centerStick</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">winSize</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">m_centerStick</span><span class="p">);</span>
                <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
                <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">m_centerStick</span><span class="p">);</span>
                <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchMoved</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Point</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">touch</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">()</span><span class="o">-</span><span class="n">touch</span><span class="o">-&gt;</span><span class="n">getStartLocation</span><span class="p">();</span>

            <span class="n">Point</span> <span class="nf">max</span><span class="p">(</span><span class="n">m_radioStick</span><span class="p">);</span>
            <span class="n">Point</span> <span class="nf">min</span><span class="p">(</span><span class="n">Point</span><span class="o">::</span><span class="n">ZERO</span><span class="o">-</span><span class="n">m_radioStick</span><span class="p">);</span>
            <span class="n">offset</span><span class="p">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>

            <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_VERTICAL</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">max</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
            <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_HORIZONTAL</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">max</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>

            <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">m_centerStick</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
        <span class="p">};</span>

        <span class="n">listener</span><span class="o">-&gt;</span><span class="n">onTouchEnded</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">Touch</span><span class="o">*</span> <span class="n">touch</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_stickLeftBase</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
            <span class="n">m_stickLeft</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

            <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_VERTICAL</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">axisState</span><span class="p">[</span><span class="n">Axis</span><span class="o">::</span><span class="n">AXIS_HORIZONTAL</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="n">m_node</span><span class="o">-&gt;</span><span class="n">getEventDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span><span class="n">listener</span><span class="p">,</span> <span class="n">m_node</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="k">return</span> <span class="n">m_node</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<blockquote>
<p>Es importante remarcar que con esta implementación de controles virtuales podremos reemplazar un tipo de control por otro sin afectar al código de nuestro juego, que siempre utilizará <code>VirtualControls</code>. Simplemente cambiando la subclase concreta que instanciamos podremos alternar entre diferentes formas de control.</p>
</blockquote>
<h2 id="mandos-fisicos">Mandos físicos<a class="headerlink" href="#mandos-fisicos" title="Permanent link">&para;</a></h2>
<p>Vamos a ver en esta sección diferentes tipos de mandos <em>hardware</em> que podremos integrar en nuestros videojuegos.</p>
<h3 id="tipos-de-mandos-fisicos">Tipos de mandos físicos<a class="headerlink" href="#tipos-de-mandos-fisicos" title="Permanent link">&para;</a></h3>
<h4>Controladores oficiales iOS</h4>
<p>La especificación de mandos para dispositivos iOS aparece a partir de iOS 7. En dicha versión del SDK se incorpora el <em>framework</em> <code>GameController</code> que nos permitirá añadir soporte para este tipo de mandos, que llevan la etiqueta MFI (<em>Made for iPhone/iPod/iPad</em>), la cual se refiere a todos los dispositivos <em>hardware</em> diseñados para estos dispositivos iOS. </p>
<p>https://developer.apple.com/library/ios/documentation/ServicesDiscovery/Conceptual/GameControllerPG/Introduction/Introduction.html</p>
<p><img alt="MOGA ACE Power" src="imagenes/mandos/moga-ace-power.png" />
<img alt="Logitech Powershell" src="imagenes/mandos/logitech-powershell.png" />
<img alt="Steelseries Stratus" src="imagenes/mandos/steelseries-stratus.jpg" /></p>
<h4>Controladores oficiales Android</h4>
<p>El soporte para controladores de juego en Android está presente a partir de la API 9, aunque se han ido incorporando mejoras en APIs sucesivas.</p>
<p>http://developer.android.com/training/game-controllers/index.html</p>
<p>Encontramos en Android diferentes mandos que soportan el estándar definido en esta plataforma. También tenemos mandos que nos proporcionan su SDK específico para que podamos optimizar su integración en nuestro juego, como por ejemplo los mandos de OUYA TV, Moga y Nibiru.</p>
<p><img alt="MOGA PRO Power" src="imagenes/mandos/moga-pro-power.jpg" />
<img alt="Amazon Fire TV Controller" src="imagenes/mandos/amazon-fire-controller.jpg" />
<img alt="OUYA TV Controller" src="imagenes/mandos/ouya-controller_original.jpg" />
<img alt="Nyko Playpad" src="imagenes/mandos/nyko-playpad.png" /></p>
<h4>Controladores iCade</h4>
<p>Estos controladores no utilizan la API oficial, ya que salieron a la venta antes de que ésta existiese. Se comportan como un teclado <em>bluetooth</em>, por lo que para utilizarlos simplemente deberemos conocer a qué tecla está mapeado cada botón. Está diseñado para ser utilizado con el iPad, pero puede utilizarse en cualquier dispositivo móvil que lo reconozca como teclado <em>bluetooth</em>.</p>
<p>En el <a href="http://www.raywenderlich.com/8618/adding-icade-support-to-your-game">este enlace</a> se puede encontrar documentación para integrar estos controladores en nuestras aplicaciones.</p>
<p><img alt="iCade" src="imagenes/mandos/icade.jpg" /></p>
<h3 id="controladores-fisicos-en-cocos2d-x">Controladores físicos en Cocos2d-x<a class="headerlink" href="#controladores-fisicos-en-cocos2d-x" title="Permanent link">&para;</a></h3>
<p>Cocos2d-x soporta tanto los mandos oficiales de Android como los oficiales de iOS, ofreciéndonos una API única para utilizarlos en cualquiera de estas plataformas. </p>
<p>Vamos a centrarnos en la API común de Cocos2d-x y en las cuestiones específicas para utilizarla en Android e iOS.</p>
<h4>Eventos del mando</h4>
<p>En Cocos2d-x encontramos el <em>listener</em> <code>EventListenerController</code> que nos permite incorporar soporte para mandos físicos de forma sencilla. Este <em>listener</em> nos permite recibir los siguientes eventos:</p>
<ul>
<li><code>onConnected</code>: Se ha conectado un mando.</li>
<li><code>onDisconnected</code>: Se ha desconectado un mando.</li>
<li><code>onKeyDown</code>: Se ha pulsado un botón del mando.</li>
<li><code>onKeyUp</code>: Se ha soltado un botón del mando.</li>
<li><code>onKeyRepeat</code>: Se mantiene pulsado un botón.</li>
<li><code>onAxisEvent</code>: Notifica cambios en el <em>stick</em> analógico.</li>
</ul>
<p>A continuación vemos el esqueleto de la clase de una escena de nuestro juego en la que utilizamos como entrada el mando. Al iniciar la escena registraremos el <em>listener</em> de eventos del mando y configuraremos los <em>callbacks</em> necesarios para cada uno de los eventos anteriores:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">bool</span> <span class="n">MiEscena</span><span class="o">::</span><span class="n">init</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">Layer</span><span class="o">::</span><span class="n">init</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>       

    <span class="n">configuraMandos</span><span class="p">();</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">MiEscena</span><span class="o">::</span><span class="n">configurarMando</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">_listener</span> <span class="o">=</span> <span class="n">EventListenerController</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>

    <span class="c1">// Registramos callbacks</span>
    <span class="n">_listener</span><span class="o">-&gt;</span><span class="n">onConnected</span> <span class="o">=</span> <span class="n">CC_CALLBACK_2</span><span class="p">(</span><span class="n">MiEscena</span><span class="o">::</span><span class="n">onConnectController</span><span class="p">,</span><span class="k">this</span><span class="p">);</span>
    <span class="n">_listener</span><span class="o">-&gt;</span><span class="n">onDisconnected</span> <span class="o">=</span> <span class="n">CC_CALLBACK_2</span><span class="p">(</span><span class="n">MiEscena</span><span class="o">::</span><span class="n">onDisconnectedController</span><span class="p">,</span><span class="k">this</span><span class="p">);</span>
    <span class="n">_listener</span><span class="o">-&gt;</span><span class="n">onKeyDown</span> <span class="o">=</span> <span class="n">CC_CALLBACK_3</span><span class="p">(</span><span class="n">MiEscena</span><span class="o">::</span><span class="n">onKeyDown</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">_listener</span><span class="o">-&gt;</span><span class="n">onKeyUp</span> <span class="o">=</span> <span class="n">CC_CALLBACK_3</span><span class="p">(</span><span class="n">MiEscena</span><span class="o">::</span><span class="n">onKeyUp</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">_listener</span><span class="o">-&gt;</span><span class="n">onAxisEvent</span> <span class="o">=</span> <span class="n">CC_CALLBACK_3</span><span class="p">(</span><span class="n">MiEscena</span><span class="o">::</span><span class="n">onAxisEvent</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>

    <span class="c1">// Añadimos el listener el mando al gestor de eventos</span>
    <span class="n">_eventDispatcher</span><span class="o">-&gt;</span><span class="n">addEventListenerWithSceneGraphPriority</span><span class="p">(</span><span class="n">_listener</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>

    <span class="c1">// Inicia búsqueda de controladores (necesario en iOS)</span>
    <span class="n">Controller</span><span class="o">::</span><span class="n">startDiscoveryController</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">MiEscena</span><span class="o">::</span><span class="n">onKeyDown</span><span class="p">(</span><span class="n">cocos2d</span><span class="o">::</span><span class="n">Controller</span> <span class="o">*</span><span class="n">controller</span><span class="p">,</span> <span class="kt">int</span> <span class="n">keyCode</span><span class="p">,</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">Event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>   

<span class="kt">void</span> <span class="n">MiEscena</span><span class="o">::</span><span class="n">onKeyUp</span><span class="p">(</span><span class="n">cocos2d</span><span class="o">::</span><span class="n">Controller</span> <span class="o">*</span><span class="n">controller</span><span class="p">,</span> <span class="kt">int</span> <span class="n">keyCode</span><span class="p">,</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">Event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">MiEscena</span><span class="o">::</span><span class="n">onAxisEvent</span><span class="p">(</span><span class="n">cocos2d</span><span class="o">::</span><span class="n">Controller</span><span class="o">*</span> <span class="n">controller</span><span class="p">,</span> <span class="kt">int</span> <span class="n">keyCode</span><span class="p">,</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>   

<span class="kt">void</span> <span class="n">MiEscena</span><span class="o">::</span><span class="n">onConnectController</span><span class="p">(</span><span class="n">Controller</span><span class="o">*</span> <span class="n">controller</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">MiEscena</span><span class="o">::</span><span class="n">onDisconnectedController</span><span class="p">(</span><span class="n">Controller</span><span class="o">*</span> <span class="n">controller</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</td></tr></table>

<p>A continuación veremos con más detalle estos eventos.</p>
<h4>Conexión y desconexión del mando</h4>
<p>Los mandos se conectarán de forma inalámbrica al móvil, por lo que deberemos poder conectar nuevos mandos, o desconectar los que tenemos conectados. </p>
<p>Podemos estar al tanto de los eventos de conexión y desconexión de mandos. A partir del parámetros <code>Controller</code> que nos proporcionan estos eventos podremos saber además datos sobre el mando que se ha conectado:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">MiEscena</span><span class="o">::</span><span class="n">onConnectController</span><span class="p">(</span><span class="n">Controller</span><span class="o">*</span> <span class="n">controller</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span> 
    <span class="n">CCLOG</span><span class="p">(</span><span class="s">&quot;Tag:%d&quot;</span><span class="p">,</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">getTag</span><span class="p">());</span>
    <span class="n">CCLOG</span><span class="p">(</span><span class="s">&quot;Id:%d&quot;</span><span class="p">,</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">());</span>
    <span class="n">CCLOG</span><span class="p">(</span><span class="s">&quot;Nombre:%s&quot;</span><span class="p">,</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">getDeviceName</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">MiEscena</span><span class="o">::</span><span class="n">onDisconnectedController</span><span class="p">(</span><span class="n">Controller</span><span class="o">*</span> <span class="n">controller</span><span class="p">,</span> <span class="n">Event</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span> 

<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Como vemos, una propiedad de los controladores es su etiqueta (<em>tag</em>). Podemos poner una etiqueta a los mandos para poder acceder a ellos de forma sencilla con <code>setTag</code> y consultarla con <code>getTag</code>. Esta etiqueta será un número entero. Por ejemplo, podríamos utilizar las etiquetas <code>1</code> y <code>2</code> para identificar los mandos para el primer y segundo jugador respectivamente. Podremos localizar uno de estos mandos de forma inmediata con el método estático <code>Controller::getControllerByTag</code>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Controller</span><span class="o">*</span> <span class="n">primerJugador</span> <span class="o">=</span> <span class="n">Controller</span><span class="o">::</span><span class="n">getControllerByTag</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<h4>Pulsación de teclas</h4>
<p>A partir de un objeto <code>Controller</code> podremos conocer el estado de sus botones con el método <code>getKeyStatus</code>. Este método recibe como parámetro el código del botón que queremos consultar. En la siguiente imagen mostramos los grupos de botones que encontramos en los mandos para móviles:</p>
<p><img alt="Botones de los mandos" src="imagenes/mandos/controller-num.png" /></p>
<p>Los códigos para los botones de cada grupo se encuentran en la enumeración <code>Key</code> y son:</p>
<ol>
<li>Analógico izquierdo: <code>JOYSTICK_LEFT_X</code>, <code>JOYSTICK_LEFT_Y</code>, <code>BUTTON_LEFT_THUMBSTICK</code></li>
<li>Analógico derecho: <code>JOYSTICK_RIGHT_X</code>, <code>JOYSTICK_RIGHT_Y</code>, <code>BUTTON_RIGHT_THUMBSTICK</code></li>
<li>Pad digital: <code>BUTTON_DPAD_UP</code>, <code>BUTTON_DPAD_DOWN</code>, 
<code>BUTTON_DPAD_LEFT</code>, <code>BUTTON_DPAD_RIGHT</code>, <code>BUTTON_DPAD_CENTER</code></li>
<li>Botones frontales: <code>BUTTON_A</code>, <code>BUTTON_B</code>, <code>BUTTON_C</code>, <code>BUTTON_X</code>, <code>BUTTON_Y</code>, <code>BUTTON_Z</code>, <code>BUTTON_START</code>, <code>BUTTON_SELECT</code>, <code>BUTTON_PAUSE</code></li>
<li>Gatillos: <code>AXIS_LEFT_TRIGGER</code>, <code>AXIS_RIGHT_TRIGGER</code></li>
<li>Botones superiores: <code>BUTTON_LEFT_SHOULDER</code>, 
<code>BUTTON_RIGHT_SHOULDER</code></li>
</ol>
<p>Por ejemplo, si queremos consultar el estado del botón <code>A</code> en el mando del primer jugador haremos lo siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">KeyStatus</span> <span class="n">estado</span> <span class="o">=</span> <span class="n">primerJugador</span><span class="o">-&gt;</span><span class="n">getKeyStatus</span><span class="p">(</span><span class="n">BUTTON_A</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>El estado es una estructura que nos da la siguiente información:</p>
<ul>
<li><code>isPressed</code>: Booleano que nos indica si está presionado el botón (para el caso de botones digitales).</li>
<li><code>isAnalog</code>: Nos indica si el botón es analógico (<em>sticks</em> analógicos o gatillos).</li>
<li><code>value</code>: Nos indica el valor del estado del botón como número flotante. Dependerá del tipo de botón. Por ejemplo en caso de <em>sticks</em> analógicos nos dará un valor entre <code>-1</code> y <code>1</code>. En caso de gatillos será entre <code>0</code> y <code>1</code>. En otros botones nos puede dar valores concretos como <code>0</code> ó <code>1</code>.</li>
</ul>
<p>Por ejemplo, podemos hacer que al pulsar el botón <code>A</code> nuestro personaje dispare y que con el <em>stick</em> izquierdo se mueva horizontalmente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">KeyStatus</span> <span class="n">estadoA</span> <span class="o">=</span> <span class="n">primerJugador</span><span class="o">-&gt;</span><span class="n">getKeyStatus</span><span class="p">(</span><span class="n">BUTTON_A</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">estado</span><span class="p">.</span><span class="n">isPressed</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">player</span><span class="o">-&gt;</span><span class="n">dispara</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">KeyStatus</span> <span class="n">estadoHorizontal</span> <span class="o">=</span> <span class="n">primerJugador</span><span class="o">-&gt;</span><span class="n">getKeyStatus</span><span class="p">(</span><span class="n">JOYSTICK_LEFT_X</span><span class="p">);</span>
<span class="n">player</span><span class="o">-&gt;</span><span class="n">setVelocity</span><span class="p">(</span><span class="n">estadoHorizontal</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<h4>Configuración de mandos para Android</h4>
<p>Cocos2d-x en Android soporta los mandos estándar para videojuegos, y también contiene optimizaciones para tipos concretos de mando como son los de tipo Ouya TV, Moga y Nibiru. Deberemos hacer algunos cambios en el proyecto Android para soportar cualquier tipo de mando <em>hardware</em>.</p>
<p>En primer lugar, deberemos añadir al proyecto de Android Studio las librerías de apoyo para la gestión de mandos de videojuegos. Para ello, cambiaremos en el fichero <code>settings.gradle</code> la referencia al módulo <code>libcocos2dx</code> por <code>libcocos2dx-with-controller</code>, que incluye las librerías y clases de apoyo necesarias:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">include</span> <span class="s1">&#39;</span><span class="s">:libcocos2dx</span><span class="s1">&#39;</span>
<span class="nv">project</span><span class="ss">(</span><span class="s1">&#39;</span><span class="s">:libcocos2dx</span><span class="s1">&#39;</span><span class="ss">)</span>.<span class="nv">projectDir</span> <span class="o">=</span> <span class="nv">new</span> <span class="nv">File</span><span class="ss">(</span><span class="nv">settingsDir</span>, <span class="s1">&#39;</span><span class="s">../cocos2d/cocos/platform/android/libcocos2dx-with-controller</span><span class="s1">&#39;</span><span class="ss">)</span>
</pre></div>
</td></tr></table>

<p>Una vez añadida la librería, añadiremos los siguientes cambios a la actividad <code>AppActivity</code>:</p>
<ul>
<li>Haremos que la actividad herede de <code>GameControllerActivity</code>.</li>
<li>En caso de querer utilizar internamente los SDK específicos para determinados tipos de mandos y optimizar la adaptación a ellos, deberemos especificarlo de forma explícita en <code>onCreate</code>:</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">this</span><span class="o">.</span><span class="na">connectController</span><span class="o">(</span><span class="n">DRIVERTYPE_NIBIRU</span><span class="o">);</span>
<span class="k">this</span><span class="o">.</span><span class="na">connectController</span><span class="o">(</span><span class="n">DRIVERTYPE_MOGA</span><span class="o">);</span>
<span class="k">this</span><span class="o">.</span><span class="na">connectController</span><span class="o">(</span><span class="n">DRIVERTYPE_OUYA</span><span class="o">);</span>
</pre></div>
</td></tr></table>

<p>Por ejemplo, para dar soporte específico a controladores de tipo OUYA tendríamos:</p>
<p><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppActivity</span> <span class="kd">extends</span> <span class="n">GameControllerActivity</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">connectController</span><span class="o">(</span><span class="n">DRIVERTYPE_OUYA</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>
También será necesario que en nuestro dispositivo Android descarguemos los <em>drivers</em> para el controlador que vayamos a utilizar y lo conectemos al dispositivo.</p>
<h4>Configuración de mandos para iOS</h4>
<p>En el caso de iOS, para que nuestro proyecto soporte los mandos oficiales aparecidos a partir de iOS 7, tendremos que añadir el <em>framework</em> <code>GameController.Framework</code> a nuestro proyecto.</p>
<p>Además, será importante que en nuestro proyecto llamemos a <code>Controller::startDiscoveryController()</code> para que inicie la búsqueda de mandos y establezca una conexión con ellos, tal como hemos indicado anteriormente.</p>
<h3 id="controles-fisicos-en-ios-nativo">Controles físicos en iOS nativo<a class="headerlink" href="#controles-fisicos-en-ios-nativo" title="Permanent link">&para;</a></h3>
<p>En iOS nativo podemos incorporar mandos físicos utilizando el <em>framework</em> <code>GameController</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">import</span> <span class="nc">GameController</span>
</pre></div>
</td></tr></table>

<h4>Conexión de los mandos</h4>
<p>Desde la aplicación podemos iniciar el descubrimiento de mandos, para así <strong>conectar nuevos</strong> dispositivos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="bp">GCController</span><span class="p">.</span><span class="n">startWirelessControllerDiscovery</span> <span class="p">{</span>
    <span class="c1">// Proceso de descubrimiento completado</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Sin embargo, lo más habitual será que el usuario tenga ya los mandos conectados al móvil, por lo que podemos directamente consultar la lista de mandos conectados, sin tener que descubrir mandos nuevos. Podemos <strong>consultar la lista de mandos conectados</strong> con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="bp">GCController</span><span class="p">.</span><span class="n">controllers</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>Esto deberemos hacerlo una vez inicializada la aplicación. Por ejemplo, un lugar donde se podría hacer es en <code>viewDidAppear</code>, si lo hacemos antes es posible que no encontremos ningún mando en la lista. </p>
<p>A cada mando le daremos un índice (jugador 1, jugador 2, etc). Algunos mandos tienen un LED que indican a que jugador corresponde, con esto activaríamos dicho LED. Por ejemplo, podemos obtener el primer mando de la lista y asignarlo como mando del primer jugador:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kc">self</span><span class="p">.</span><span class="n">gameController</span> <span class="p">=</span> <span class="bp">GCController</span><span class="p">.</span><span class="n">controllers</span><span class="p">().</span><span class="bp">first</span>
<span class="kc">self</span><span class="p">.</span><span class="n">gameController</span><span class="p">?.</span><span class="n">playerIndex</span> <span class="p">=</span> <span class="p">.</span><span class="n">index1</span>
</pre></div>
</td></tr></table>

<h4>Perfiles de mandos</h4>
<p>En iOS encontrados dos tipos (perfiles) de mandos distintos que podemos utilizar:</p>
<ul>
<li><em>Micro Gamepad</em>: Se trata del controlador de Siri, un mando reducido con un panel direccional táctil y dos botones.</li>
<li><em>Extended Gamepad</em>: Mando de tipo <em>videoconsola</em>. Encontramos mandos específicos para móvil (dispositivos MFi - <em>Made For iOS</em>), o podremos conectar también mandos _bluetooth de videoconsolas actuales (PS4 y Xbox One).</li>
</ul>
<p>Según el tipo de mando que queramos utilizar, obtendremos un perfil u otro. Cada perfil tendrá una serie de botones (representados por la clase <code>CGControllerButtonInput</code>) y controles direccionales (representados por <code>CGControllerDirectionPad</code>)</p>
<p>En caso del <em>Micro Gamepad</em>, obtendremos el perfil con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">profile</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">gameController</span><span class="p">?.</span><span class="n">microGamepad</span>
</pre></div>
</td></tr></table>

<p>Dicho perfil contiene:</p>
<table>
<thead>
<tr>
<th>Elemento</th>
<th>Clase</th>
</tr>
</thead>
<tbody>
<tr>
<td>Un pad direccional analógico (touchpad)</td>
<td><code>CGControllerDirectionPad</code></td>
</tr>
<tr>
<td>Dos botones (A, X)</td>
<td><code>CGControllerButtonInput</code></td>
</tr>
</tbody>
</table>
<p>En el caso de los <em>Extended Gamepads</em>, obtendremos el perfil con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">profile</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">gameController</span><span class="p">?.</span><span class="n">extendedGamepad</span>
</pre></div>
</td></tr></table>

<p>Dentro de dicho perfil encontraremos:</p>
<table>
<thead>
<tr>
<th>Elemento</th>
<th>Clase</th>
</tr>
</thead>
<tbody>
<tr>
<td>Un pad direccional digital</td>
<td><code>CGControllerDirectionPad</code></td>
</tr>
<tr>
<td>Dos sticks analógicos (<em>thumbsticks</em>)</td>
<td><code>CGControllerDirectionPad</code></td>
</tr>
<tr>
<td>Dos gatillos analógicos (<em>triggers</em>)</td>
<td><code>CGControllerButtonInput</code></td>
</tr>
<tr>
<td>Dos botones superiores digitales (<em>shoulders</em>)</td>
<td><code>CGControllerButtonInput</code></td>
</tr>
<tr>
<td>Cuatro botones digitales frontales</td>
<td><code>CGControllerButtonInput</code></td>
</tr>
</tbody>
</table>
<h4>Lectura de los controles</h4>
<p>En el caso de los botones, podemos leer su valor (<code>value</code>) como un <code>Float</code> de <code>0</code> a <code>1</code>. Esto es útil para los <em>triggers</em> analógicos, que pueden tener diferente grado de pulsación:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">gameController</span><span class="p">?.</span><span class="n">extendedGamepad</span><span class="p">?.</span><span class="n">buttonA</span><span class="p">.</span><span class="n">value</span>
</pre></div>
</td></tr></table>

<p>Aunque lo más habitual será tener botones digitales y necesitar únicamente saber si está pulsado o no, lo cual podemos conocer con la propiedad <code>isPressed</code> de tipo <code>Bool</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">gameController</span><span class="p">?.</span><span class="n">extendedGamepad</span><span class="p">?.</span><span class="n">buttonA</span><span class="p">.</span><span class="n">isPressed</span>
</pre></div>
</td></tr></table>

<p>También nos puede interesar saber cuándo el botón cambia de estado de pulsación, por ejemplo para saber el momento en el que hemos pulsado el botón. Esto podemos hacerlo con un <em>handler</em> como el siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kc">self</span><span class="p">.</span><span class="n">gameController</span><span class="p">?.</span><span class="n">extendedGamepad</span><span class="p">?.</span><span class="n">buttonA</span><span class="p">.</span><span class="n">valueChangedHandler</span> <span class="p">=</span> <span class="p">{(</span><span class="n">button</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">pressed</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pressed</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">actionButton</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En el caso de los controles direccionales, podemos leer sus propiedades <code>xAxis</code> y <code>yAxis</code> para conocer el estado del eje horizontal y vertical respectivamente. Estos ejes tomarán valores entre <code>-1</code> y <code>1</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">if</span> <span class="kd">let</span> <span class="nv">profile</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">gameController</span><span class="p">?.</span><span class="n">extendedGamepad</span> <span class="p">{</span>
    <span class="n">vel</span> <span class="p">=</span> <span class="n">profile</span><span class="p">.</span><span class="n">leftThumbstick</span><span class="p">.</span><span class="n">xAxis</span><span class="p">.</span><span class="n">value</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Para el caso de control direccional digital, tendremos también las propiedades <code>left</code>, <code>right</code>, <code>up</code> y <code>down</code> que se comportarán como botones, y nos permitirán saber si dichas direcciones están pulsadas o no.</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="box2d.html" title="Box2D" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Anterior
                </span>
                Box2D
              </span>
            </div>
          </a>
        
        
          <a href="adaptacion_a_moviles.html" title="Adaptación a diferentes dispositivos" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Siguiente
                </span>
                Adaptación a diferentes dispositivos
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="assets/javascripts/application.245445c6.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>