{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Presentaci\u00f3n \u00b6 Los dispositivos actuales cuentan con una elevada potencia gr\u00e1fica, comparable a la que podemos encontrar en algunas videoconsolas actuales. Esto hace que estos dispositivos sean capaces de reproducir videojuegos, y de hecho, este tipo de aplicaciones es uno de los que m\u00e1s \u00e9xito han cosechado en los mercados de aplicaciones para m\u00f3viles desde sus comienzos. En la asignatura Videojuegos para Dispositivos M\u00f3viles del M\u00e1ster Universitario en Desarrollo de Software para Dispositivos M\u00f3viles de la Universidad de Alicante veremos c\u00f3mo dise\u00f1ar e implementar videojuegos orientados a estas plataformas. Compatibilidad \u00b6 El c\u00f3digo fuente proporcionado en este libro ha sido probado con la libreria Cocos2d-x versi\u00f3n 4.0 y Xcode 11 . Copyright \u00b6 Copyright 2019-2020 Universidad de Alicante. Todos los derechos reservados. Este documento est\u00e1 protegido por copyright y se distribuye bajo licencias que restringen su uso, copia y distribuci\u00f3n. Se restringe al uso estrictamente personal y como material did\u00e1ctico del M\u00e1ster Universitario en Desarrollo de Software para Dispositivos M\u00f3viles, curso 2019-2020, de la Universidad de Alicante. La distribuci\u00f3n y copia de este documento no est\u00e1n permitidas, salvo autorizaci\u00f3n previa de la Universidad de Alicante. La documentaci\u00f3n se suministra \"tal cual\", sin ning\u00fan tipo de condiciones, declaraciones ni garant\u00edas, expresas o impl\u00edcitas, incluidas las relativas a la comercializaci\u00f3n, la adecuaci\u00f3n a fines concretos o la no infracci\u00f3n de las leyes, salvo en los casos en que dichas renuncias no fueran legalmente v\u00e1lidas.","title":"Presentaci\u00f3n"},{"location":"index.html#presentacion","text":"Los dispositivos actuales cuentan con una elevada potencia gr\u00e1fica, comparable a la que podemos encontrar en algunas videoconsolas actuales. Esto hace que estos dispositivos sean capaces de reproducir videojuegos, y de hecho, este tipo de aplicaciones es uno de los que m\u00e1s \u00e9xito han cosechado en los mercados de aplicaciones para m\u00f3viles desde sus comienzos. En la asignatura Videojuegos para Dispositivos M\u00f3viles del M\u00e1ster Universitario en Desarrollo de Software para Dispositivos M\u00f3viles de la Universidad de Alicante veremos c\u00f3mo dise\u00f1ar e implementar videojuegos orientados a estas plataformas.","title":"Presentaci\u00f3n"},{"location":"index.html#compatibilidad","text":"El c\u00f3digo fuente proporcionado en este libro ha sido probado con la libreria Cocos2d-x versi\u00f3n 4.0 y Xcode 11 .","title":"Compatibilidad"},{"location":"index.html#copyright","text":"Copyright 2019-2020 Universidad de Alicante. Todos los derechos reservados. Este documento est\u00e1 protegido por copyright y se distribuye bajo licencias que restringen su uso, copia y distribuci\u00f3n. Se restringe al uso estrictamente personal y como material did\u00e1ctico del M\u00e1ster Universitario en Desarrollo de Software para Dispositivos M\u00f3viles, curso 2019-2020, de la Universidad de Alicante. La distribuci\u00f3n y copia de este documento no est\u00e1n permitidas, salvo autorizaci\u00f3n previa de la Universidad de Alicante. La documentaci\u00f3n se suministra \"tal cual\", sin ning\u00fan tipo de condiciones, declaraciones ni garant\u00edas, expresas o impl\u00edcitas, incluidas las relativas a la comercializaci\u00f3n, la adecuaci\u00f3n a fines concretos o la no infracci\u00f3n de las leyes, salvo en los casos en que dichas renuncias no fueran legalmente v\u00e1lidas.","title":"Copyright"},{"location":"adaptacion_a_moviles.html","text":"Adaptaci\u00f3n a m\u00f3viles \u00b6 Una de las principales problem\u00e1ticas en el desarrollo de dispositivos m\u00f3viles es la gran diferencia de tama\u00f1os de pantalla existentes, con distinta resoluci\u00f3n y relaci\u00f3n de aspecto. Esto plantea diferentes problemas: Tama\u00f1o de los recursos : Con esto nos referimos a la resoluci\u00f3n que deber\u00edan tener recursos como los sprites o tilemaps . Un enfoque sencillo podr\u00eda ser proporcionar estos recursos a resoluci\u00f3n m\u00e1xima, para as\u00ed aprovechar las pantallas de mayor resoluci\u00f3n. El problema es que los dispositivos con menor resoluci\u00f3n disponen tambi\u00e9n de una menor memoria de v\u00eddeo, por lo que es probable que no puedan albergar las texturas necesarias en resoluci\u00f3n m\u00e1xima. Por este motivo ser\u00e1 conveniente proporcionar diferentes versiones de los recursos para diferentes resoluciones de pantalla. Sistema de coordenadas : Debemos evitar utilizar un sistema de coordenadas en pixels, ya que el tama\u00f1o de la pantalla cambiar\u00e1 en cada dispositivo. Lo que se har\u00e1 es utilizar siempre un sistema de coordenadas del mismo tama\u00f1o independientemente de la resoluci\u00f3n del dispositivo en el que se vaya a ejecutar el juego. Hablaremos en este caso de un sistema de coordenadas en puntos (en lugar de pixels). El tama\u00f1o de cada punto depender\u00e1 de la resoluci\u00f3n real de la pantalla del dispositivo utilizado. Relaci\u00f3n de aspecto : A pesar de trabajar en puntos para que las dimensiones del sistema de coordenadas utilizado sean siempre las mismas, tenemos el problema de que la relaci\u00f3n de aspecto puede ser distinta. Para resolver esto podemos a\u00f1adir un borde cuando la relaci\u00f3n de aspecto del dispositivo no coincide con la que se ha utilizado en el dise\u00f1o, estirar la pantalla a pesar de deformar la imagen, o bien recortarla en alguna de sus dimensiones. Esta \u00faltima opci\u00f3n ser\u00e1 la m\u00e1s adecuada, pero deberemos llevar cuidado de hacerlo de forma correcta y dise\u00f1ar el juego de forma que sobre suficiente espacio como para que se pueda aplicar el recorte sin problemas. Vamos a ver a continuaci\u00f3n c\u00f3mo implementar todo lo anterior en Cocos2d-x. Resoluciones de recursos, dise\u00f1o y pantalla \u00b6 Para resolver el problema de los distintos tama\u00f1os de pantalla en Cocos2d-x lo que haremos ser\u00e1 definir tres resoluciones distintas: Resoluci\u00f3n de recursos : Resoluci\u00f3n para la que est\u00e1n preparados los recursos utilizados. Resoluci\u00f3n de dise\u00f1o : Resoluci\u00f3n para la que hemos dise\u00f1ado el juego. Ser\u00e1 esta resoluci\u00f3n la que utilizaremos en el c\u00f3digo del juego (resoluci\u00f3n en puntos). Resoluci\u00f3n de pantalla : Resoluci\u00f3n real de la pantalla del dispositivo. En el objeto AppDelegate se inicializa el juego. Este es un buen punto para configurar las resoluciones anteriores. Por ejemplo, podemos definir esta configuraci\u00f3n de la siguiente forma: 1 2 3 4 5 6 7 8 9 10 Size screenSize = director -> getOpenGLView () -> getFrameSize (); Size designSize ( 480 , 320 ); Size resourceSize ( 960 , 640 ); // Establecemos la resoluci\u00f3n de recursos director -> setContentScaleFactor ( resourceSize . width / designSize . width ); // Establecemos la resoluci\u00f3n de dise\u00f1o (puntos) cocos2d :: Director :: getInstance () -> getOpenGLView () -> setDesignResolutionSize ( 320 , 480 , ResolutionPolicy :: FIXED_WIDTH ); En este ejemplo hemos especificado: Resoluci\u00f3n de recursos : 960 x 640 Resoluci\u00f3n de dise\u00f1o : 480 x 320 Las reglas que seguiremos para trabajar con estas resoluciones son: En el c\u00f3digo del juego siempre utilizaremos la resoluci\u00f3n de dise\u00f1o . Es decir, en el ejemplo anterior consideraremos que siempre tenemos una resoluci\u00f3n de 480 x 320 puntos al posicionar sprites , ubicar elementos del HUD, mostrar elementos del escenario, etc. El contenido que hayamos dibujado en el espacio de dise\u00f1o se estirar\u00e1 para ocupar toda la pantalla. La resoluci\u00f3n de recursos nos indica la resoluci\u00f3n de pantalla para la que est\u00e1n preparados los recursos en el caso ideal, es decir, en el que cada p\u00edxel de la imagen del recurso corresponde exactamente a un p\u00edxel en pantalla. En el caso de nuestro ejemplo, la resoluci\u00f3n para la que est\u00e1n preparados los recursos es el doble que la resoluci\u00f3n de dise\u00f1o. Es decir, un sprite cuya imagen tenga 80 x 80 pixels que est\u00e9 pensado para que se dibuje con su tama\u00f1o original en una pantalla de 960 x 640, en un espacio de dise\u00f1o de 480 x 320 ocupar\u00eda un espacio de 40 x 40 puntos. Decimos en este caso que su factor de escala es 2.0, ya cada punto de nuestro espacio de dise\u00f1o corresponde a 2 x 2 pixels de la imagen del recurso. Si la resoluci\u00f3n real de pantalla fuera de 480 x 320, coincidiendo con la resoluci\u00f3n de dise\u00f1o, la imagen del sprite tendr\u00e1 que escalarse a mitad de tama\u00f1o (reduciendo la definici\u00f3n de la imagen original a la mitad, ya que la definici\u00f3n del sprite es mayor de lo que nos permite mostrar la pantalla); en el caso de tener una resoluci\u00f3n de pantalla de 960 x 640 el sprite se mostrar\u00eda en su tama\u00f1o real con todos sus pixels (aunque en el c\u00f3digo lo posicionemos y obtengamos su tama\u00f1o en puntos); y si contamos con una pantalla de 1920 x 1280 el sprite tendr\u00eda que escalarse al doble de su tama\u00f1o (en este caso la resoluci\u00f3n del sprite no ser\u00eda suficiente para aprovechar toda la definici\u00f3n de la pantalla). Con esto podemos ver que aunque trabajemos con una resoluci\u00f3n de dise\u00f1o peque\u00f1a, esto no implica que el juego se vaya a ver con poca resoluci\u00f3n. \u00c9sta resoluci\u00f3n de dise\u00f1o simplemente es un sistema de coordenadas de referencia para situar los objetos en la escena. La resoluci\u00f3n que realmente determinar\u00e1 la definici\u00f3n de los gr\u00e1ficos del juego es la resoluci\u00f3n de recursos. Con el m\u00e9todo Director::setContentScaleFactor estableceremos la relaci\u00f3n existente entre la relaci\u00f3n de recursos y la de dise\u00f1o. Por ejemplo, si la resoluci\u00f3n de recursos es el doble que la de dise\u00f1o, el factor de escala ser\u00e1 2. En caso de que la relaci\u00f3n de aspecto de estas resoluciones no coincidiese, tendr\u00edamos que decidir si tomar como referencia el alto o el ancho de la imagen a la hora de calcular el factor de escala. 1 2 3 4 5 // Tomamos como referencia el ancho director -> setContentScaleFactor ( resourceSize . width / designSize . width ); // Tomamos como referencia el alto director -> setContentScaleFactor ( resourceSize . height / designSize . height ); Gesti\u00f3n de recursos \u00b6 En el apartado anterior hemos visto c\u00f3mo establecer la resoluci\u00f3n de los recursos. Sin embargo, como ya hemos comentado anteriormente, es dif\u00edcil tener una \u00fanica resoluci\u00f3n de recursos que sea adecuada para todos los dispositivos: dispositivos de alta densidad necesitan recursos con mayor resoluci\u00f3n para aprovechar la densidad de pantalla, y dispositivos con menor densidad de pantalla normalmente tienen una memoria de v\u00eddeo m\u00e1s limitada donde puede que no quepan los recursos necesarios. Por ello es conveniente suministrar diferentes versiones de los recursos. Para soportar distintas versiones de un mismo recurso lo que haremos es guardarlo en diferentes directorios pero con el mismo nombre de fichero. Por ejemplo, podemos crear un directorio sd para la versi\u00f3n normal y otro directorio hd para la versi\u00f3n para dispositivos de alta resoluci\u00f3n. Ambos directorios tendr\u00e1n los mismos ficheros de texturas, pero con distintas resoluciones. Lo que deberemos hacer es indicar al motor d\u00f3nde buscar los recursos en funci\u00f3n de la resoluci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 Size screenSize = director -> getOpenGLView () -> getFrameSize (); std :: vector < std :: string > searchPaths ; if ( screenSize . height > 320 ) { // iPhone retina searchPaths . push_back ( \"hd\" ); searchPaths . push_back ( \"comun\" ); } else { // iPhone searchPaths . push_back ( \"sd\" ); searchPaths . push_back ( \"comun\" ); } FileUtils :: getInstance () -> setSearchPaths ( searchPaths ); En el ejemplo anterior, en el caso del iPhone retina buscar\u00e1 primero los recursos en el directorio hd , y si no los encuentra ah\u00ed buscar\u00e1 en comun . En caso caso de tener menor resoluci\u00f3n buscar\u00e1 primero en sd y despu\u00e9s en comun . Una vez decidida la versi\u00f3n de los recursos que se va a utilizar, deberemos indicar al motor la resoluci\u00f3n de recursos correcta para que as\u00ed los escale de forma adecuada: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Size screenSize = director -> getOpenGLView () -> getFrameSize (); Size designSize = Size ( 480 , 320 ); Size resourceSize ; std :: vector < std :: string > searchPaths ; if ( screenSize . height > 320 ) { // iPhone retina searchPaths . push_back ( \"hd\" ); searchPaths . push_back ( \"comun\" ); resourceSize = Size ( 960 , 640 ); } else { // iPhone searchPaths . push_back ( \"sd\" ); searchPaths . push_back ( \"comun\" ); resourceSize = Size ( 480 , 320 ); } FileUtils :: getInstance () -> setSearchPaths ( searchPaths ); director -> setContentScaleFactor ( resourceSize . width / designSize . width ); director -> getOpenGLView () -> setDesignResolutionSize ( 320 , 480 , ResolutionPolicy :: FIXED_WIDTH ); Estrategias de adaptaci\u00f3n \u00b6 Con el m\u00e9todo setDesignResolutionSize establecemos la resoluci\u00f3n de dise\u00f1o a utilizar en el juego. Adem\u00e1s el tercer par\u00e1metro permite indicar la forma de adaptar la resoluci\u00f3n de dise\u00f1o a la resoluci\u00f3n de pantalla cuando la relaci\u00f3n de aspecto de ambas resoluciones no coincida. Encontramos las siguientes estrategias: ResolutionPolicy::SHOW_ALL : Hace que todo el contenido de la resoluci\u00f3n de dise\u00f1o quede dentro de la pantalla, dejando franjas negras en los laterales si la relaci\u00f3n de aspecto no es la misma. Estas franjas negras hacen que desperdiciemos espacio de pantalla y causan un efecto bastante negativo, por lo que a pesar de la sencillez de esta estrategia, no ser\u00e1 recomendable si buscamos un producto con un buen acabado. ResolutionPolicy::EXACT_FIT : Hace que el contenido dentro de la resoluci\u00f3n de dise\u00f1o se estire para adaptarse a la resoluci\u00f3n de pantalla, deformando el contenido si la relaci\u00f3n de aspecto no es la misma. Aunque en este caso se llene la pantalla, la deformaci\u00f3n de la imagen tambi\u00e9n causar\u00e1 muy mal efecto y por lo tanto debemos evitar utilizar esta t\u00e9cnica . ResolutionPolicy::NO_BORDER : Ajusta el contenido de la resoluci\u00f3n de dise\u00f1o a la resoluci\u00f3n de pantalla, sin dejar borde y sin deformar el contenido, pero dejando parte de \u00e9ste fuera de la pantalla si la relaci\u00f3n de aspecto no coincide. En este caso no habr\u00e1 problema si implementamos el juego de forma correcta, ayud\u00e1ndonos de los m\u00e9todos Director::getInstance()->getVisibleSize() y Director::getInstance()->getVisibleOrigin() que nos dar\u00e1n el tama\u00f1o y el origen, respectivamente, de la zona visible de nuestra resoluci\u00f3n de dise\u00f1o. De esta forma deberemos asegurarnos de dibujar todos los componentes del HUD dentro de esta zona, y a la hora de implementar scroll lo alinearemos de forma correcta con el origen de la zona visible. ResolutionPolicy::FIXED_HEIGHT , ResolutionPolicy::FIXED_WIDTH modifican la resoluci\u00f3n de dise\u00f1o para que tenga la misma relaci\u00f3n de aspecto que la resoluci\u00f3n de pantalla, manteniendo fija la altura o la anchura de dise\u00f1o respectivamente. Podremos consultar la resoluci\u00f3n de dise\u00f1o con Director::getInstance()->getWinSize() . En estos casos toda la resoluci\u00f3n de dise\u00f1o es visible en pantalla, pero \u00e9sta puede variar en altura o en anchura, seg\u00fan la estrategia indicada. \u00bfQu\u00e9 estrategia debemos utilizar? Depender\u00e1 de lo que busquemos en nuestro juego, pero normalmente nos quedaremos con NO_BORDER , FIXED_HEIGHT o FIXED_WIDTH . Estrategia NO_BORDER \u00b6 Se trata de una estrategia adecuada por ejemplo para juegos de rol con vista cenital y scroll en cualquier direcci\u00f3n. El personaje estar\u00e1 centrado en pantalla y se podr\u00e1 mover en cualquier direcci\u00f3n, as\u00ed que nos da igual la parte que quede cortada siempre que en el caso de haber HUD nos aseguremos de dibujarlo dentro de la zona visible. Para conseguir dibujar el HUD de forma adecuada con esta estrategia es importante tener en cuenta las propiedades visibleOrigin y visibleSize , que nos indicar\u00e1n la zona de nuestra espacio de dise\u00f1o que va a ser visible realmente en pantalla. Estrategias FIXED_WIDTH y FIXED_HEIGHT \u00b6 Estas dos estrategias, a diferencia de todas las dem\u00e1s, tienen la particularidad de modificar la resoluci\u00f3n de dise\u00f1o, manteniendo inalterado siempre al menos el ancho ( FIXED_WIDTH ) o el alto ( FIXED_HEIGHT ). Podemos consultar la resoluci\u00f3n de dise\u00f1o que ha resultado tras la modificaci\u00f3n con la propiedad winSize . Si tenemos por ejemplo un plataformas de avance horizontal, normalmente querremos que la altura sea fija, por lo que FIXED_HEIGHT podr\u00eda ser la opci\u00f3n m\u00e1s adecuada. Si por el contrario es un juego que avanza verticalmente (por ejemplo juegos de naves), ser\u00e1 m\u00e1s adecuado FIXED_WIDTH . Posicionamiento de los elementos de la GUI \u00b6 Hemos visto diferentes estrategias para adaptar el videojuego al tama\u00f1o de la pantalla del m\u00f3vil, intentando preservar en la medida de lo posible la resoluci\u00f3n de dise\u00f1o. Esto es relativamente sencillo para juegos que cuentan con escenarios con scroll lateral, vertical, o ambos. Sin embargo, un elemento con el que deberemos llevar especial cuidado son los componentes de la GUI, como es el caso del HUD (marcador de puntuaci\u00f3n, vidas restantes, energ\u00eda, etc) y los men\u00fas del juego. Componentes de la GUI de cocos2d-x \u00b6 En cocos2d-x encontramos una API bastante completa de elementos para la GUI, a la que tendremos acceso importando el fichero ui/CocosGUI.h y que est\u00e1 contenida bajo el espacio de nombres ui . En ella encontramos elementos como botones, listas, etiquetas de texto, paneles de scroll , im\u00e1genes o sliders , y podremos utilizarlos de la misma forma que el resto de nodos, aunque en estos casos normalmente contaremos con la posibilidad de programar eventos para las acciones que pueda realizar cada uno de estos widgets , como por ejemplo el evento de click de un bot\u00f3n. 1 2 3 4 5 6 7 8 9 10 11 ui :: Button * button = ui :: Button :: create (); button -> loadTextures ( \"boton_normal.png\" , \"boton_pressed.png\" ); button -> setTitleText ( \"Pause\" ); button -> setTitleFontName ( \"Marker Felt\" ); addChild ( button ); button -> addTouchEventListener ([ & ]( Ref * sender , ui :: Widget :: TouchEventType type ) { if ( type == ui :: Widget :: TouchEventType :: ENDED ) { pausar (); } }); Im\u00e1genes nine-patch \u00b6 Algunos elementos de la GUI de cocos2d-x, como los botones, soportan trabajar con im\u00e1genes nine-patch , con lo cual podemos hacer botones independientes del tama\u00f1o de su contenido. Para activar el modo nine_patch , deberemos proporcionar los l\u00edmites de la regi\u00f3n central (estirable) de la imagen mediante el m\u00e9todo setCapInsets . Tras esto activaremos el modo nine-patch con setScale9Enabled . Ahora podremos cambiar el tama\u00f1o del contenido del widget setContentSize sin que se deformen las esquinas de la imagen. 1 2 3 button -> setCapInsets ( Rect ( 8 , 8 , 26 , 26 )); button -> setContentSize ( button -> getTitleRenderer () -> getContentSize () + Size ( 16 , 16 )); button -> setScale9Enabled ( true ); Alineaci\u00f3n con los bordes de la pantalla \u00b6 Muchos elementos del HUD deber\u00e1n estar alineados con las esquinas de la pantalla. Por ejemplo, nos puede interesar tener un bot\u00f3n de pausa en la esquina superior izquierda, y nuestra puntuaci\u00f3n en la esquina superior derecha. Para alinear estos elementos de forma correcta, lo m\u00e1s adecuado ser\u00e1 ajustar convenientemente la propiedad anchorPoint del nodo, que contendr\u00e1 unas coordenadas relativas (de 0 a 1) al tama\u00f1o del nodo, indicando qu\u00e9 punto del nodo coincidir\u00e1 con la posici\u00f3n donde lo ubiquemos en pantalla ( position ). En el eje de las x , el valor 0 hace referencia al lado izquierda, 0.5 al centro, y 1 al lado derecho. En el eje de las y , el valor 0 representa la parte inferior del nodo, 0.5 la mitad, y 1 la parte superior. Por ejemplo, para un elemento que vaya a estar en la esquina superior izquierda, un valor correcto para el anchorPoint ser\u00eda (0,1) , para que as\u00ed cuando lo ubiquemos en dicha posici\u00f3n sea su esquina superior izquierda la que coincida con la esquina de la pantalla. 1 2 3 4 5 Size visibleSize = Director :: getInstance () -> getVisibleSize (); Vec2 origin = Director :: getInstance () -> getVisibleOrigin (); button -> setAnchorPoint ( Vec2 ( 0.0 , 1.0 )); button -> setPosition ( Point ( origin . x + 5 , origin . y + visibleSize . height - 5 )); Por otro lado, si queremos que el elemento quede alineado en la esquina superior derecha, ser\u00e1 mejor especificar como anchorPoint el valor (1,1) , para que as\u00ed al ubicarlo en dicha posici\u00f3n sea su esquina superior derecha. Aunque el nodo cambie de tama\u00f1o, su esquina superior derecha siempre se mantendr\u00e1 en el mismo punto en pantalla. Para los elementos con texto variable, como por ejemplo la puntuaci\u00f3n, cuando los ajustemos a la derecha ser\u00e1 conveniente que reservemos espacio suficiente para todos los valores que queramos que pueda tomar, para que as\u00ed al ir aumentando el n\u00famero de d\u00edgitos de la puntuaci\u00f3n no se vaya desplazando el texto. En este caso puede ser recomendable utilizar una fuente monoespaciada y rellenar con ceros el n\u00famero m\u00e1ximo de d\u00edgitos que queramos que pueda tener. Por ejemplo, SCORE: 00010 . Men\u00fas \u00b6 A parte del HUD, los men\u00fas del juego son otro elemento con el que deberemos llevar especial cuidado. En este caso lo normal ser\u00e1 tener centrados los items del men\u00fa en pantalla, habitualmente con una disposici\u00f3n vertical. Los botones del men\u00fa (y todos los botones de la interfaz en general) deber\u00e1n tener un tama\u00f1o suficiente para abarcar la yema del dedo en cualquier dispositivo. Esto nos llevar\u00e1 a tener en el m\u00f3vil botones que ocupar\u00e1n gran parte de la pantalla. Si trasladamos la aplicaci\u00f3n a un tablet , la estrategia de cocos2d-x ser\u00e1 la de escalar la pantalla, lo cual puede producir que los men\u00fas se vean innecesariamente grandes. Podemos plantearnos la posibilidad de implementar men\u00fas alternativos para tel\u00e9fonos y tablets , que aprovechen en cada caso la pantalla de forma adecuada, o limitar el tama\u00f1o de los elementos del men\u00fa cuando el tama\u00f1o f\u00edsico de la pantalla sea mayor al de un m\u00f3vil, para as\u00ed evitar ocupar m\u00e1s espacio de pantalla que el necesario para poderlos pulsar f\u00e1cilmente. Depuraci\u00f3n del cambio de densidad de pantalla \u00b6 Para comprobar que nuestra aplicaci\u00f3n se adapta de forma correcta podemos utilizar diferentes tama\u00f1os de ventana durante el desarrollo. Sin embargo, tambi\u00e9n ser\u00e1 necesario comprobar lo que ocurre al tener diferentes densidades de pantalla, teniendo algunos dispositivos resoluciones superiores a la de nuestra m\u00e1quina de desarrollo. Para resolver este problema podemos utilizar la funci\u00f3n GLView::setFrameZoomFactor . Con esta funci\u00f3n podemos aplicar un factor de zoom al contenido de la ventana. De esta forma podemos tener altas resoluciones, como los 2048x1536 pixeles de un iPad retina, dentro del espacio de nuestra pantalla. Esta funci\u00f3n deber\u00e1 invocarse \u00fanicamente en el c\u00f3digo espec\u00edfico de la plataforma de desarrollo (Windows, Linux o Mac). Por ejemplo, en el caso de Mac a\u00f1adiremos las siguientes l\u00edneas al fichero AppDelegate.cpp : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 bool AppDelegate :: applicationDidFinishLaunching () { // initialize director auto director = Director :: getInstance (); auto glview = director -> getOpenGLView (); if ( ! glview ) { glview = GLViewImpl :: create ( \"Mi Juego\" ); director -> setOpenGLView ( glview ); } // Depuracion multi-resolucion GLView * eglView = Director :: getInstance () -> getOpenGLView (); eglView -> setFrameSize ( 1536 , 2048 ); eglView -> setFrameZoomFactor ( 0.4f ); // Soporte multi-resolucion cocos2d :: Director :: getInstance () -> getOpenGLView () -> setDesignResolutionSize ( 768 , 1024 , ResolutionPolicy :: FIXED_WIDTH ); // turn on display FPS director -> setDisplayStats ( true ); // set FPS. the default value is 1.0/60 if you don't call this director -> setAnimationInterval ( 1.0 / 60 ); // create a scene. it's an autorelease object auto scene = TitleScene :: createScene (); // run director -> runWithScene ( scene ); return true ; } Compilaci\u00f3n condicional \u00b6 En muchos casos tendremos que poner c\u00f3digo que s\u00f3lo queremos que se incluya para una plataforma determinada. Podemos hacer que se determine en tiempo de compilaci\u00f3n si se debe incluir dicho c\u00f3digo o no. Para ello podemos incluir bloques condicionales que hagan que s\u00f3lo se incluya el c\u00f3digo al compilar si compilamos para la plataforma indicada. 1 2 3 #if (CC_TARGET_PLATFORM == <plataforma>) ... // C\u00f3digo condicional #endif Por ejemplo, en el caso anterior en el que busc\u00e1bamos emular diferentes resoluciones de m\u00f3vil en la plataforma Mac para as\u00ed depurar la adaptaci\u00f3n al tama\u00f1o de pantalla, podemos hacer que este c\u00f3digo para la depuraci\u00f3n s\u00f3lo se incluya para la plataforma Mac: 1 2 3 4 5 6 #if (CC_TARGET_PLATFORM == CC_PLATFORM_MAC) // Depuracion multi-resolucion GLView * eglView = Director :: getInstance () -> getOpenGLView (); eglView -> setFrameSize ( 320 , 480 ); eglView -> setFrameZoomFactor ( 1.0f ); #endif Podemos introducir c\u00f3digo condicional para las diferentes plataformas soportadas: CC_PLATFORM_IOS CC_PLATFORM_ANDROID CC_PLATFORM_WP8 CC_PLATFORM_BLACKBERRY CC_PLATFORM_WIN32 CC_PLATFORM_LINUX CC_PLATFORM_MAC Esto nos permitir\u00e1 por ejemplo incluir servicios que s\u00f3lo estar\u00e1n disponibles en una determinada plataforma, como es el caso de Game Center en iOS. Optimizaci\u00f3n de texturas \u00b6 Aunque utilicemos un motor o librer\u00eda de alto nivel para implementar nuestro videojuego, como puede ser Unity o Cocos2d-x, por debajo estas librer\u00edas siempre estar\u00e1n utilizando OpenGL. Concretamente, en los dispositivos m\u00f3viles utilizar\u00e1n OpenGL ES, una versi\u00f3n reducida de OpenGL pensada para este tipo de dispositivos. Seg\u00fan las caracter\u00edsticas del dispositivo se utilizar\u00e1 OpenGL ES 1.0 o OpenGL ES 2.0. Las primeras generaciones de iPhone soportaban \u00fanicamente OpenGL ES 1.0, mientras que actualmente se pueden utilizar ambas versiones de la librer\u00eda. Actualmente podemos encontrar OpenGL ES 2.0 en pr\u00e1cticamente la totalidad de dispositivos Android e iOS disponibles. Por este motivo ser\u00e1 importante tener algunas nociones sobre c\u00f3mo gestiona los gr\u00e1ficos OpenGL. Los gr\u00e1ficos a mostrar en pantalla se almacenan en memoria de v\u00eddeo como texturas. La memoria de v\u00eddeo es un recurso cr\u00edtico (se suele compartir con la RAM del dispositivo), por lo que deberemos optimizar las texturas para ocupar la m\u00ednima cantidad de memoria posible. Para aprovechar al m\u00e1ximo la memoria, se recomienda que las texturas tengan de tama\u00f1o una potencia de 2 (por ejemplo 128x128, 256x256, 512x512, 1024x1024, o 2048x2048), ya que son las dimensiones con las que trabaja la memoria de v\u00eddeo. En OpenGL ES 1.0 el tama\u00f1o m\u00e1ximo de las texturas es de 1024x1024, mientras que en OpenGL ES 2.0 este tama\u00f1o se ampl\u00eda hasta 2048x2048, Existen diferentes formatos de textura: RGB8888 : 32 bits por pixel. Contiene un canal alpha de 8 bits, con el que podemos dar a cada pixel 256 posibles niveles de transparencia. Permite representar m\u00e1s de 16 millones de colores (8 bits para cada canal RGB). RGB4444 : 16 bits por pixel. Contiene un canal alpha de 4 bits, con el que podemos dar a cada pixel 16 posibles niveles de transparencia. Permite representar 4.096 colores (4 bits para cada canal RGB). Esto permite representar colores planos, pero no ser\u00e1 capaz de representar correctamente los degradados. RGB565 : 16 bits por pixel. No permite transparencia. Permite representar 65.536 colores, con 6 bits para el canal verde (G), y 5 bits para los canales rojo (R) y azul (B). Este tipo de textura ser\u00e1 la m\u00e1s adecuada para fondos. RGB5551 : 16 bits por pixel. Permite transparencia de un s\u00f3lo bit, es decir, que un pixel puede ser transparente u opaco, pero no permite niveles intermedios. Permite representar 32.768 colores (5 bits para cada canal RGB). Debemos evitar en la medida de lo posible utilizar el tipo RGB8888 , debido no s\u00f3lo al espacio que ocupa en memoria y en disco (aumentar\u00e1 significativamente el tama\u00f1o del paquete), sino tambi\u00e9n a que el rendimiento del videojuego disminuir\u00e1 al utilizar este tipo de texturas. Escogeremos un tipo u otro seg\u00fan nuestras necesidades. Por ejemplo, si nuestros gr\u00e1ficos utilizan colores planos, RGB4444 puede ser una buena opci\u00f3n. Para fondos en los que no necesitemos transparencia la opci\u00f3n m\u00e1s adecuada ser\u00eda RGB565 . Si nuestros gr\u00e1ficos tienen un borde s\u00f3lido y no necesitamos transparencia parcial, pero si total, podemos utilizar RGB5551 . En caso de necesitar utilizar RGB4444 con texturas en las que tenemos degradado, podemos aplicar a la textura el efecto dithering para que el degradado se represente de una forma m\u00e1s adecuada utilizando un reducido n\u00famero de colores. Esto se consigue mezclando p\u00edxeles de distintos colores y modificando la proporci\u00f3n de cada color conforme avanza el degradado, evitando as\u00ed el efecto de degradado escalonado que obtendr\u00edamos al representar las texturas con un menor n\u00famero de colores. Tambi\u00e9n tenemos la posibilidad de utilizar formatos de textura comprimidos para aprovechar al m\u00e1ximo el espacio y obtener un mayor rendimiento. En iPhone el formato de textura soportado es PVRTC. Existen variantes de 2 y 4 bits de este formato. Se trata de un formato de compresi\u00f3n con p\u00e9rdidas. En Android los dispositivos con OpenGL ES 1.0 no ten\u00edan ning\u00fan formato est\u00e1ndar de compresi\u00f3n. Seg\u00fan el dispositivo pod\u00edamos encontrar distintos formatos: ATITC, PVRTC, DXT. Sin embargo, todos los dispositivos con soporte para OpenGL ES 2.0 soportan el formato ETC1. Podemos convertir nuestras texturas a este formato con la herramienta $ANDROID_SDK_HOME/tools/etc1tool , incluida con el SDK de Android. Un inconveniente de este formato es que no soporta canal alpha . Adem\u00e1s de seleccionar el formato adecuado para la textura, deberemos aprovechar al m\u00e1ximo el espacio disponible dentro de ella (dentro de una textura podemos incluir im\u00e1genes de diferentes sprites y fotogramas de los mismos). Herramientas especializadas como Texture Packer nos permitir\u00e1n al mismo tiempo empaquetar nuestros sprites de forma \u00f3ptima en una textura, y especificar el formato de textura a utilizar. En motores como Unity encontramos herramientas integradas que nos permiten realizar esta tarea.","title":"Adaptaci\u00f3n a diferentes dispositivos"},{"location":"adaptacion_a_moviles.html#adaptacion-a-moviles","text":"Una de las principales problem\u00e1ticas en el desarrollo de dispositivos m\u00f3viles es la gran diferencia de tama\u00f1os de pantalla existentes, con distinta resoluci\u00f3n y relaci\u00f3n de aspecto. Esto plantea diferentes problemas: Tama\u00f1o de los recursos : Con esto nos referimos a la resoluci\u00f3n que deber\u00edan tener recursos como los sprites o tilemaps . Un enfoque sencillo podr\u00eda ser proporcionar estos recursos a resoluci\u00f3n m\u00e1xima, para as\u00ed aprovechar las pantallas de mayor resoluci\u00f3n. El problema es que los dispositivos con menor resoluci\u00f3n disponen tambi\u00e9n de una menor memoria de v\u00eddeo, por lo que es probable que no puedan albergar las texturas necesarias en resoluci\u00f3n m\u00e1xima. Por este motivo ser\u00e1 conveniente proporcionar diferentes versiones de los recursos para diferentes resoluciones de pantalla. Sistema de coordenadas : Debemos evitar utilizar un sistema de coordenadas en pixels, ya que el tama\u00f1o de la pantalla cambiar\u00e1 en cada dispositivo. Lo que se har\u00e1 es utilizar siempre un sistema de coordenadas del mismo tama\u00f1o independientemente de la resoluci\u00f3n del dispositivo en el que se vaya a ejecutar el juego. Hablaremos en este caso de un sistema de coordenadas en puntos (en lugar de pixels). El tama\u00f1o de cada punto depender\u00e1 de la resoluci\u00f3n real de la pantalla del dispositivo utilizado. Relaci\u00f3n de aspecto : A pesar de trabajar en puntos para que las dimensiones del sistema de coordenadas utilizado sean siempre las mismas, tenemos el problema de que la relaci\u00f3n de aspecto puede ser distinta. Para resolver esto podemos a\u00f1adir un borde cuando la relaci\u00f3n de aspecto del dispositivo no coincide con la que se ha utilizado en el dise\u00f1o, estirar la pantalla a pesar de deformar la imagen, o bien recortarla en alguna de sus dimensiones. Esta \u00faltima opci\u00f3n ser\u00e1 la m\u00e1s adecuada, pero deberemos llevar cuidado de hacerlo de forma correcta y dise\u00f1ar el juego de forma que sobre suficiente espacio como para que se pueda aplicar el recorte sin problemas. Vamos a ver a continuaci\u00f3n c\u00f3mo implementar todo lo anterior en Cocos2d-x.","title":"Adaptaci\u00f3n a m\u00f3viles"},{"location":"adaptacion_a_moviles.html#resoluciones-de-recursos-diseno-y-pantalla","text":"Para resolver el problema de los distintos tama\u00f1os de pantalla en Cocos2d-x lo que haremos ser\u00e1 definir tres resoluciones distintas: Resoluci\u00f3n de recursos : Resoluci\u00f3n para la que est\u00e1n preparados los recursos utilizados. Resoluci\u00f3n de dise\u00f1o : Resoluci\u00f3n para la que hemos dise\u00f1ado el juego. Ser\u00e1 esta resoluci\u00f3n la que utilizaremos en el c\u00f3digo del juego (resoluci\u00f3n en puntos). Resoluci\u00f3n de pantalla : Resoluci\u00f3n real de la pantalla del dispositivo. En el objeto AppDelegate se inicializa el juego. Este es un buen punto para configurar las resoluciones anteriores. Por ejemplo, podemos definir esta configuraci\u00f3n de la siguiente forma: 1 2 3 4 5 6 7 8 9 10 Size screenSize = director -> getOpenGLView () -> getFrameSize (); Size designSize ( 480 , 320 ); Size resourceSize ( 960 , 640 ); // Establecemos la resoluci\u00f3n de recursos director -> setContentScaleFactor ( resourceSize . width / designSize . width ); // Establecemos la resoluci\u00f3n de dise\u00f1o (puntos) cocos2d :: Director :: getInstance () -> getOpenGLView () -> setDesignResolutionSize ( 320 , 480 , ResolutionPolicy :: FIXED_WIDTH ); En este ejemplo hemos especificado: Resoluci\u00f3n de recursos : 960 x 640 Resoluci\u00f3n de dise\u00f1o : 480 x 320 Las reglas que seguiremos para trabajar con estas resoluciones son: En el c\u00f3digo del juego siempre utilizaremos la resoluci\u00f3n de dise\u00f1o . Es decir, en el ejemplo anterior consideraremos que siempre tenemos una resoluci\u00f3n de 480 x 320 puntos al posicionar sprites , ubicar elementos del HUD, mostrar elementos del escenario, etc. El contenido que hayamos dibujado en el espacio de dise\u00f1o se estirar\u00e1 para ocupar toda la pantalla. La resoluci\u00f3n de recursos nos indica la resoluci\u00f3n de pantalla para la que est\u00e1n preparados los recursos en el caso ideal, es decir, en el que cada p\u00edxel de la imagen del recurso corresponde exactamente a un p\u00edxel en pantalla. En el caso de nuestro ejemplo, la resoluci\u00f3n para la que est\u00e1n preparados los recursos es el doble que la resoluci\u00f3n de dise\u00f1o. Es decir, un sprite cuya imagen tenga 80 x 80 pixels que est\u00e9 pensado para que se dibuje con su tama\u00f1o original en una pantalla de 960 x 640, en un espacio de dise\u00f1o de 480 x 320 ocupar\u00eda un espacio de 40 x 40 puntos. Decimos en este caso que su factor de escala es 2.0, ya cada punto de nuestro espacio de dise\u00f1o corresponde a 2 x 2 pixels de la imagen del recurso. Si la resoluci\u00f3n real de pantalla fuera de 480 x 320, coincidiendo con la resoluci\u00f3n de dise\u00f1o, la imagen del sprite tendr\u00e1 que escalarse a mitad de tama\u00f1o (reduciendo la definici\u00f3n de la imagen original a la mitad, ya que la definici\u00f3n del sprite es mayor de lo que nos permite mostrar la pantalla); en el caso de tener una resoluci\u00f3n de pantalla de 960 x 640 el sprite se mostrar\u00eda en su tama\u00f1o real con todos sus pixels (aunque en el c\u00f3digo lo posicionemos y obtengamos su tama\u00f1o en puntos); y si contamos con una pantalla de 1920 x 1280 el sprite tendr\u00eda que escalarse al doble de su tama\u00f1o (en este caso la resoluci\u00f3n del sprite no ser\u00eda suficiente para aprovechar toda la definici\u00f3n de la pantalla). Con esto podemos ver que aunque trabajemos con una resoluci\u00f3n de dise\u00f1o peque\u00f1a, esto no implica que el juego se vaya a ver con poca resoluci\u00f3n. \u00c9sta resoluci\u00f3n de dise\u00f1o simplemente es un sistema de coordenadas de referencia para situar los objetos en la escena. La resoluci\u00f3n que realmente determinar\u00e1 la definici\u00f3n de los gr\u00e1ficos del juego es la resoluci\u00f3n de recursos. Con el m\u00e9todo Director::setContentScaleFactor estableceremos la relaci\u00f3n existente entre la relaci\u00f3n de recursos y la de dise\u00f1o. Por ejemplo, si la resoluci\u00f3n de recursos es el doble que la de dise\u00f1o, el factor de escala ser\u00e1 2. En caso de que la relaci\u00f3n de aspecto de estas resoluciones no coincidiese, tendr\u00edamos que decidir si tomar como referencia el alto o el ancho de la imagen a la hora de calcular el factor de escala. 1 2 3 4 5 // Tomamos como referencia el ancho director -> setContentScaleFactor ( resourceSize . width / designSize . width ); // Tomamos como referencia el alto director -> setContentScaleFactor ( resourceSize . height / designSize . height );","title":"Resoluciones de recursos, dise\u00f1o y pantalla"},{"location":"adaptacion_a_moviles.html#gestion-de-recursos","text":"En el apartado anterior hemos visto c\u00f3mo establecer la resoluci\u00f3n de los recursos. Sin embargo, como ya hemos comentado anteriormente, es dif\u00edcil tener una \u00fanica resoluci\u00f3n de recursos que sea adecuada para todos los dispositivos: dispositivos de alta densidad necesitan recursos con mayor resoluci\u00f3n para aprovechar la densidad de pantalla, y dispositivos con menor densidad de pantalla normalmente tienen una memoria de v\u00eddeo m\u00e1s limitada donde puede que no quepan los recursos necesarios. Por ello es conveniente suministrar diferentes versiones de los recursos. Para soportar distintas versiones de un mismo recurso lo que haremos es guardarlo en diferentes directorios pero con el mismo nombre de fichero. Por ejemplo, podemos crear un directorio sd para la versi\u00f3n normal y otro directorio hd para la versi\u00f3n para dispositivos de alta resoluci\u00f3n. Ambos directorios tendr\u00e1n los mismos ficheros de texturas, pero con distintas resoluciones. Lo que deberemos hacer es indicar al motor d\u00f3nde buscar los recursos en funci\u00f3n de la resoluci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 Size screenSize = director -> getOpenGLView () -> getFrameSize (); std :: vector < std :: string > searchPaths ; if ( screenSize . height > 320 ) { // iPhone retina searchPaths . push_back ( \"hd\" ); searchPaths . push_back ( \"comun\" ); } else { // iPhone searchPaths . push_back ( \"sd\" ); searchPaths . push_back ( \"comun\" ); } FileUtils :: getInstance () -> setSearchPaths ( searchPaths ); En el ejemplo anterior, en el caso del iPhone retina buscar\u00e1 primero los recursos en el directorio hd , y si no los encuentra ah\u00ed buscar\u00e1 en comun . En caso caso de tener menor resoluci\u00f3n buscar\u00e1 primero en sd y despu\u00e9s en comun . Una vez decidida la versi\u00f3n de los recursos que se va a utilizar, deberemos indicar al motor la resoluci\u00f3n de recursos correcta para que as\u00ed los escale de forma adecuada: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Size screenSize = director -> getOpenGLView () -> getFrameSize (); Size designSize = Size ( 480 , 320 ); Size resourceSize ; std :: vector < std :: string > searchPaths ; if ( screenSize . height > 320 ) { // iPhone retina searchPaths . push_back ( \"hd\" ); searchPaths . push_back ( \"comun\" ); resourceSize = Size ( 960 , 640 ); } else { // iPhone searchPaths . push_back ( \"sd\" ); searchPaths . push_back ( \"comun\" ); resourceSize = Size ( 480 , 320 ); } FileUtils :: getInstance () -> setSearchPaths ( searchPaths ); director -> setContentScaleFactor ( resourceSize . width / designSize . width ); director -> getOpenGLView () -> setDesignResolutionSize ( 320 , 480 , ResolutionPolicy :: FIXED_WIDTH );","title":"Gesti\u00f3n de recursos"},{"location":"adaptacion_a_moviles.html#estrategias-de-adaptacion","text":"Con el m\u00e9todo setDesignResolutionSize establecemos la resoluci\u00f3n de dise\u00f1o a utilizar en el juego. Adem\u00e1s el tercer par\u00e1metro permite indicar la forma de adaptar la resoluci\u00f3n de dise\u00f1o a la resoluci\u00f3n de pantalla cuando la relaci\u00f3n de aspecto de ambas resoluciones no coincida. Encontramos las siguientes estrategias: ResolutionPolicy::SHOW_ALL : Hace que todo el contenido de la resoluci\u00f3n de dise\u00f1o quede dentro de la pantalla, dejando franjas negras en los laterales si la relaci\u00f3n de aspecto no es la misma. Estas franjas negras hacen que desperdiciemos espacio de pantalla y causan un efecto bastante negativo, por lo que a pesar de la sencillez de esta estrategia, no ser\u00e1 recomendable si buscamos un producto con un buen acabado. ResolutionPolicy::EXACT_FIT : Hace que el contenido dentro de la resoluci\u00f3n de dise\u00f1o se estire para adaptarse a la resoluci\u00f3n de pantalla, deformando el contenido si la relaci\u00f3n de aspecto no es la misma. Aunque en este caso se llene la pantalla, la deformaci\u00f3n de la imagen tambi\u00e9n causar\u00e1 muy mal efecto y por lo tanto debemos evitar utilizar esta t\u00e9cnica . ResolutionPolicy::NO_BORDER : Ajusta el contenido de la resoluci\u00f3n de dise\u00f1o a la resoluci\u00f3n de pantalla, sin dejar borde y sin deformar el contenido, pero dejando parte de \u00e9ste fuera de la pantalla si la relaci\u00f3n de aspecto no coincide. En este caso no habr\u00e1 problema si implementamos el juego de forma correcta, ayud\u00e1ndonos de los m\u00e9todos Director::getInstance()->getVisibleSize() y Director::getInstance()->getVisibleOrigin() que nos dar\u00e1n el tama\u00f1o y el origen, respectivamente, de la zona visible de nuestra resoluci\u00f3n de dise\u00f1o. De esta forma deberemos asegurarnos de dibujar todos los componentes del HUD dentro de esta zona, y a la hora de implementar scroll lo alinearemos de forma correcta con el origen de la zona visible. ResolutionPolicy::FIXED_HEIGHT , ResolutionPolicy::FIXED_WIDTH modifican la resoluci\u00f3n de dise\u00f1o para que tenga la misma relaci\u00f3n de aspecto que la resoluci\u00f3n de pantalla, manteniendo fija la altura o la anchura de dise\u00f1o respectivamente. Podremos consultar la resoluci\u00f3n de dise\u00f1o con Director::getInstance()->getWinSize() . En estos casos toda la resoluci\u00f3n de dise\u00f1o es visible en pantalla, pero \u00e9sta puede variar en altura o en anchura, seg\u00fan la estrategia indicada. \u00bfQu\u00e9 estrategia debemos utilizar? Depender\u00e1 de lo que busquemos en nuestro juego, pero normalmente nos quedaremos con NO_BORDER , FIXED_HEIGHT o FIXED_WIDTH .","title":"Estrategias de adaptaci\u00f3n"},{"location":"adaptacion_a_moviles.html#estrategia-no_border","text":"Se trata de una estrategia adecuada por ejemplo para juegos de rol con vista cenital y scroll en cualquier direcci\u00f3n. El personaje estar\u00e1 centrado en pantalla y se podr\u00e1 mover en cualquier direcci\u00f3n, as\u00ed que nos da igual la parte que quede cortada siempre que en el caso de haber HUD nos aseguremos de dibujarlo dentro de la zona visible. Para conseguir dibujar el HUD de forma adecuada con esta estrategia es importante tener en cuenta las propiedades visibleOrigin y visibleSize , que nos indicar\u00e1n la zona de nuestra espacio de dise\u00f1o que va a ser visible realmente en pantalla.","title":"Estrategia NO_BORDER"},{"location":"adaptacion_a_moviles.html#estrategias-fixed_width-y-fixed_height","text":"Estas dos estrategias, a diferencia de todas las dem\u00e1s, tienen la particularidad de modificar la resoluci\u00f3n de dise\u00f1o, manteniendo inalterado siempre al menos el ancho ( FIXED_WIDTH ) o el alto ( FIXED_HEIGHT ). Podemos consultar la resoluci\u00f3n de dise\u00f1o que ha resultado tras la modificaci\u00f3n con la propiedad winSize . Si tenemos por ejemplo un plataformas de avance horizontal, normalmente querremos que la altura sea fija, por lo que FIXED_HEIGHT podr\u00eda ser la opci\u00f3n m\u00e1s adecuada. Si por el contrario es un juego que avanza verticalmente (por ejemplo juegos de naves), ser\u00e1 m\u00e1s adecuado FIXED_WIDTH .","title":"Estrategias FIXED_WIDTH y FIXED_HEIGHT"},{"location":"adaptacion_a_moviles.html#posicionamiento-de-los-elementos-de-la-gui","text":"Hemos visto diferentes estrategias para adaptar el videojuego al tama\u00f1o de la pantalla del m\u00f3vil, intentando preservar en la medida de lo posible la resoluci\u00f3n de dise\u00f1o. Esto es relativamente sencillo para juegos que cuentan con escenarios con scroll lateral, vertical, o ambos. Sin embargo, un elemento con el que deberemos llevar especial cuidado son los componentes de la GUI, como es el caso del HUD (marcador de puntuaci\u00f3n, vidas restantes, energ\u00eda, etc) y los men\u00fas del juego.","title":"Posicionamiento de los elementos de la GUI"},{"location":"adaptacion_a_moviles.html#componentes-de-la-gui-de-cocos2d-x","text":"En cocos2d-x encontramos una API bastante completa de elementos para la GUI, a la que tendremos acceso importando el fichero ui/CocosGUI.h y que est\u00e1 contenida bajo el espacio de nombres ui . En ella encontramos elementos como botones, listas, etiquetas de texto, paneles de scroll , im\u00e1genes o sliders , y podremos utilizarlos de la misma forma que el resto de nodos, aunque en estos casos normalmente contaremos con la posibilidad de programar eventos para las acciones que pueda realizar cada uno de estos widgets , como por ejemplo el evento de click de un bot\u00f3n. 1 2 3 4 5 6 7 8 9 10 11 ui :: Button * button = ui :: Button :: create (); button -> loadTextures ( \"boton_normal.png\" , \"boton_pressed.png\" ); button -> setTitleText ( \"Pause\" ); button -> setTitleFontName ( \"Marker Felt\" ); addChild ( button ); button -> addTouchEventListener ([ & ]( Ref * sender , ui :: Widget :: TouchEventType type ) { if ( type == ui :: Widget :: TouchEventType :: ENDED ) { pausar (); } });","title":"Componentes de la GUI de cocos2d-x"},{"location":"adaptacion_a_moviles.html#imagenes-nine-patch","text":"Algunos elementos de la GUI de cocos2d-x, como los botones, soportan trabajar con im\u00e1genes nine-patch , con lo cual podemos hacer botones independientes del tama\u00f1o de su contenido. Para activar el modo nine_patch , deberemos proporcionar los l\u00edmites de la regi\u00f3n central (estirable) de la imagen mediante el m\u00e9todo setCapInsets . Tras esto activaremos el modo nine-patch con setScale9Enabled . Ahora podremos cambiar el tama\u00f1o del contenido del widget setContentSize sin que se deformen las esquinas de la imagen. 1 2 3 button -> setCapInsets ( Rect ( 8 , 8 , 26 , 26 )); button -> setContentSize ( button -> getTitleRenderer () -> getContentSize () + Size ( 16 , 16 )); button -> setScale9Enabled ( true );","title":"Im\u00e1genes nine-patch"},{"location":"adaptacion_a_moviles.html#alineacion-con-los-bordes-de-la-pantalla","text":"Muchos elementos del HUD deber\u00e1n estar alineados con las esquinas de la pantalla. Por ejemplo, nos puede interesar tener un bot\u00f3n de pausa en la esquina superior izquierda, y nuestra puntuaci\u00f3n en la esquina superior derecha. Para alinear estos elementos de forma correcta, lo m\u00e1s adecuado ser\u00e1 ajustar convenientemente la propiedad anchorPoint del nodo, que contendr\u00e1 unas coordenadas relativas (de 0 a 1) al tama\u00f1o del nodo, indicando qu\u00e9 punto del nodo coincidir\u00e1 con la posici\u00f3n donde lo ubiquemos en pantalla ( position ). En el eje de las x , el valor 0 hace referencia al lado izquierda, 0.5 al centro, y 1 al lado derecho. En el eje de las y , el valor 0 representa la parte inferior del nodo, 0.5 la mitad, y 1 la parte superior. Por ejemplo, para un elemento que vaya a estar en la esquina superior izquierda, un valor correcto para el anchorPoint ser\u00eda (0,1) , para que as\u00ed cuando lo ubiquemos en dicha posici\u00f3n sea su esquina superior izquierda la que coincida con la esquina de la pantalla. 1 2 3 4 5 Size visibleSize = Director :: getInstance () -> getVisibleSize (); Vec2 origin = Director :: getInstance () -> getVisibleOrigin (); button -> setAnchorPoint ( Vec2 ( 0.0 , 1.0 )); button -> setPosition ( Point ( origin . x + 5 , origin . y + visibleSize . height - 5 )); Por otro lado, si queremos que el elemento quede alineado en la esquina superior derecha, ser\u00e1 mejor especificar como anchorPoint el valor (1,1) , para que as\u00ed al ubicarlo en dicha posici\u00f3n sea su esquina superior derecha. Aunque el nodo cambie de tama\u00f1o, su esquina superior derecha siempre se mantendr\u00e1 en el mismo punto en pantalla. Para los elementos con texto variable, como por ejemplo la puntuaci\u00f3n, cuando los ajustemos a la derecha ser\u00e1 conveniente que reservemos espacio suficiente para todos los valores que queramos que pueda tomar, para que as\u00ed al ir aumentando el n\u00famero de d\u00edgitos de la puntuaci\u00f3n no se vaya desplazando el texto. En este caso puede ser recomendable utilizar una fuente monoespaciada y rellenar con ceros el n\u00famero m\u00e1ximo de d\u00edgitos que queramos que pueda tener. Por ejemplo, SCORE: 00010 .","title":"Alineaci\u00f3n con los bordes de la pantalla"},{"location":"adaptacion_a_moviles.html#menus","text":"A parte del HUD, los men\u00fas del juego son otro elemento con el que deberemos llevar especial cuidado. En este caso lo normal ser\u00e1 tener centrados los items del men\u00fa en pantalla, habitualmente con una disposici\u00f3n vertical. Los botones del men\u00fa (y todos los botones de la interfaz en general) deber\u00e1n tener un tama\u00f1o suficiente para abarcar la yema del dedo en cualquier dispositivo. Esto nos llevar\u00e1 a tener en el m\u00f3vil botones que ocupar\u00e1n gran parte de la pantalla. Si trasladamos la aplicaci\u00f3n a un tablet , la estrategia de cocos2d-x ser\u00e1 la de escalar la pantalla, lo cual puede producir que los men\u00fas se vean innecesariamente grandes. Podemos plantearnos la posibilidad de implementar men\u00fas alternativos para tel\u00e9fonos y tablets , que aprovechen en cada caso la pantalla de forma adecuada, o limitar el tama\u00f1o de los elementos del men\u00fa cuando el tama\u00f1o f\u00edsico de la pantalla sea mayor al de un m\u00f3vil, para as\u00ed evitar ocupar m\u00e1s espacio de pantalla que el necesario para poderlos pulsar f\u00e1cilmente.","title":"Men\u00fas"},{"location":"adaptacion_a_moviles.html#depuracion-del-cambio-de-densidad-de-pantalla","text":"Para comprobar que nuestra aplicaci\u00f3n se adapta de forma correcta podemos utilizar diferentes tama\u00f1os de ventana durante el desarrollo. Sin embargo, tambi\u00e9n ser\u00e1 necesario comprobar lo que ocurre al tener diferentes densidades de pantalla, teniendo algunos dispositivos resoluciones superiores a la de nuestra m\u00e1quina de desarrollo. Para resolver este problema podemos utilizar la funci\u00f3n GLView::setFrameZoomFactor . Con esta funci\u00f3n podemos aplicar un factor de zoom al contenido de la ventana. De esta forma podemos tener altas resoluciones, como los 2048x1536 pixeles de un iPad retina, dentro del espacio de nuestra pantalla. Esta funci\u00f3n deber\u00e1 invocarse \u00fanicamente en el c\u00f3digo espec\u00edfico de la plataforma de desarrollo (Windows, Linux o Mac). Por ejemplo, en el caso de Mac a\u00f1adiremos las siguientes l\u00edneas al fichero AppDelegate.cpp : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 bool AppDelegate :: applicationDidFinishLaunching () { // initialize director auto director = Director :: getInstance (); auto glview = director -> getOpenGLView (); if ( ! glview ) { glview = GLViewImpl :: create ( \"Mi Juego\" ); director -> setOpenGLView ( glview ); } // Depuracion multi-resolucion GLView * eglView = Director :: getInstance () -> getOpenGLView (); eglView -> setFrameSize ( 1536 , 2048 ); eglView -> setFrameZoomFactor ( 0.4f ); // Soporte multi-resolucion cocos2d :: Director :: getInstance () -> getOpenGLView () -> setDesignResolutionSize ( 768 , 1024 , ResolutionPolicy :: FIXED_WIDTH ); // turn on display FPS director -> setDisplayStats ( true ); // set FPS. the default value is 1.0/60 if you don't call this director -> setAnimationInterval ( 1.0 / 60 ); // create a scene. it's an autorelease object auto scene = TitleScene :: createScene (); // run director -> runWithScene ( scene ); return true ; }","title":"Depuraci\u00f3n del cambio de densidad de pantalla"},{"location":"adaptacion_a_moviles.html#compilacion-condicional","text":"En muchos casos tendremos que poner c\u00f3digo que s\u00f3lo queremos que se incluya para una plataforma determinada. Podemos hacer que se determine en tiempo de compilaci\u00f3n si se debe incluir dicho c\u00f3digo o no. Para ello podemos incluir bloques condicionales que hagan que s\u00f3lo se incluya el c\u00f3digo al compilar si compilamos para la plataforma indicada. 1 2 3 #if (CC_TARGET_PLATFORM == <plataforma>) ... // C\u00f3digo condicional #endif Por ejemplo, en el caso anterior en el que busc\u00e1bamos emular diferentes resoluciones de m\u00f3vil en la plataforma Mac para as\u00ed depurar la adaptaci\u00f3n al tama\u00f1o de pantalla, podemos hacer que este c\u00f3digo para la depuraci\u00f3n s\u00f3lo se incluya para la plataforma Mac: 1 2 3 4 5 6 #if (CC_TARGET_PLATFORM == CC_PLATFORM_MAC) // Depuracion multi-resolucion GLView * eglView = Director :: getInstance () -> getOpenGLView (); eglView -> setFrameSize ( 320 , 480 ); eglView -> setFrameZoomFactor ( 1.0f ); #endif Podemos introducir c\u00f3digo condicional para las diferentes plataformas soportadas: CC_PLATFORM_IOS CC_PLATFORM_ANDROID CC_PLATFORM_WP8 CC_PLATFORM_BLACKBERRY CC_PLATFORM_WIN32 CC_PLATFORM_LINUX CC_PLATFORM_MAC Esto nos permitir\u00e1 por ejemplo incluir servicios que s\u00f3lo estar\u00e1n disponibles en una determinada plataforma, como es el caso de Game Center en iOS.","title":"Compilaci\u00f3n condicional"},{"location":"adaptacion_a_moviles.html#optimizacion-de-texturas","text":"Aunque utilicemos un motor o librer\u00eda de alto nivel para implementar nuestro videojuego, como puede ser Unity o Cocos2d-x, por debajo estas librer\u00edas siempre estar\u00e1n utilizando OpenGL. Concretamente, en los dispositivos m\u00f3viles utilizar\u00e1n OpenGL ES, una versi\u00f3n reducida de OpenGL pensada para este tipo de dispositivos. Seg\u00fan las caracter\u00edsticas del dispositivo se utilizar\u00e1 OpenGL ES 1.0 o OpenGL ES 2.0. Las primeras generaciones de iPhone soportaban \u00fanicamente OpenGL ES 1.0, mientras que actualmente se pueden utilizar ambas versiones de la librer\u00eda. Actualmente podemos encontrar OpenGL ES 2.0 en pr\u00e1cticamente la totalidad de dispositivos Android e iOS disponibles. Por este motivo ser\u00e1 importante tener algunas nociones sobre c\u00f3mo gestiona los gr\u00e1ficos OpenGL. Los gr\u00e1ficos a mostrar en pantalla se almacenan en memoria de v\u00eddeo como texturas. La memoria de v\u00eddeo es un recurso cr\u00edtico (se suele compartir con la RAM del dispositivo), por lo que deberemos optimizar las texturas para ocupar la m\u00ednima cantidad de memoria posible. Para aprovechar al m\u00e1ximo la memoria, se recomienda que las texturas tengan de tama\u00f1o una potencia de 2 (por ejemplo 128x128, 256x256, 512x512, 1024x1024, o 2048x2048), ya que son las dimensiones con las que trabaja la memoria de v\u00eddeo. En OpenGL ES 1.0 el tama\u00f1o m\u00e1ximo de las texturas es de 1024x1024, mientras que en OpenGL ES 2.0 este tama\u00f1o se ampl\u00eda hasta 2048x2048, Existen diferentes formatos de textura: RGB8888 : 32 bits por pixel. Contiene un canal alpha de 8 bits, con el que podemos dar a cada pixel 256 posibles niveles de transparencia. Permite representar m\u00e1s de 16 millones de colores (8 bits para cada canal RGB). RGB4444 : 16 bits por pixel. Contiene un canal alpha de 4 bits, con el que podemos dar a cada pixel 16 posibles niveles de transparencia. Permite representar 4.096 colores (4 bits para cada canal RGB). Esto permite representar colores planos, pero no ser\u00e1 capaz de representar correctamente los degradados. RGB565 : 16 bits por pixel. No permite transparencia. Permite representar 65.536 colores, con 6 bits para el canal verde (G), y 5 bits para los canales rojo (R) y azul (B). Este tipo de textura ser\u00e1 la m\u00e1s adecuada para fondos. RGB5551 : 16 bits por pixel. Permite transparencia de un s\u00f3lo bit, es decir, que un pixel puede ser transparente u opaco, pero no permite niveles intermedios. Permite representar 32.768 colores (5 bits para cada canal RGB). Debemos evitar en la medida de lo posible utilizar el tipo RGB8888 , debido no s\u00f3lo al espacio que ocupa en memoria y en disco (aumentar\u00e1 significativamente el tama\u00f1o del paquete), sino tambi\u00e9n a que el rendimiento del videojuego disminuir\u00e1 al utilizar este tipo de texturas. Escogeremos un tipo u otro seg\u00fan nuestras necesidades. Por ejemplo, si nuestros gr\u00e1ficos utilizan colores planos, RGB4444 puede ser una buena opci\u00f3n. Para fondos en los que no necesitemos transparencia la opci\u00f3n m\u00e1s adecuada ser\u00eda RGB565 . Si nuestros gr\u00e1ficos tienen un borde s\u00f3lido y no necesitamos transparencia parcial, pero si total, podemos utilizar RGB5551 . En caso de necesitar utilizar RGB4444 con texturas en las que tenemos degradado, podemos aplicar a la textura el efecto dithering para que el degradado se represente de una forma m\u00e1s adecuada utilizando un reducido n\u00famero de colores. Esto se consigue mezclando p\u00edxeles de distintos colores y modificando la proporci\u00f3n de cada color conforme avanza el degradado, evitando as\u00ed el efecto de degradado escalonado que obtendr\u00edamos al representar las texturas con un menor n\u00famero de colores. Tambi\u00e9n tenemos la posibilidad de utilizar formatos de textura comprimidos para aprovechar al m\u00e1ximo el espacio y obtener un mayor rendimiento. En iPhone el formato de textura soportado es PVRTC. Existen variantes de 2 y 4 bits de este formato. Se trata de un formato de compresi\u00f3n con p\u00e9rdidas. En Android los dispositivos con OpenGL ES 1.0 no ten\u00edan ning\u00fan formato est\u00e1ndar de compresi\u00f3n. Seg\u00fan el dispositivo pod\u00edamos encontrar distintos formatos: ATITC, PVRTC, DXT. Sin embargo, todos los dispositivos con soporte para OpenGL ES 2.0 soportan el formato ETC1. Podemos convertir nuestras texturas a este formato con la herramienta $ANDROID_SDK_HOME/tools/etc1tool , incluida con el SDK de Android. Un inconveniente de este formato es que no soporta canal alpha . Adem\u00e1s de seleccionar el formato adecuado para la textura, deberemos aprovechar al m\u00e1ximo el espacio disponible dentro de ella (dentro de una textura podemos incluir im\u00e1genes de diferentes sprites y fotogramas de los mismos). Herramientas especializadas como Texture Packer nos permitir\u00e1n al mismo tiempo empaquetar nuestros sprites de forma \u00f3ptima en una textura, y especificar el formato de textura a utilizar. En motores como Unity encontramos herramientas integradas que nos permiten realizar esta tarea.","title":"Optimizaci\u00f3n de texturas"},{"location":"box2d.html","text":"Motores de f\u00edsicas \u00b6 Un tipo de juegos que ha tenido una gran proliferaci\u00f3n en el mercado de aplicaciones para m\u00f3viles son aquellos juegos basados en f\u00edsicas. Estos juegos son aquellos en los que el motor realiza una simulaci\u00f3n f\u00edsica de los objetos en pantalla, siguiendo las leyes de la cinem\u00e1tica y la din\u00e1mica. Es decir, los objetos de la pantalla est\u00e1n sujetos a gravedad, cada uno de ellos tiene una masa, y cuando se produce una colisi\u00f3n entre ellos se produce una fuerza de reacci\u00f3n que depender\u00e1 de su velocidad y su masa. El motor de f\u00edsicas se encarga de realizar toda esta simulaci\u00f3n, y nosotros s\u00f3lo deberemos encargarnos de proporcionar las propiedades de los objetos del mundo. Uno de los motores f\u00edsicos m\u00e1s utilizados es Box2D, originalmente implementado en C++. Se ha utilizado para implementar juegos tan conocidos y exitosos como Angry Birds. Podemos encontrar ports de este motor para las distintas plataformas m\u00f3viles. Motores como Cocos2D, libgdx y Unity incluyen una implementaci\u00f3n de este motor de f\u00edsicas. Motor de f\u00edsicas Box2D \u00b6 Vamos ahora a estudiar el motor de f\u00edsicas Box2D. Es importante destacar que este motor s\u00f3lo se encargar\u00e1 de simular la f\u00edsica de los objetos, no de dibujarlos. Ser\u00e1 nuestra responsabilidad mostrar los objetos en la escena de forma adecuada seg\u00fan los datos obtenidos de la simulaci\u00f3n f\u00edsica. Comenzaremos viendo los principales componentes de esta librer\u00eda. Componentes de Box2D \u00b6 Los componentes b\u00e1sicos que nos permiten realizar la simulaci\u00f3n f\u00edsica con Box2D son: Body : Representa un cuerpo r\u00edgido. Estos son los tipos de objetos que tendremos en el mundo 2D simulado. Cada cuerpo tendr\u00e1 una posici\u00f3n y velocidad. Los cuerpos se ver\u00e1n afectados por la gravedad del mundo, y por la interacci\u00f3n con los otros cuerpos. Cada cuerpo tendr\u00e1 una serie de propiedades f\u00edsicas, como su masa o su centro de gravedad. Fixture : Es el objeto que se encarga de fijar las propiedades de un cuerpo, como su forma, coeficiente de rozamiento o densidad. Un cuerpo podr\u00eda contener varias fixtures , para as\u00ed poder crear formas m\u00e1s complejas combinando formas b\u00e1sicas. Shape : Sirve para especificar la forma de una fixture . Hay distintos tipos de formas (subclases de Shape ), como por ejemplo CircleShape y PolygonShape , para crear cuerpos con formar circulares o poligonales respectivamente. Constraint : Nos permite limitar la libertad de un cuerpo. Por ejemplo podemos utilizar una restricci\u00f3n que impida que el cuerpo pueda rotar, o para que se mueva siguiendo s\u00f3lo una l\u00ednea (por ejemplo un objeto montado en un rail). Joint : Nos permite definir uniones entre diferentes cuerpos. World : Representa el mundo 2D en el que tendr\u00e1 lugar la simulaci\u00f3n. Podemos a\u00f1adir una serie de cuerpos al mundo. Una de las principales propiedades del mundo es la gravedad. Todas las clases de la librer\u00eda Box 2D tienen el prefijo b2 . Hay que tener en cuenta que se trata de clases C++, y no Objective-C. Lo primero que deberemos hacer es crear el mundo en el que se realizar\u00e1 la simulaci\u00f3n f\u00edsica. Como par\u00e1metro deberemos proporcionar un vector 2D con la gravedad del mundo: 1 2 3 b2Vec2 gravity ; gravity . Set ( 0 , - 10 ); b2World * world = new b2World ( gravity ); Unidades de medida \u00b6 Antes de crear cuerpos en el mundo, debemos entender el sistema de coordenadas de Box2D y sus unidades de medida. Los objetos de Box2D se miden en metros, y la librer\u00eda est\u00e1 optimizada para objetos de 1m, por lo que deberemos hacer que los objetos que aparezcan con m\u00e1s frecuencia tengan esta medida. Sin embargo, los gr\u00e1ficos en pantalla se miden en p\u00edxeles (o puntos). Deberemos por lo tanto fijar el ratio de conversi\u00f3n entre pixeles y metros. Por ejemplo, si los objetos con los que trabajamos normalmente miden 32 pixeles, haremos que 32 pixeles equivalgan a un metro. Definimos el siguiente ratio de conversi\u00f3n: 1 const float PTM_RATIO = 32.0 ; Para todas las unidades de medida Box2D utiliza el sistema m\u00e9trico. Por ejemplo, para la masa de los objetos utiliza Kg. Tipos de cuerpos \u00b6 Encontramos tres tipos diferentes de cuerpos en Box2D seg\u00fan la forma en la que queremos que se realice la simulaci\u00f3n con ellos: Din\u00e1micos : Est\u00e1n sometidos a las leyes f\u00edsicas, y tienen una masa concreta y finita. Estos cuerpos se ven afectados por la gravedad y por la interacci\u00f3n con los dem\u00e1s cuerpos. Est\u00e1ticos : Son cuerpos que permanecen siempre en la misma posici\u00f3n. Equivalen a cuerpos con masa infinita. Por ejemplo, podemos hacer que el escenario sea est\u00e1tico. Es importante no mover aquellos cuerpos que hayan sido marcados como est\u00e1ticos, ya que el motor podr\u00eda no responder de forma correcta. Cinem\u00e1ticos : Al igual que los cuerpos est\u00e1ticos tienen masa infinita y no se ven afectados por otros cuerpos ni por la gravedad. Sin embargo, en esta caso no tienen una posici\u00f3n fija, sino que podemos moverlos por el mundo. Nos son \u00fatiles por ejemplo para proyectiles. Creaci\u00f3n de cuerpos \u00b6 Con todo lo visto anteriormente ya podemos crear distintos cuerpos. Para crear un cuerpo primero debemos crear un objeto de tipo BodyDef con las propiedades del cuerpo a crear, como por ejemplo su posici\u00f3n en el mundo, su velocidad, o su tipo. Una vez hecho esto, crearemos el cuerpo a partir del mundo ( World ) y de la definici\u00f3n del cuerpo que acabamos de crear. Una vez creado el cuerpo, podremos asignarle una forma y densidad mediante fixtures . Por ejemplo, en el siguiente caso creamos un cuerpo din\u00e1mico con forma rectangular: 1 2 3 4 5 6 7 8 9 10 b2BodyDef bodyDef ; bodyDef . type = b2_dynamicBody ; bodyDef . position . Set ( x / PTM_RATIO , y / PTM_RATIO ); b2Body * body = world -> CreateBody ( & bodyDef ); b2PolygonShape bodyShape ; bodyShape . SetAsBox (( width / 2 ) / PTM_RATIO , ( height / 2 ) / PTM_RATIO ); body -> CreateFixture ( & bodyShape , 1.0f ); En este caso hemos creado un cuerpo con una \u00fanica fixture con forma de caja y densidad 1.0 \\frac{kg}{m^2} \\frac{kg}{m^2} . La masa del cuerpo sera calculada de forma autom\u00e1tica a partir de la forma y densidad de sus fixtures . De forma similar podemos tambi\u00e9n crear un cuerpo din\u00e1mico de forma circular con: 1 2 3 4 5 6 7 8 9 10 b2BodyDef bodyDef ; bodyDef . type = b2_dynamicBody ; bodyDef . position . Set ( x / PTM_RATIO , y / PTM_RATIO ); b2Body * body = world -> CreateBody ( & bodyDef ); b2CircleShape bodyShape ; bodyShape . m_radius = radius / PTM_RATIO ; b2Fixture * bodyFixture = body -> CreateFixture ( & bodyShape , 1.0f ); Para definir los l\u00edmites del escenario utilizaremos un cuerpo de tipo est\u00e1tico compuesto de varias fixtures con forma de arista ( edge ). En este caso en lugar de utilizar el atajo CreateFixture(shape, density) de los ejemplos anteriores utilizaremos la versi\u00f3n CreateFixture(fixtureDef) que crea la fixture a partir de las propiedades definidas en una estructura de tipo b2FixtureDef , lo cual nos dar\u00e1 mayor flexibilidad: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 b2BodyDef limitesBodyDef ; limitesBodyDef . position . Set ( x , y ); b2Body * limitesBody = world -> CreateBody ( & limitesBodyDef ); b2EdgeShape limitesShape ; b2FixtureDef fixtureDef ; fixtureDef . shape = & limitesShape ; limitesShape . Set ( b2Vec2 ( 0.0f / PTM_RATIO , 0.0f / PTM_RATIO ), b2Vec2 ( width / PTM_RATIO , 0.0f / PTM_RATIO )); limitesBody -> CreateFixture ( & fixtureDef ); limitesShape . Set ( b2Vec2 ( width / PTM_RATIO , 0.0f / PTM_RATIO ), b2Vec2 ( width / PTM_RATIO , height / PTM_RATIO )); limitesBody -> CreateFixture ( & fixtureDef ); limitesShape . Set ( b2Vec2 ( width / PTM_RATIO , height / PTM_RATIO ), b2Vec2 ( 0.0f / PTM_RATIO , height / PTM_RATIO )); limitesBody -> CreateFixture ( & fixtureDef ); limitesShape . Set ( b2Vec2 ( 0.0f / PTM_RATIO , height / PTM_RATIO ), b2Vec2 ( 0.0f / PTM_RATIO , 0.0f / PTM_RATIO )); limitesBody -> CreateFixture ( & fixtureDef ); En este \u00faltimo caso vemos que no hemos indicado ni el tipo de cuerpo ni la masa. Si no indicamos nada por defecto el cuerpo ser\u00e1 est\u00e1tico y su masa ser\u00e1 infinita. En la propiedad type de la estructura b2BodyDef podemos especificar de forma expl\u00edcita el tipo de cuerpo que queremos crear, que puede ser: b2_staticBody : Cuerpo est\u00e1tico (valor por defecto). Podemos moverlos manualmente, pero el motor no los mueve. b2_kinematicBody : Cuerpo cinem\u00e1tica. Podemos darle una velocidad pero las fuerzas no tienen efecto sobre \u00e9l. b2_dinamicBody : Cuerpo din\u00e1mico. Sometido totalmente a simulaci\u00f3n f\u00edsica. Los cuerpos tienen adem\u00e1s una propiedad userData que nos permite vincular cualquier objeto con el cuerpo. Por ejemplo, podr\u00edamos vincular a un cuerpo f\u00edsico el Sprite que queremos utilizar para mostrarlo en pantalla: 1 bodyDef . userData = sprite ; De esta forma, cuando realicemos la simulaci\u00f3n podemos obtener el sprite vinculado al cuerpo f\u00edsico y mostrarlo en pantalla en la posici\u00f3n que corresponda. Simulaci\u00f3n \u00b6 Ya hemos visto c\u00f3mo crear el mundo 2D y los cuerpos r\u00edgidos. Vamos a ver ahora c\u00f3mo realizar la simulaci\u00f3n f\u00edsica dentro de este mundo. Para realizar la simulaci\u00f3n deberemos llamar al m\u00e9todo step sobre el mundo, proporcionando el delta time transcurrido desde la \u00faltima actualizaci\u00f3n del mismo: 1 2 world -> Step ( delta , 6 , 2 ); world -> ClearForces (); Recomendaci\u00f3n : Conviene utilizar un delta time fijo para el motor de f\u00edsicas, para as\u00ed obtener resultados predecibles en la simulaci\u00f3n (por ejemplo 60 fps). Si el frame rate del render es distinto podemos interpolar las posiciones. Adem\u00e1s, los algoritmos de simulaci\u00f3n f\u00edsica son iterativos. Con cada iteraci\u00f3n se busca resolver las colisiones y restricciones de los objetos del mundo para aproximar su posici\u00f3n y velocidad. Cuantas m\u00e1s iteraciones se realicen mayor precisi\u00f3n se obtendr\u00e1 en los resultados, pero mayor coste tendr\u00e1n. El segundo y el tercer par\u00e1metro de step nos permiten establecer el n\u00famero de veces que debe iterar el algoritmo para resolver la posici\u00f3n y la velocidad de los cuerpos respectivamente. Tras hacer la simulaci\u00f3n, deberemos limpiar las fuerzas acumuladas sobre los objetos, para que no se arrastren estos resultados a pr\u00f3ximas simulaciones. Recomendaci\u00f3n : Un valor recomendable para las iteraciones de posici\u00f3n y velocidad es 8 y 3 respectivamente. Tras hacer la simulaci\u00f3n deberemos actualizar las posiciones de los sprites en pantalla y mostrarlos. Por ejemplo, si hemos vinculado el Sprite al cuerpo mediante la propiedad userData , podemos recuperarlo y actualizarlo de la siguiente forma: 1 2 3 4 5 6 Sprite * sprite = ( Sprite * ) body -> GetUserData (); b2Vec2 pos = body -> GetPosition (); float rot = - 1 * CC_RADIANS_TO_DEGREES ( b -> GetAngle ()); sprite -> setPosition ( Vec2 ( pos . x * PTM_RATIO , pos . y * PTM_RATIO )); sprite -> setRotation ( rot ); Formas de los objetos \u00b6 Hemos visto que mediante fixtures podemos asignar diferentes formas a los objetos del mundo, como c\u00edrculos, pol\u00edgonos y aristas. C\u00edrculos Es la forma m\u00e1s sencilla. Se crea simplemente indicando su centro y su radio, y el c\u00e1lculo de colisiones con ellos es muy eficiente. 1 2 3 b2CircleShape circle ; circle . m_p . Set ( 0.0f , 0.0f ); // Centro circle . m_radius = 0.5f ; // Radio Pol\u00edgonos Nos permite crear formas arbitrarias convexas. Es importante destacar que los pol\u00edgonos siempre ser\u00e1n convexos y cerrados, y sus v\u00e9rtices se definir\u00e1n en sentido contrario a las agujas del reloj (CCW). El c\u00e1lculo de colisiones con formas c\u00f3ncavas es demasiado complejo para el motor de f\u00edsicas. 1 2 3 4 5 6 7 b2Vec2 vertices [ kNUM_VERTICES ]; // Vertices definidos en orden CCW vertices [ 0 ]. Set ( - 1.0f , 0.0f ); vertices [ 1 ]. Set ( 1.0f , 0.0f ); vertices [ 2 ]. Set ( 0.0f , 2.0f ); b2PolygonShape polygon ; polygon . Set ( vertices , kNUM_VERTICES ); Un caso particular de los pol\u00edgonos son las cajas. Al ser este tipo de pol\u00edgonos muy com\u00fan, se proporciona un m\u00e9todo para crearlas de forma autom\u00e1tica a partir de su media altura y anchura: 1 2 b2PolygonShape box ; bodyShape . SetAsBox ( 0.5 , 0.5 ); // Crea una caja de 1m x 1m Aristas Las aristas ( edges ) son segmentos de l\u00ednea que normalmente se utilizan para construir la geometr\u00eda del escenario est\u00e1tico, que podr\u00e1 tener una forma arbitraria. Podemos 1 2 3 4 5 b2Vec2 v1 ( 0.0f , 0.0f ); // Inicio del segmento b2Vec2 v2 ( 1.0f , 0.0f ); // Fin del segmento b2EdgeShape edge ; edge . Set ( v1 , v2 ); Cadenas Las cadenas nos permiten unir varias aristas para as\u00ed definir la geometr\u00eda est\u00e1tica del escenario y evitar que se puedan producir \"baches\" en las juntas entre diferentes aristas. 1 2 3 4 5 6 7 8 b2Vec2 v [ kNUM_VERTICES ]; v [ 0 ]. Set ( 0.0f , 0.0f ); v [ 1 ]. Set ( 1.0f , 0.25f ); v [ 2 ]. Set ( 2.0f , 1.0f ); v [ 3 ]. Set ( 3.0f , 1.25f ); b2ChainShape chain ; chain . CreateChain ( vs , kNUM_VERTICES ); Cuidado : Las aristas de la cadena no deben intersectar entre si. Esto no est\u00e1 previsto por el motor, por lo que puede producir efectos inesperados. Formas compuestas Si ninguno de los tipos anteriores de formas se adapta a nuestras necesidades, como por ejemplo en el caso de necesitar una forma c\u00f3ncava, podemos definir la forma del cuerpo como una composici\u00f3n de form\u00e1s b\u00e1sicas. Esto lo podemos conseguir a\u00f1adiendo m\u00faltiples fixtures a un cuerpo, cada una de ellas con una forma distinta. Esto ser\u00e1 \u00fatil para cuerpos din\u00e1micos con formas complejas. Propiedades de los cuerpos \u00b6 Los cuerpos y fixtures tienen una serie de propiedades que nos permiten definir su comportamiento en la simulaci\u00f3n f\u00edsica. Hemos visto algunas b\u00e1sicas como la masa y la forma, que se indican en el momento de crear una fixture . Vamos a ver ahora otras propiedades f\u00edsicas de los objetos. Resistencia al aire Para cada cuerpo podemos indicar una constante de resistencia al aire ( damping ), tanto lineal como angular. La resistencia al aire es la fuerza que har\u00e1 que la velocidad del objeto disminuya, aunque no est\u00e9 en contacto con ning\u00fan otro cuerpo. Cu\u00e1nta mayor sea la velocidad, m\u00e1s fuerza ejercer\u00e1 la resistencia al aire para pararlo. Es recomendable indicar una resistencia al aire para que los cuerpos no se muevan (o roten) de forma indefinida: 1 2 bodyDef . linearDamping = 0.1f ; bodyDef . angularDamping = 0.25f ; Fricci\u00f3n La fricci\u00f3n es la fuerza que hace que un objeto se pare al deslizarse sobre otro, debido a rugosidades de la superficie. A diferencia de la resistencia al aire, esta fuerza s\u00f3lo se ejercer\u00e1 cuando dos fixtures est\u00e9n en contacto. La fricci\u00f3n se define a nivel de fixture : 1 fixtureDef . friction = 0.25f ; Restituci\u00f3n La restituci\u00f3n nos indica la forma en la que responder\u00e1 un objeto al colisionar con otro, permitiendo que los objetos permanezcan juntos o reboten. Una restituci\u00f3n 0 indica que el objeto no rebotar\u00e1 el colisionar, mientras que el valor 1 indica que al colisionar rebota y en el rebote se restituye toda la velocidad que ten\u00eda en el momento previo a la colisi\u00f3n. 1 fixtureDef . restitution = 0.5f ; Din\u00e1mica de cuerpos r\u00edgidos \u00b6 Vamos a ver con mayor detalle la forma en la que se aplican fuerzas e impulsos sobre los cuerpos del mundo. Fuerza y masa Siguiendo la segunda ley de Newton, la fuerza que se debe aplicar sobre un objeto para producir una determinada aceleraci\u00f3n se calcula de la siguiente forma: \\mathbf{f} = m\\mathbf{a} \\mathbf{f} = m\\mathbf{a} Sin embargo, en nuestro motor de f\u00edsicas lo que realmente nos interesa es conocer la aceleraci\u00f3n producida tras aplicar una fuerza, calculada como: \\mathbf{a} = \\frac{1}{m}\\mathbf{f} \\mathbf{a} = \\frac{1}{m}\\mathbf{f} Podemos ver que aqu\u00ed multiplicamos la fuerza por la inversa de la masa . Dado que este c\u00e1lculo es frecuente, para evitar tener que calcular la inversa en cada momento, normalmente los motores almacenan la masa inversa de los cuerpos, en lugar de almacenar la masa. Almacenar la masa inversa tiene una ventaja importante. Para hacer que un cuerpo sea est\u00e1tico (que no se vea afectado por las fuerzas que sobre \u00e9l se ejerzan) lo que haremos es dar a ese cuerpo masa infinita. Este valor infinito podr\u00eda crear dificultades en el c\u00f3digo, y la necesidad de tratar casos especiales. Si trabajamos \u00fanicamente con masa inversa, bastar\u00e1 con darle un valor 0 a la masa inversa para hacer el cuerpo est\u00e1tico. En el caso de Box2D en lugar de indicar la masa al crear una fixture indicamos su densidad (medida en \\frac{kg}{m^2} \\frac{kg}{m^2} ). En funci\u00f3n del tama\u00f1o de la forma y de su densidad la librer\u00eda calcular\u00e1 de forma autom\u00e1tica la masa. 1 fixtureDef . density = 1.0 ; Podemos modificar las propiedades de masa de un cuerpo con el m\u00e9todo SetMassData . 1 2 3 4 5 6 b2MassData md ; md . mass = 2.0 ; md . center = b2Vec ( 1.0 , 0.0 ); md . I = 1.0 ; body . SetMassData ( md ); De esta forma adem\u00e1s de la masa podremos especificar el centro de masas y el momento de inercia. El momento de inercia nos permitir\u00e1 indicar qu\u00e9 par de fuerzas ( torque ) deberemos ejercer para producir una determinada aceleraci\u00f3n angular, de la misma forma que la masa nos indica qu\u00e9 fuerza debemos ejercer para producir una determinada aceleraci\u00f3n lineal. Torque y momento de inercia El torque \\tau \\tau es a la aceleraci\u00f3n angular \\alpha \\alpha lo que la fuerza es a la aceleraci\u00f3n lineal. En este caso, en lugar de tener en cuenta \u00fanicamente la masa del objeto, deberemos tener en cuenta su momento de inercia I I , en el que no s\u00f3lo tenemos la masa, sino c\u00f3mo est\u00e1 repartida a lo largo del cuerpo, lo cual influir\u00e1 en c\u00f3mo las fuerzas afectar\u00e1n a la rotaci\u00f3n. \\tau = I \\alpha \\tau = I \\alpha Por ejemplo, si tenemos un objeto con forma de bast\u00f3n, habr\u00e1 que hacer menos fuerza para que gire alrededor de su eje principal que alrededor de otro eje. Por lo tanto, el momento de inercia no tendr\u00e1 siempre el mismo valor para un determinado objeto, sino que depender\u00e1 del eje de rotaci\u00f3n. El momento de inercia codifica c\u00f3mo est\u00e1 repartida la masa del objeto alrededor de su centro. Para simplificar, supongamos que nuestro cuerpo r\u00edgido est\u00e1 compuesto de n n part\u00edculas cada una de ellas con una determinada masa m_i m_i , y situada en una posici\u00f3n (x_i, y_i) (x_i, y_i) respecto al centro de masas del cuerpo. El momento de inercia se calcular\u00eda de la siguiente forma (medido en kg\u00b7m kg\u00b7m ): I = \\sum^{n}_{i=1} m_i \\sqrt{x_i^2 + y_i^2} I = \\sum^{n}_{i=1} m_i \\sqrt{x_i^2 + y_i^2} Es decir, este coeficiente no tiene en cuenta s\u00f3lo la masa, sino tambi\u00e9n lo alejada que est\u00e1 la masa respecto del centro del centro. De esta forma, har\u00e1 falta hacer m\u00e1s fuerza para girar un cuerpo cuando la distribuci\u00f3n de masa est\u00e9 alejada del centro. Box2D calcular\u00e1 de forma autom\u00e1tica tanto el centro de masas como el momento de inercia a partir de la densidad, forma y posici\u00f3n de cada fixture que compone un cuerpo, y normalmente no necesitaremos establecer estos datos de forma manual. Acumulador de fuerzas Normalmente sobre un cuerpo actuar\u00e1n varias fuerzas. Siguiendo el principio de D'Alembert, un conjunto de fuerzas F=\\{f_1, f_2, ... f_{|F|}\\} F=\\{f_1, f_2, ... f_{|F|}\\} actuando sobre un objeto pueden ser sustituidas por una \u00fanica fuerza calculada como la suma de las fuerzas de F F : f = \\sum^{|F|}_{i=1} f_i f = \\sum^{|F|}_{i=1} f_i Para ello, cada objeto contar\u00e1 con un acumulador de fuerzas f donde se ir\u00e1n sumando todas las fuerzas que act\u00faan sobre \u00e9l (gravedad, interacci\u00f3n con otros objetos, suelo, etc). Cuando llegue el momento de realizar la actualizaci\u00f3n de posici\u00f3n y velocidad, la aceleraci\u00f3n del objeto se calcular\u00e1 a partir de la fuerza que indique dicho acumulador f f . Poner a cero el acumulador. Una vez finalizado un paso de la simulaci\u00f3n deberemos poner a cero los acumuladores de fuerzas de cada objeto del mundo. Por este motivo Box2D tiene un m\u00e9todo clearForces que deberemos llamar antes de realizar cada paso de la simulaci\u00f3n. Deberemos llevar cuidado con la discretizaci\u00f3n del tiempo. Si una gran fuerza se aplica durante un periodo de tiempo muy breve (por ejemplo para disparar una bala), si la aceleraci\u00f3n producida se extiende a todo el delta time el incremento de velocidad producido puede ser desmesurado. Por este motivo, estas fuerzas que se aplican en un breve instante puntual de tiempo se tratar\u00e1n como impulsos . Aplicaci\u00f3n de fuerzas El caso m\u00e1s com\u00fan de fuerza aplicada a los objetos es la gravedad . Si queremos hacer una simulaci\u00f3n realista deber\u00edamos aplicar una fuerza que produzca una aceleraci\u00f3n de a_{gravedad}=-9.8 \\frac{m}{s^2} a_{gravedad}=-9.8 \\frac{m}{s^2} sobre nuestros objetos en el eje y y (normalmente se redondea en a_{gravedad}=10 a_{gravedad}=10 . Considerando el vector \\mathbf{a}_{gravedad} = (0, a_{gravedad}) \\mathbf{a}_{gravedad} = (0, a_{gravedad}) tenemos: \\mathbf{f}_{gravedad} = \\mathbf{a}_{gravedad}m \\mathbf{f}_{gravedad} = \\mathbf{a}_{gravedad}m Los cuerpos de Box2D tienen una propiedad gravityScale que nos permite aplicar una gravedad distinta a cada cuerpo. Podemos especificarlo al crear el cuerpo: 1 bodyDef . gravityScale = 5.0 ; Tambi\u00e9n se puede tratar como una fuerza la \"resistencia al aire\" ( damping ) que produce que los objetos vayan frenando y no se muevan indefinidamente. Un modelo simplificado para esta fuerza que se suele utilizar en videojuegos es el siguiente: \\mathbf{f}_{resistencia} = -\\mathbf{\\hat{v}}(k_{damping} |\\mathbf{v}| \\mathbf{f}_{resistencia} = -\\mathbf{\\hat{v}}(k_{damping} |\\mathbf{v}| Donde k_{damping} k_{damping} es la constante de damping especificada para el cuerpo, y \\mathbf{\\hat{v}} \\mathbf{\\hat{v}} el vector de velocidad normalizado (vector unitario con la direcci\u00f3n de la velocidad). Podemos ver que la fuerza act\u00faa en el sentido opuesto a la velocidad del objeto (lo frena), y con una magnitud proporcional a la velocidad. A parte de las fuerzas de gravedad, resistencia al aire, y las fuerzas ejercidas entre cuerpos en contacto, tambi\u00e9n podemos aplicar una fuerza manualmente sobre un determinado cuerpo. Para ello deberemos indicar el vector de fuerza y el punto del objeto donde se aplicar\u00e1 dicha fuerza: 1 body . ApplyForce ( b2Vec ( 5.0 , 2.0 ), body . GetPosition ()); Las unidades en las que especificaremos la fuerza son Newtons ( N = \\frac{kg\u00b7m}{s^2} N = \\frac{kg\u00b7m}{s^2} ). Si el punto del objeto al que aplicamos la fuerza no es su centro de masas, la fuerza producir\u00e1 adem\u00e1s que el objeto rote (a no ser que en su definici\u00f3n hayamos dado valor TRUE a su propiedad fixedRotation , que evitar\u00e1 que rote). Si nos interesa siempre aplicar la fuerza en el centro, podemos utilizar el m\u00e9todo: 1 body . ApplyForceToCenter ( b2Vec ( 5.0 , 2.0 )); Aplicaci\u00f3n de un par de fuerzas ( torque ) Podemos tambi\u00e9n aplicar un par de fuerzas ( torque ) para producir una rotaci\u00f3n del objeto alrededor de su centro de masas sin producir una traslaci\u00f3n: 1 body . ApplyTorque ( 2.0 ); El torque se indica en N\u00b7m N\u00b7m . Impulsos Los impulsos producen un cambio instant\u00e1neo en la velocidad de un objeto. Podemos ver los impulsos respecto a la velocidad como vemos a las fuerzas respecto a la aceleraci\u00f3n. Si aplicar una fuerza a un cuerpo produce una aceleraci\u00f3n, aplicar un impulso produce un cambio de velocidad. Una diferencia importante es que no puede haber aceleraci\u00f3n si no se aplica ninguna fuerza, mientras que si que puede haber velocidad si no se aplican impulsos, un impulso lo que provoca es un cambio en la velocidad. El impulso g g necesario para producir un cambio de velocidad \\Delta v \\Delta v ser\u00e1 proporcional a la masa del objeto: \\begin{equation} g = m\\Delta v \\end{equation} \\begin{equation} g = m\\Delta v \\end{equation} Al igual que en el caso de las fuerzas, el c\u00e1lculo que nos interesar\u00e1 realizar es la obtenci\u00f3n del cambio de velocidad a partir del impulso: \\begin{equation} \\Delta v = \\frac{1}{m}g \\end{equation} \\begin{equation} \\Delta v = \\frac{1}{m}g \\end{equation} Considerando \\Delta v = v' - v \\Delta v = v' - v , donde v v es la velocidad previa a la aplicaci\u00f3n del impulso, y v' v' es la velocidad resultante, tenemos: \\begin{equation} v' = v + \\frac{1}{m}g \\end{equation} \\begin{equation} v' = v + \\frac{1}{m}g \\end{equation} Aplicaci\u00f3n de impulsos En Box2D podremos aplicar un impulso sobre un punto de un cuerpo (al igual que en el caso de la fuerza) con: 1 body . ApplyImpulse ( b2Vec ( 5.0 , 2.0 , body . GetPosition ()); El impulso lineal se especifica en N\u00b7s N\u00b7s . Podemos tambi\u00e9n aplicar un impulso angular con: 1 body . ApplyAngularImpulse ( 2 . 0 ); Las unidades en este caso son N\u00b7m\u00b7s N\u00b7m\u00b7s (es decir, kg\\frac{m^2}{s} kg\\frac{m^2}{s} ). Velocidad Adem\u00e1s de aplicar fuerzas e impulsos sobre los cuerpos, tambi\u00e9n podemos consultar o modificar su velocidad con GetVelocity y SetVelocity . En el caso de la velocidad trabajaremos con \\frac{m}{s} \\frac{m}{s} . Esto puede ser \u00fatil en cuerpos de tipo kinematic , en los que las fuerzas nos tienen efecto (al tener masa infinita), pero que si que pueden mantener una velocidad constante, como por ejemplo un proyectil. 1 body . SetVelocity ( b2Vec ( 5.0 , 0.0 )); De la misma forma, tambi\u00e9n podemos consultar y modificar la velocidad angular con GetAngularVelocity y SetAngularVelocity respectivamente. En estos casos las unidades son \\frac{radianes}{s} \\frac{radianes}{s} . Posici\u00f3n Dado un cuerpo, cuyo centro de masas est\u00e1 posicionado en \\mathbf{p}_0 \\mathbf{p}_0 y con rotaci\u00f3n \\Theta \\Theta (matriz de rotaci\u00f3n), puede interesarnos determinar la posici\u00f3n de cualquier otro punto del objeto en el mundo. Supongamos que queremos conocer la posici\u00f3n de un punto cuyas coordenadas locales (respecto al centro de masas) son \\mathbf{p}_{local} \\mathbf{p}_{local} . La posici\u00f3n global de dicho punto vendr\u00e1 determinada por: \\mathbf{p}_{global} = \\Theta \\mathbf{p}_{local} + \\mathbf{p}_0 \\mathbf{p}_{global} = \\Theta \\mathbf{p}_{local} + \\mathbf{p}_0 Para simplificar este c\u00e1lculo, Box2D nos proporciona una serie de m\u00e9todos con los que podemos convertir entre coordenadas locales del objeto y coordenadas globales del mundo, teniendo en cuenta la posici\u00f3n o orientaci\u00f3n del objeto. Con GetWorldPoint podremos obtener las coordenadas globales a partir de la coordenadas locales del objeto, y con GetLocalPoint podremos hacer la transformaci\u00f3n inversa. 1 b2Vec globalPos = body -> GetWorldPoint ( b2Vec ( 0.0 , 1.0 )); Detecci\u00f3n de colisiones \u00b6 Hemos comentado que dentro de la simulaci\u00f3n f\u00edsica existen interacciones entre los diferentes objetos del mundo. Encontramos diferentes formas de consultar las colisiones de los objetos del mundo con otros objetos y otros elementos. Colisi\u00f3n con un punto del mundo Un test sencillo consiste en comprobar si la forma de una fixture ocupa un determinado punto del mundo. Esto es \u00fatil por ejemplo cuando tocamos sobre la pantalla t\u00e1ctil, para comprobar si en el punto sobre el que hemos pulsado hay un determinado objeto. Este m\u00e9todo se aplica sobre una fixture concreta: 1 2 3 4 5 b2Transfrom transform ; transform . SetIdentity (); b2Vec2 point ( touch_x / PTM_RATIO , touch_y / PTM_RATIO ); bool hit = fixture -> TestPoint ( transform , point ); Trazado de rayos Otro test disponible es el trazado de rayos. Consiste en lanzar un rayo desde una determinada posici\u00f3n del mundo en una determinada direcci\u00f3n y comprobar cu\u00e1l es el primer objeto del mundo f\u00edsico con el que impacta. Esto es especialmente \u00fatil para implementar por ejemplo los disparos de nuestro personaje. Al ser la bala un objeto extremadamente r\u00e1pido, no es conveniente simular su movimiento con el motor de f\u00edsicas, ya que podr\u00eda producirse el efecto conocido como tunneling , atravesando objetos al dar un gran salto en su posici\u00f3n de una iteraci\u00f3n a la siguiente. En este caso es mejor simplemente considerar la bala como algo instant\u00e1neo, y encontrar en el mismo momento en que se dispara el objeto con el que impactar\u00eda lanzando un rayo. Puede aplicarse para una fixture concreta para saber si el rayo impacta con ella: 1 2 3 4 5 6 7 8 9 10 11 b2RayCastInput input ; input . p1 . Set ( 0.0f , 0.0f , 0.0f ); // Punto inicial del rayo input . p2 . Set ( 1.0f , 0.0f , 0.0f ); // Punto final del rayo input . maxFraction = 1.0f ; b2RayCastOutput output ; bool hit = fixture -> RayCast ( & output , input , 0 ); if ( hit ) { b2Vec2 hitPoint = input . p1 + output . fraction * ( input . p2 \u2013 input . p1 ); b2Vec2 normal = output . normal ; } Como salida tenemos la siguiente informaci\u00f3n del punto de impacto: Fracci\u00f3n : Tomando como referencia el vector desde el punto inicial al final del rayo, nos indica por cu\u00e1nto debemos multiplicar dicho vector para encontrar el punto de impacto. Como entrada debemos especificar la fracci\u00f3n m\u00e1xima hasta la que vamos a buscar el impacto. Por ejemplo, si la fracci\u00f3n es 1.0 el punto de impacto coincidir\u00e1 con el punto final del rayo, mientras que si es 0.5 el impacto estar\u00eda justo a la mitad del vector del rayo. Normal : Nos indica la direcci\u00f3n normal de la superficie sobre la que ha impactado el rayo. De esta forma podremos saber si hemos impactado de lado o de frente, y as\u00ed aplicar distinto nivel de da\u00f1o en cada caso, o aplicar una fuerza al objeto en la direcci\u00f3n en la que haya recibido el impacto. Tambi\u00e9n podr\u00eda aplicarse sobre el mundo, para buscar la primera fixture con la que impacte. En este caso necesitaremos utilizar un objeto b2RayCastCallback para obtener la informaci\u00f3n del primer fixture con el que impacte y los datos del impacto. Colisiones entre cuerpos Podemos recibir notificaciones cada vez que se produzca un contacto entre objetos del mundo, para as\u00ed por ejemplo aumentar el da\u00f1o recibido. Podremos recibir notificaciones mediante un objeto que implemente la interfaz ContactListener . Esta interfaz nos forzar\u00e1 a definir los siguientes m\u00e9todos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MiContactListener : public b2ContactListener { public : MiContactListener (); ~ MiContactListener (); // Se produce un contacto entre dos cuerpos virtual void BeginContact ( b2Contact * contact ); // El contacto entre los cuerpos ha finalizado virtual void EndContact ( b2Contact * contact ); // Se ejecuta antes de resolver el contacto. // Podemos evitar que se procese virtual void PreSolve ( b2Contact * contact , const b2Manifold * oldManifold ); // Podemos obtener el impulso aplicado sobre los cuerpos en contacto virtual void PostSolve ( b2Contact * contact , const b2ContactImpulse * impulse ); }; Podemos obtener los cuerpos implicados en el contacto a partir del par\u00e1metro Contact . Tambi\u00e9n podemos obtener informaci\u00f3n sobre los puntos de contacto mediante la informaci\u00f3n proporcionada por WorldManifold : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void MiContactListener :: BeginContact ( b2Contact * contact ) { b2Body * bodyA = contact . fixtureA -> GetBody (); b2Body * bodyB = contact . fixtureB -> GetBody (); // Obtiene el punto de contacto b2WorldManifold worldManifold ; contact -> GetWorldManifold ( & worldManifold ); b2Vec2 point = worldManifold . points [ 0 ]; // Calcula la velocidad a la que se produce el impacto b2Vec2 vA = bodyA -> GetLinearVelocityFromWorldPoint ( point ); b2Vec2 vB = bodyB -> GetLinearVelocityFromWorldPoint ( point ); float32 vel = b2Dot ( vB - vA , worldManifold . normal ); ... } De esta forma, adem\u00e1s de detectar colisiones podemos tambi\u00e9n saber la velocidad a la que han chocado, para as\u00ed poder aplicar un diferente nivel de da\u00f1o seg\u00fan la fuerza del impacto. El objeto manifold nos da el conjunto de puntos que define el contacto. En el caso de la colisi\u00f3n de una esfera con una superficie siempre ser\u00e1 un \u00fanico punto, pero en el caso de una caja puede ocurrir que toda una cara de la caja colisione con la superficie. En este caso el manifold nos devoler\u00e1 los puntos de los extremos de la cara que colisiones con la superficie. Tambi\u00e9n podemos utilizar PostSolve para obtener el impulso ejercido sobre los cuerpos en contacto en cada instante: 1 2 3 4 5 6 7 8 void MiContactListener :: PostSolve ( b2Contact * contact , const b2ContactImpulse * impulse ) { b2Body * bodyA = contact . fixtureA -> GetBody (); b2Body * bodyB = contact . fixtureB -> GetBody (); float impulso = impulse -> GetNormalImpulses ()[ 0 ]; } Debemos tener en cuenta que BeginContact s\u00f3lo ser\u00e1 llamado una vez, al comienzo del contacto, mientras que PostSolve nos informa en cada iteraci\u00f3n de las fuerzas ejercidas entre los cuerpos en contacto para mantener uno en reposo sobre otro. Sensores En el punto anterior hemos visto c\u00f3mo detectar colisiones entre cuerpos que producen una respuesta (fuerza de reacci\u00f3n). En algunos casos nos interesa que en el motor de f\u00edsicas se detecten colisiones con un cuerpo, pero que no produzcan una respuesta en la simulaci\u00f3n f\u00edsica. Por ejemplo, podr\u00edamos tener una zona en la que al entrar alg\u00fan cuerpo queramos que se abra alguna puerta. Esto podemos conseguirlo mediante sensores. Podemos hacer que una fixture se comporte como sensor mediante su propiedad isSensor : 1 fixtureDef . isSensor = TRUE ; Al ser un sensor otros objetos atravesar\u00e1 esta fixture , pero podremos detectar las colisiones mediante los m\u00e9todos BeginContact y EndContact de una ContactListener . Controlador de personaje \u00b6 En un videojuego de plataformas debemos aplicar f\u00edsicas y control de colisiones a nuestro personaje para as\u00ed por ejemplo controlar el salto y las ca\u00eddas, y evitar que pueda atravesar muros o el suelo. Este control suele hacerse con f\u00edsicas simplificadas que aplican una gravedad al personaje y comprueban si entra en colisi\u00f3n con el suelo (parte inferior) o con muros (laterales). Sin embargo, podr\u00eda interesarnos delegar todo este control a un motor de f\u00edsicas como Box2D. Vamos a ver c\u00f3mo podr\u00edamos utilizar este motor para implementar un controlador de personaje. En primer lugar deberemos crear un cuerpo f\u00edsico para nuestro personaje y su geometr\u00eda de colisi\u00f3n. Podemos para ello utilizar una caja con las dimensiones de su nodo gr\u00e1fico ( m_playerSprite ). Es importante bloquear la rotaci\u00f3n del cuerpo f\u00edsico, ya que normalmente buscaremos que nuestro personaje est\u00e9 siempre de pie : 1 2 3 4 5 6 7 8 9 10 11 b2BodyDef bodyDef ; bodyDef . type = b2BodyType :: b2_dynamicBody ; bodyDef . fixedRotation = true ; b2PolygonShape shapeBoundingBox ; shapeBoundingBox . SetAsBox ( m_playerSprite -> getContentSize (). width / PTM_RATIO , m_playerSprite -> getContentSize (). height / PTM_RATIO ); m_body = world -> CreateBody ( & bodyDef ); b2Fixture * fixture = m_body -> CreateFixture ( & shapeBoundingBox , 1.0 ); fixture -> SetFriction ( 0.0f ); Adem\u00e1s de crear la geometr\u00eda de colisi\u00f3n del sprite , es importante saber cu\u00e1ndo estamos pisando suelo y cu\u00e1ndo estamos en el aire, para determinar as\u00ed si podemos saltar o no. Para ello podemos utilizar un sensor a\u00f1adido bajo los pies del personaje: 1 2 3 4 5 6 b2CircleShape shapeSensor ; shapeSensor . m_radius = GROUND_TEST_RADIUS ; shapeSensor . m_p = b2Vec2 ( 0 , - m_playerSprite -> getContentSize (). height * 0.5 / PTM_RATIO ); m_groundTest = m_body -> CreateFixture ( & shapeSensor , 1.0 ); m_groundTest -> SetSensor ( true ); Al marcar esta forma circular como sensor , no causar\u00e1 reacci\u00f3n de colisi\u00f3n con el suelo pero si que detectar\u00e1 cuando est\u00e1 solapado con \u00e9l. De esta forma podremos saber si estamos sobre una superficie o en el aire. Podemos comprobar las colisiones de nuestro cuerpo con el siguiente c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 bool checkGrounded () { b2ContactEdge * edge = m_body -> GetContactList (); while ( edge != NULL ) { if ( edge -> contact -> GetFixtureA () == m_groundTest || edge -> contact -> GetFixtureB () == m_groundTest ) { return true ; } edge = edge -> next ; } return false ; } Con este m\u00e9todo obtenemos todos los contactos existentes con el cuerpo de nuestro personaje, y filtramos s\u00f3lo aquellos que se producen con el sensor ( m_groundTest ). En caso de existir alguno, es que estamos pisando sobre alguna superficie. Podr\u00edamos implementar el salto aplicando una velocidad vertical ( m_jump ) y conservando la velocidad horizontal del personaje. Haremos esto s\u00f3lo cuando el personaje est\u00e9 sobre una superficie s\u00f3lida: 1 2 3 if ( checkGrounded ()) { m_body -> SetLinearVelocity ( b2Vec2 ( m_body -> GetLinearVelocity (). x , m_jump )); } Para mover el personaje a izquierda o derecha lo \u00fanico que deberemos hacer es establecer su velocidad en x a partir del valor del eje horizontal de mando, conservando su velocidad vertical (determinada por la fuerza de la gravedad): 1 2 m_body -> SetLinearVelocity ( b2Vec2 ( m_horizontalAxis * m_vel / PTM_RATIO , m_body -> GetLinearVelocity (). y )); Con esto ya tendremos nuestro sprite en movimiento utilizando el motor de f\u00edsicas. Ya s\u00f3lo quedar\u00eda controlar las animaciones de nuestro personaje, aunque esto ya no es responsabilidad del motor de f\u00edsicas. Por ejemplo, deberemos hacer que mire en la direcci\u00f3n en la que estemos moviendo el mando: 1 2 3 4 5 if ( m_horizontalAxis < 0 && ! m_playerSprite -> isFlippedX ()) { m_playerSprite -> setFlippedX ( true ); } else if ( m_horizontalAxis > 0 && m_playerSprite -> isFlippedX ()) { m_playerSprite -> setFlippedX ( false ); } Si queremos controlar la velocidad de la animaci\u00f3n de fotogramas en funci\u00f3n de la velocidad a la que estemos moviendo el personaje podemos a\u00f1adir una acci\u00f3n de tipo Speed : 1 2 3 Animate * actionAnimate = Animate :: create ( AnimationCache :: getInstance () -> getAnimation ( \"animAndar\" )); RepeatForever * actionRepeat = RepeatForever :: create ( actionAnimate ); m_actionAndar = Speed :: create ( actionRepeat , 1.0f ); Con esta acci\u00f3n podremos controlar la velocidad a la que se reproduce la animaci\u00f3n en cada momento con: 1 2 3 4 5 6 7 8 if ( fabsf ( m_horizontalAxis ) < 0.1 ) { // Paramos al personaje m_actionAndar -> setSpeed ( 0.0f ); m_playerSprite -> setSpriteFrame ( \"idle.png\" ); } else { // Establecemos la velocidad de la animaci\u00f3n m_actionAndar -> setSpeed ( fabsf ( m_horizontalAxis )); } Depuraci\u00f3n de las f\u00edsicas \u00b6 Dado que los cuerpos f\u00edsicos se tratan de forma independiente de los nodos gr\u00e1ficos, a veces resulta conveniente poder visualizar qu\u00e9 ocurre en el mundo f\u00edsico para poder depurar de forma correcta el comportamiento de las entidades de nuestro juego. El motor Box2D nos ofrece facilidades para hacer esto. La clase b2World ofrece la funcionalidad de \"dibujar\" los objetos del mundo f\u00edsico, como las formas de las fixtures , los AABB, o los centros de masas de los objetos. Para poder dibujar estos contenidos deberemos proporcionar a Box2D una clase que le indique c\u00f3mo dibujar cada elemento con nuestro motor gr\u00e1fico (en nuestro caso Cocos2d-x). Esta clase deber\u00e1 heredar de b2Draw , y deber\u00e1 implementar una serie de m\u00e9todos en los que indicaremos c\u00f3mo dibujar diferentes primitivas gr\u00e1ficas (c\u00edrculos, rect\u00e1ngulos, polil\u00edneas, etc). Afortunadamente, Cocos2d-x cuenta con el nodo de tipo DrawNode que nos facilitar\u00e1 dibujar dichas primitivas. A continuaci\u00f3n mostrarmos un ejemplo de implementaci\u00f3n de una clase que nos permita depurar la f\u00edsica de Box2D en Cocos2d-x: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class CocosDebugDraw : public b2Draw { float32 mRatio ; cocos2d :: DrawNode * mNode ; public : CocosDebugDraw (); CocosDebugDraw ( float32 ratio ); ~ CocosDebugDraw (); cocos2d :: Node * GetNode (); void Clear (); virtual void DrawPolygon ( const b2Vec2 * vertices , int vertexCount , const b2Color & color ); virtual void DrawSolidPolygon ( const b2Vec2 * vertices , int vertexCount , const b2Color & color ); virtual void DrawCircle ( const b2Vec2 & center , float32 radius , const b2Color & color ); virtual void DrawSolidCircle ( const b2Vec2 & center , float32 radius , const b2Vec2 & axis , const b2Color & color ); virtual void DrawSegment ( const b2Vec2 & p1 , const b2Vec2 & p2 , const b2Color & color ); virtual void DrawTransform ( const b2Transform & xf ); virtual void DrawPoint ( const b2Vec2 & p , float32 size , const b2Color & color ); virtual void DrawString ( int x , int y , const char * string , ...); virtual void DrawAABB ( b2AABB * aabb , const b2Color & color ); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 CocosDebugDraw :: CocosDebugDraw () : mRatio ( 1.0f ) { mNode = DrawNode :: create (); mNode -> retain (); } CocosDebugDraw :: CocosDebugDraw ( float32 ratio ) : mRatio ( ratio ) { mNode = DrawNode :: create (); mNode -> retain (); } CocosDebugDraw ::~ CocosDebugDraw () { mNode -> release (); } void CocosDebugDraw :: Clear () { mNode -> clear (); } Node * CocosDebugDraw :: GetNode () { return mNode ; } void CocosDebugDraw :: DrawPolygon ( const b2Vec2 * old_vertices , int vertexCount , const b2Color & color ) { Vec2 * vertices = new Vec2 [ vertexCount ]; for ( int i = 0 ; i < vertexCount ; i ++ ) { vertices [ i ] = Vec2 ( old_vertices [ i ]. x * mRatio , old_vertices [ i ]. y * mRatio ); } mNode -> drawPoly ( vertices , vertexCount , false , Color4F ( color . r , color . g , color . b , 1.0f )); delete [] vertices ; } void CocosDebugDraw :: DrawSolidPolygon ( const b2Vec2 * old_vertices , int vertexCount , const b2Color & color ) { Vec2 * vertices = new Vec2 [ vertexCount ]; for ( int i = 0 ; i < vertexCount ; i ++ ) { vertices [ i ] = Vec2 ( old_vertices [ i ]. x * mRatio , old_vertices [ i ]. y * mRatio ); } mNode -> drawSolidPoly ( vertices , vertexCount , Color4F ( color . r , color . g , color . b , 1.0f )); delete [] vertices ; } void CocosDebugDraw :: DrawCircle ( const b2Vec2 & center , float32 radius , const b2Color & color ) { mNode -> drawCircle ( Vec2 ( center . x * mRatio , center . y * mRatio ), radius * mRatio , 0.0f , 16.0f , false , 1.0f , 1.0f , Color4F ( color . r , color . g , color . b , 1.0f )); } void CocosDebugDraw :: DrawSolidCircle ( const b2Vec2 & center , float32 radius , const b2Vec2 & axis , const b2Color & color ) { mNode -> drawSolidCircle ( Vec2 ( center . x * mRatio , center . y * mRatio ), radius * mRatio , 0.0f , 16.0f , 1.0f , 1.0f , Color4F ( color . r , color . g , color . b , 1.0f )); } void CocosDebugDraw :: DrawSegment ( const b2Vec2 & p1 , const b2Vec2 & p2 , const b2Color & color ) { mNode -> drawSegment ( Vec2 ( p1 . x * mRatio , p1 . y * mRatio ), Vec2 ( p2 . x * mRatio , p2 . y * mRatio ), 1.0f , Color4F ( color . r , color . g , color . b , 1.0f )); } void CocosDebugDraw :: DrawTransform ( const b2Transform & xf ) { b2Vec2 p1 = xf . p , p2 ; const float32 k_axisScale = 0.4f ; p2 = p1 + k_axisScale * xf . q . GetXAxis (); DrawSegment ( p1 , p2 , b2Color ( 1 , 0 , 0 )); p2 = p1 + k_axisScale * xf . q . GetYAxis (); DrawSegment ( p1 , p2 , b2Color ( 0 , 1 , 0 )); } void CocosDebugDraw :: DrawPoint ( const b2Vec2 & p , float32 size , const b2Color & color ) { mNode -> drawPoint ( Vec2 ( p . x * mRatio , p . y * mRatio ), size * mRatio , Color4F ( color . r , color . g , color . b , 1.0f )); } void CocosDebugDraw :: DrawString ( int x , int y , const char * string , ...) { // No soportado } void CocosDebugDraw :: DrawAABB ( b2AABB * aabb , const b2Color & color ) { mNode -> drawRect ( Vec2 ( aabb -> lowerBound . x * mRatio , aabb -> lowerBound . y * mRatio ), Vec2 ( aabb -> upperBound . x * mRatio , aabb -> upperBound . y * mRatio ), Color4F ( color . r , color . g , color . b , 1.0f )); } Una vez definida dicha clase, la a\u00f1adiremos al mundo f\u00edsico ( b2World ): 1 2 3 4 m_world = new b2World ( b2Vec2 ( 0 , - 10 )); m_debugDraw = new CocosDebugDraw ( PTM_RATIO ); m_world -> SetDebugDraw ( m_debugDraw ); Ser\u00e1 importante tras esto indicar qu\u00e9 tipos de elementos del motor f\u00edsico queremos que se muestre en la capa de depuraci\u00f3n: 1 2 3 4 5 6 7 8 uint32 flags = 0 ; flags += b2Draw :: e_shapeBit ; flags += b2Draw :: e_jointBit ; flags += b2Draw :: e_aabbBit ; flags += b2Draw :: e_pairBit ; flags += b2Draw :: e_centerOfMassBit ; m_debugDraw -> SetFlags ( flags ); Tras esto, a\u00f1adiremos el nodo de depuraci\u00f3n a nuestra escena. Haremos que quede por delante del resto de capas: 1 m_node -> addChild ( m_debugDraw -> GetNode (), 9999 ); Lo \u00faltimo que deberemos hacer es que en cada iteraci\u00f3n, tras actualizar el estado del mundo f\u00edsico, redibujaremos la capa de depuraci\u00f3n: 1 2 3 4 5 6 7 8 9 void Mundo :: update ( float delta ){ m_world -> ClearForces (); m_world -> Step ( 1.0f / 60.0f , 6 , 2 ); m_debugDraw -> Clear (); m_world -> DrawDebugData (); // ... } Gesti\u00f3n de f\u00edsicas con PhysicsEditor \u00b6 Hasta ahora hemos visto que es sencillo crear con Box 2D formas rectangulares y circulares, pero si tenemos objetos m\u00e1s complejos la tarea se complicar\u00e1 notablemente. Tendremos que definir la forma del objeto mediante un pol\u00edgono, pero definir este pol\u00edgono en c\u00f3digo es una tarea altamente tediosa. Podemos hacer esto de forma bastante m\u00e1s sencilla con herramientas como Physics Editor . Se trata de una aplicaci\u00f3n de pago, pero podemos obtener de forma gratuita una versi\u00f3n limitada. La aplicaci\u00f3n puede descargarse de: 1 http : // www . codeandweb . com / physicseditor Con esta herramienta podremos abrir determinados sprites , y obtener de forma autom\u00e1tica su contorno. Cuenta con una herramienta similar a la \"varita m\u00e1gica\" de Photoshop, con la que podremos hacer que sea la propia aplicaci\u00f3n la que determine el contorno de nuestros sprites . A continuaci\u00f3n vemos el entorno de la herramienta con el contorno que ha detectado autom\u00e1ticamente para nuestro sprite : En el lateral derecho podemos seleccionar el formato en el que queremos exportar el contorno detectado. En nuestro caso utilizaremos el formato de Box 2D gen\u00e9rico (se exporta como plist ). Tambi\u00e9n debemos especificar el ratio de p\u00edxeles a metros que queremos utilizar en nuestra aplicaci\u00f3n ( PTM-Ratio ). En dicho panel tambi\u00e9n podemos establecer una serie de propiedades de la forma ( fixture ) que estamos definiendo (densidad, fricci\u00f3n, etc). Una vez establecidos los datos anteriores podemos exportar el contorno del objeto pulsando el bot\u00f3n Publish . Con esto generaremos un fichero plist que podremos importar desde nuestro juego Cocos2D. Para ello necesitaremos a\u00f1adir la clase GB2ShapeCache a nuestro proyecto. Esta clase viene incluida en el instalador de Physics Editor (tenemos tanto versi\u00f3n para Cocos2D como para Cocos2D-X). Para utilizar las formas definidas primero deberemos cargar el contenido del fichero plist en la cach\u00e9 de formas mediante la clase anterior: 1 2 3 4 5 #include \"GB2ShapeCache-x.h\" ... GB2ShapeCache :: sharedGB2ShapeCache () -> addShapesWithFile ( \"formas.plist\" ); Una vez cargadas las formas en la cach\u00e9, podremos asignar las propiedades de las fixtures definidas a nuestros objetos de Box2D: 1 2 3 b2Body * body = ... // Inicializar body GB2ShapeCache :: sharedGB2ShapeCache () -> addFixturesToBody ( body , \"roca\" ); Referencias \u00b6 (Gamasutra) How to create 2D Physics Games with Box2D library","title":"Box2D"},{"location":"box2d.html#motores-de-fisicas","text":"Un tipo de juegos que ha tenido una gran proliferaci\u00f3n en el mercado de aplicaciones para m\u00f3viles son aquellos juegos basados en f\u00edsicas. Estos juegos son aquellos en los que el motor realiza una simulaci\u00f3n f\u00edsica de los objetos en pantalla, siguiendo las leyes de la cinem\u00e1tica y la din\u00e1mica. Es decir, los objetos de la pantalla est\u00e1n sujetos a gravedad, cada uno de ellos tiene una masa, y cuando se produce una colisi\u00f3n entre ellos se produce una fuerza de reacci\u00f3n que depender\u00e1 de su velocidad y su masa. El motor de f\u00edsicas se encarga de realizar toda esta simulaci\u00f3n, y nosotros s\u00f3lo deberemos encargarnos de proporcionar las propiedades de los objetos del mundo. Uno de los motores f\u00edsicos m\u00e1s utilizados es Box2D, originalmente implementado en C++. Se ha utilizado para implementar juegos tan conocidos y exitosos como Angry Birds. Podemos encontrar ports de este motor para las distintas plataformas m\u00f3viles. Motores como Cocos2D, libgdx y Unity incluyen una implementaci\u00f3n de este motor de f\u00edsicas.","title":"Motores de f\u00edsicas"},{"location":"box2d.html#motor-de-fisicas-box2d","text":"Vamos ahora a estudiar el motor de f\u00edsicas Box2D. Es importante destacar que este motor s\u00f3lo se encargar\u00e1 de simular la f\u00edsica de los objetos, no de dibujarlos. Ser\u00e1 nuestra responsabilidad mostrar los objetos en la escena de forma adecuada seg\u00fan los datos obtenidos de la simulaci\u00f3n f\u00edsica. Comenzaremos viendo los principales componentes de esta librer\u00eda.","title":"Motor de f\u00edsicas Box2D"},{"location":"box2d.html#componentes-de-box2d","text":"Los componentes b\u00e1sicos que nos permiten realizar la simulaci\u00f3n f\u00edsica con Box2D son: Body : Representa un cuerpo r\u00edgido. Estos son los tipos de objetos que tendremos en el mundo 2D simulado. Cada cuerpo tendr\u00e1 una posici\u00f3n y velocidad. Los cuerpos se ver\u00e1n afectados por la gravedad del mundo, y por la interacci\u00f3n con los otros cuerpos. Cada cuerpo tendr\u00e1 una serie de propiedades f\u00edsicas, como su masa o su centro de gravedad. Fixture : Es el objeto que se encarga de fijar las propiedades de un cuerpo, como su forma, coeficiente de rozamiento o densidad. Un cuerpo podr\u00eda contener varias fixtures , para as\u00ed poder crear formas m\u00e1s complejas combinando formas b\u00e1sicas. Shape : Sirve para especificar la forma de una fixture . Hay distintos tipos de formas (subclases de Shape ), como por ejemplo CircleShape y PolygonShape , para crear cuerpos con formar circulares o poligonales respectivamente. Constraint : Nos permite limitar la libertad de un cuerpo. Por ejemplo podemos utilizar una restricci\u00f3n que impida que el cuerpo pueda rotar, o para que se mueva siguiendo s\u00f3lo una l\u00ednea (por ejemplo un objeto montado en un rail). Joint : Nos permite definir uniones entre diferentes cuerpos. World : Representa el mundo 2D en el que tendr\u00e1 lugar la simulaci\u00f3n. Podemos a\u00f1adir una serie de cuerpos al mundo. Una de las principales propiedades del mundo es la gravedad. Todas las clases de la librer\u00eda Box 2D tienen el prefijo b2 . Hay que tener en cuenta que se trata de clases C++, y no Objective-C. Lo primero que deberemos hacer es crear el mundo en el que se realizar\u00e1 la simulaci\u00f3n f\u00edsica. Como par\u00e1metro deberemos proporcionar un vector 2D con la gravedad del mundo: 1 2 3 b2Vec2 gravity ; gravity . Set ( 0 , - 10 ); b2World * world = new b2World ( gravity );","title":"Componentes de Box2D"},{"location":"box2d.html#unidades-de-medida","text":"Antes de crear cuerpos en el mundo, debemos entender el sistema de coordenadas de Box2D y sus unidades de medida. Los objetos de Box2D se miden en metros, y la librer\u00eda est\u00e1 optimizada para objetos de 1m, por lo que deberemos hacer que los objetos que aparezcan con m\u00e1s frecuencia tengan esta medida. Sin embargo, los gr\u00e1ficos en pantalla se miden en p\u00edxeles (o puntos). Deberemos por lo tanto fijar el ratio de conversi\u00f3n entre pixeles y metros. Por ejemplo, si los objetos con los que trabajamos normalmente miden 32 pixeles, haremos que 32 pixeles equivalgan a un metro. Definimos el siguiente ratio de conversi\u00f3n: 1 const float PTM_RATIO = 32.0 ; Para todas las unidades de medida Box2D utiliza el sistema m\u00e9trico. Por ejemplo, para la masa de los objetos utiliza Kg.","title":"Unidades de medida"},{"location":"box2d.html#tipos-de-cuerpos","text":"Encontramos tres tipos diferentes de cuerpos en Box2D seg\u00fan la forma en la que queremos que se realice la simulaci\u00f3n con ellos: Din\u00e1micos : Est\u00e1n sometidos a las leyes f\u00edsicas, y tienen una masa concreta y finita. Estos cuerpos se ven afectados por la gravedad y por la interacci\u00f3n con los dem\u00e1s cuerpos. Est\u00e1ticos : Son cuerpos que permanecen siempre en la misma posici\u00f3n. Equivalen a cuerpos con masa infinita. Por ejemplo, podemos hacer que el escenario sea est\u00e1tico. Es importante no mover aquellos cuerpos que hayan sido marcados como est\u00e1ticos, ya que el motor podr\u00eda no responder de forma correcta. Cinem\u00e1ticos : Al igual que los cuerpos est\u00e1ticos tienen masa infinita y no se ven afectados por otros cuerpos ni por la gravedad. Sin embargo, en esta caso no tienen una posici\u00f3n fija, sino que podemos moverlos por el mundo. Nos son \u00fatiles por ejemplo para proyectiles.","title":"Tipos de cuerpos"},{"location":"box2d.html#creacion-de-cuerpos","text":"Con todo lo visto anteriormente ya podemos crear distintos cuerpos. Para crear un cuerpo primero debemos crear un objeto de tipo BodyDef con las propiedades del cuerpo a crear, como por ejemplo su posici\u00f3n en el mundo, su velocidad, o su tipo. Una vez hecho esto, crearemos el cuerpo a partir del mundo ( World ) y de la definici\u00f3n del cuerpo que acabamos de crear. Una vez creado el cuerpo, podremos asignarle una forma y densidad mediante fixtures . Por ejemplo, en el siguiente caso creamos un cuerpo din\u00e1mico con forma rectangular: 1 2 3 4 5 6 7 8 9 10 b2BodyDef bodyDef ; bodyDef . type = b2_dynamicBody ; bodyDef . position . Set ( x / PTM_RATIO , y / PTM_RATIO ); b2Body * body = world -> CreateBody ( & bodyDef ); b2PolygonShape bodyShape ; bodyShape . SetAsBox (( width / 2 ) / PTM_RATIO , ( height / 2 ) / PTM_RATIO ); body -> CreateFixture ( & bodyShape , 1.0f ); En este caso hemos creado un cuerpo con una \u00fanica fixture con forma de caja y densidad 1.0 \\frac{kg}{m^2} \\frac{kg}{m^2} . La masa del cuerpo sera calculada de forma autom\u00e1tica a partir de la forma y densidad de sus fixtures . De forma similar podemos tambi\u00e9n crear un cuerpo din\u00e1mico de forma circular con: 1 2 3 4 5 6 7 8 9 10 b2BodyDef bodyDef ; bodyDef . type = b2_dynamicBody ; bodyDef . position . Set ( x / PTM_RATIO , y / PTM_RATIO ); b2Body * body = world -> CreateBody ( & bodyDef ); b2CircleShape bodyShape ; bodyShape . m_radius = radius / PTM_RATIO ; b2Fixture * bodyFixture = body -> CreateFixture ( & bodyShape , 1.0f ); Para definir los l\u00edmites del escenario utilizaremos un cuerpo de tipo est\u00e1tico compuesto de varias fixtures con forma de arista ( edge ). En este caso en lugar de utilizar el atajo CreateFixture(shape, density) de los ejemplos anteriores utilizaremos la versi\u00f3n CreateFixture(fixtureDef) que crea la fixture a partir de las propiedades definidas en una estructura de tipo b2FixtureDef , lo cual nos dar\u00e1 mayor flexibilidad: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 b2BodyDef limitesBodyDef ; limitesBodyDef . position . Set ( x , y ); b2Body * limitesBody = world -> CreateBody ( & limitesBodyDef ); b2EdgeShape limitesShape ; b2FixtureDef fixtureDef ; fixtureDef . shape = & limitesShape ; limitesShape . Set ( b2Vec2 ( 0.0f / PTM_RATIO , 0.0f / PTM_RATIO ), b2Vec2 ( width / PTM_RATIO , 0.0f / PTM_RATIO )); limitesBody -> CreateFixture ( & fixtureDef ); limitesShape . Set ( b2Vec2 ( width / PTM_RATIO , 0.0f / PTM_RATIO ), b2Vec2 ( width / PTM_RATIO , height / PTM_RATIO )); limitesBody -> CreateFixture ( & fixtureDef ); limitesShape . Set ( b2Vec2 ( width / PTM_RATIO , height / PTM_RATIO ), b2Vec2 ( 0.0f / PTM_RATIO , height / PTM_RATIO )); limitesBody -> CreateFixture ( & fixtureDef ); limitesShape . Set ( b2Vec2 ( 0.0f / PTM_RATIO , height / PTM_RATIO ), b2Vec2 ( 0.0f / PTM_RATIO , 0.0f / PTM_RATIO )); limitesBody -> CreateFixture ( & fixtureDef ); En este \u00faltimo caso vemos que no hemos indicado ni el tipo de cuerpo ni la masa. Si no indicamos nada por defecto el cuerpo ser\u00e1 est\u00e1tico y su masa ser\u00e1 infinita. En la propiedad type de la estructura b2BodyDef podemos especificar de forma expl\u00edcita el tipo de cuerpo que queremos crear, que puede ser: b2_staticBody : Cuerpo est\u00e1tico (valor por defecto). Podemos moverlos manualmente, pero el motor no los mueve. b2_kinematicBody : Cuerpo cinem\u00e1tica. Podemos darle una velocidad pero las fuerzas no tienen efecto sobre \u00e9l. b2_dinamicBody : Cuerpo din\u00e1mico. Sometido totalmente a simulaci\u00f3n f\u00edsica. Los cuerpos tienen adem\u00e1s una propiedad userData que nos permite vincular cualquier objeto con el cuerpo. Por ejemplo, podr\u00edamos vincular a un cuerpo f\u00edsico el Sprite que queremos utilizar para mostrarlo en pantalla: 1 bodyDef . userData = sprite ; De esta forma, cuando realicemos la simulaci\u00f3n podemos obtener el sprite vinculado al cuerpo f\u00edsico y mostrarlo en pantalla en la posici\u00f3n que corresponda.","title":"Creaci\u00f3n de cuerpos"},{"location":"box2d.html#simulacion","text":"Ya hemos visto c\u00f3mo crear el mundo 2D y los cuerpos r\u00edgidos. Vamos a ver ahora c\u00f3mo realizar la simulaci\u00f3n f\u00edsica dentro de este mundo. Para realizar la simulaci\u00f3n deberemos llamar al m\u00e9todo step sobre el mundo, proporcionando el delta time transcurrido desde la \u00faltima actualizaci\u00f3n del mismo: 1 2 world -> Step ( delta , 6 , 2 ); world -> ClearForces (); Recomendaci\u00f3n : Conviene utilizar un delta time fijo para el motor de f\u00edsicas, para as\u00ed obtener resultados predecibles en la simulaci\u00f3n (por ejemplo 60 fps). Si el frame rate del render es distinto podemos interpolar las posiciones. Adem\u00e1s, los algoritmos de simulaci\u00f3n f\u00edsica son iterativos. Con cada iteraci\u00f3n se busca resolver las colisiones y restricciones de los objetos del mundo para aproximar su posici\u00f3n y velocidad. Cuantas m\u00e1s iteraciones se realicen mayor precisi\u00f3n se obtendr\u00e1 en los resultados, pero mayor coste tendr\u00e1n. El segundo y el tercer par\u00e1metro de step nos permiten establecer el n\u00famero de veces que debe iterar el algoritmo para resolver la posici\u00f3n y la velocidad de los cuerpos respectivamente. Tras hacer la simulaci\u00f3n, deberemos limpiar las fuerzas acumuladas sobre los objetos, para que no se arrastren estos resultados a pr\u00f3ximas simulaciones. Recomendaci\u00f3n : Un valor recomendable para las iteraciones de posici\u00f3n y velocidad es 8 y 3 respectivamente. Tras hacer la simulaci\u00f3n deberemos actualizar las posiciones de los sprites en pantalla y mostrarlos. Por ejemplo, si hemos vinculado el Sprite al cuerpo mediante la propiedad userData , podemos recuperarlo y actualizarlo de la siguiente forma: 1 2 3 4 5 6 Sprite * sprite = ( Sprite * ) body -> GetUserData (); b2Vec2 pos = body -> GetPosition (); float rot = - 1 * CC_RADIANS_TO_DEGREES ( b -> GetAngle ()); sprite -> setPosition ( Vec2 ( pos . x * PTM_RATIO , pos . y * PTM_RATIO )); sprite -> setRotation ( rot );","title":"Simulaci\u00f3n"},{"location":"box2d.html#formas-de-los-objetos","text":"Hemos visto que mediante fixtures podemos asignar diferentes formas a los objetos del mundo, como c\u00edrculos, pol\u00edgonos y aristas.","title":"Formas de los objetos"},{"location":"box2d.html#propiedades-de-los-cuerpos","text":"Los cuerpos y fixtures tienen una serie de propiedades que nos permiten definir su comportamiento en la simulaci\u00f3n f\u00edsica. Hemos visto algunas b\u00e1sicas como la masa y la forma, que se indican en el momento de crear una fixture . Vamos a ver ahora otras propiedades f\u00edsicas de los objetos.","title":"Propiedades de los cuerpos"},{"location":"box2d.html#dinamica-de-cuerpos-rigidos","text":"Vamos a ver con mayor detalle la forma en la que se aplican fuerzas e impulsos sobre los cuerpos del mundo.","title":"Din\u00e1mica de cuerpos r\u00edgidos"},{"location":"box2d.html#deteccion-de-colisiones","text":"Hemos comentado que dentro de la simulaci\u00f3n f\u00edsica existen interacciones entre los diferentes objetos del mundo. Encontramos diferentes formas de consultar las colisiones de los objetos del mundo con otros objetos y otros elementos.","title":"Detecci\u00f3n de colisiones"},{"location":"box2d.html#controlador-de-personaje","text":"En un videojuego de plataformas debemos aplicar f\u00edsicas y control de colisiones a nuestro personaje para as\u00ed por ejemplo controlar el salto y las ca\u00eddas, y evitar que pueda atravesar muros o el suelo. Este control suele hacerse con f\u00edsicas simplificadas que aplican una gravedad al personaje y comprueban si entra en colisi\u00f3n con el suelo (parte inferior) o con muros (laterales). Sin embargo, podr\u00eda interesarnos delegar todo este control a un motor de f\u00edsicas como Box2D. Vamos a ver c\u00f3mo podr\u00edamos utilizar este motor para implementar un controlador de personaje. En primer lugar deberemos crear un cuerpo f\u00edsico para nuestro personaje y su geometr\u00eda de colisi\u00f3n. Podemos para ello utilizar una caja con las dimensiones de su nodo gr\u00e1fico ( m_playerSprite ). Es importante bloquear la rotaci\u00f3n del cuerpo f\u00edsico, ya que normalmente buscaremos que nuestro personaje est\u00e9 siempre de pie : 1 2 3 4 5 6 7 8 9 10 11 b2BodyDef bodyDef ; bodyDef . type = b2BodyType :: b2_dynamicBody ; bodyDef . fixedRotation = true ; b2PolygonShape shapeBoundingBox ; shapeBoundingBox . SetAsBox ( m_playerSprite -> getContentSize (). width / PTM_RATIO , m_playerSprite -> getContentSize (). height / PTM_RATIO ); m_body = world -> CreateBody ( & bodyDef ); b2Fixture * fixture = m_body -> CreateFixture ( & shapeBoundingBox , 1.0 ); fixture -> SetFriction ( 0.0f ); Adem\u00e1s de crear la geometr\u00eda de colisi\u00f3n del sprite , es importante saber cu\u00e1ndo estamos pisando suelo y cu\u00e1ndo estamos en el aire, para determinar as\u00ed si podemos saltar o no. Para ello podemos utilizar un sensor a\u00f1adido bajo los pies del personaje: 1 2 3 4 5 6 b2CircleShape shapeSensor ; shapeSensor . m_radius = GROUND_TEST_RADIUS ; shapeSensor . m_p = b2Vec2 ( 0 , - m_playerSprite -> getContentSize (). height * 0.5 / PTM_RATIO ); m_groundTest = m_body -> CreateFixture ( & shapeSensor , 1.0 ); m_groundTest -> SetSensor ( true ); Al marcar esta forma circular como sensor , no causar\u00e1 reacci\u00f3n de colisi\u00f3n con el suelo pero si que detectar\u00e1 cuando est\u00e1 solapado con \u00e9l. De esta forma podremos saber si estamos sobre una superficie o en el aire. Podemos comprobar las colisiones de nuestro cuerpo con el siguiente c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 bool checkGrounded () { b2ContactEdge * edge = m_body -> GetContactList (); while ( edge != NULL ) { if ( edge -> contact -> GetFixtureA () == m_groundTest || edge -> contact -> GetFixtureB () == m_groundTest ) { return true ; } edge = edge -> next ; } return false ; } Con este m\u00e9todo obtenemos todos los contactos existentes con el cuerpo de nuestro personaje, y filtramos s\u00f3lo aquellos que se producen con el sensor ( m_groundTest ). En caso de existir alguno, es que estamos pisando sobre alguna superficie. Podr\u00edamos implementar el salto aplicando una velocidad vertical ( m_jump ) y conservando la velocidad horizontal del personaje. Haremos esto s\u00f3lo cuando el personaje est\u00e9 sobre una superficie s\u00f3lida: 1 2 3 if ( checkGrounded ()) { m_body -> SetLinearVelocity ( b2Vec2 ( m_body -> GetLinearVelocity (). x , m_jump )); } Para mover el personaje a izquierda o derecha lo \u00fanico que deberemos hacer es establecer su velocidad en x a partir del valor del eje horizontal de mando, conservando su velocidad vertical (determinada por la fuerza de la gravedad): 1 2 m_body -> SetLinearVelocity ( b2Vec2 ( m_horizontalAxis * m_vel / PTM_RATIO , m_body -> GetLinearVelocity (). y )); Con esto ya tendremos nuestro sprite en movimiento utilizando el motor de f\u00edsicas. Ya s\u00f3lo quedar\u00eda controlar las animaciones de nuestro personaje, aunque esto ya no es responsabilidad del motor de f\u00edsicas. Por ejemplo, deberemos hacer que mire en la direcci\u00f3n en la que estemos moviendo el mando: 1 2 3 4 5 if ( m_horizontalAxis < 0 && ! m_playerSprite -> isFlippedX ()) { m_playerSprite -> setFlippedX ( true ); } else if ( m_horizontalAxis > 0 && m_playerSprite -> isFlippedX ()) { m_playerSprite -> setFlippedX ( false ); } Si queremos controlar la velocidad de la animaci\u00f3n de fotogramas en funci\u00f3n de la velocidad a la que estemos moviendo el personaje podemos a\u00f1adir una acci\u00f3n de tipo Speed : 1 2 3 Animate * actionAnimate = Animate :: create ( AnimationCache :: getInstance () -> getAnimation ( \"animAndar\" )); RepeatForever * actionRepeat = RepeatForever :: create ( actionAnimate ); m_actionAndar = Speed :: create ( actionRepeat , 1.0f ); Con esta acci\u00f3n podremos controlar la velocidad a la que se reproduce la animaci\u00f3n en cada momento con: 1 2 3 4 5 6 7 8 if ( fabsf ( m_horizontalAxis ) < 0.1 ) { // Paramos al personaje m_actionAndar -> setSpeed ( 0.0f ); m_playerSprite -> setSpriteFrame ( \"idle.png\" ); } else { // Establecemos la velocidad de la animaci\u00f3n m_actionAndar -> setSpeed ( fabsf ( m_horizontalAxis )); }","title":"Controlador de personaje"},{"location":"box2d.html#depuracion-de-las-fisicas","text":"Dado que los cuerpos f\u00edsicos se tratan de forma independiente de los nodos gr\u00e1ficos, a veces resulta conveniente poder visualizar qu\u00e9 ocurre en el mundo f\u00edsico para poder depurar de forma correcta el comportamiento de las entidades de nuestro juego. El motor Box2D nos ofrece facilidades para hacer esto. La clase b2World ofrece la funcionalidad de \"dibujar\" los objetos del mundo f\u00edsico, como las formas de las fixtures , los AABB, o los centros de masas de los objetos. Para poder dibujar estos contenidos deberemos proporcionar a Box2D una clase que le indique c\u00f3mo dibujar cada elemento con nuestro motor gr\u00e1fico (en nuestro caso Cocos2d-x). Esta clase deber\u00e1 heredar de b2Draw , y deber\u00e1 implementar una serie de m\u00e9todos en los que indicaremos c\u00f3mo dibujar diferentes primitivas gr\u00e1ficas (c\u00edrculos, rect\u00e1ngulos, polil\u00edneas, etc). Afortunadamente, Cocos2d-x cuenta con el nodo de tipo DrawNode que nos facilitar\u00e1 dibujar dichas primitivas. A continuaci\u00f3n mostrarmos un ejemplo de implementaci\u00f3n de una clase que nos permita depurar la f\u00edsica de Box2D en Cocos2d-x: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class CocosDebugDraw : public b2Draw { float32 mRatio ; cocos2d :: DrawNode * mNode ; public : CocosDebugDraw (); CocosDebugDraw ( float32 ratio ); ~ CocosDebugDraw (); cocos2d :: Node * GetNode (); void Clear (); virtual void DrawPolygon ( const b2Vec2 * vertices , int vertexCount , const b2Color & color ); virtual void DrawSolidPolygon ( const b2Vec2 * vertices , int vertexCount , const b2Color & color ); virtual void DrawCircle ( const b2Vec2 & center , float32 radius , const b2Color & color ); virtual void DrawSolidCircle ( const b2Vec2 & center , float32 radius , const b2Vec2 & axis , const b2Color & color ); virtual void DrawSegment ( const b2Vec2 & p1 , const b2Vec2 & p2 , const b2Color & color ); virtual void DrawTransform ( const b2Transform & xf ); virtual void DrawPoint ( const b2Vec2 & p , float32 size , const b2Color & color ); virtual void DrawString ( int x , int y , const char * string , ...); virtual void DrawAABB ( b2AABB * aabb , const b2Color & color ); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 CocosDebugDraw :: CocosDebugDraw () : mRatio ( 1.0f ) { mNode = DrawNode :: create (); mNode -> retain (); } CocosDebugDraw :: CocosDebugDraw ( float32 ratio ) : mRatio ( ratio ) { mNode = DrawNode :: create (); mNode -> retain (); } CocosDebugDraw ::~ CocosDebugDraw () { mNode -> release (); } void CocosDebugDraw :: Clear () { mNode -> clear (); } Node * CocosDebugDraw :: GetNode () { return mNode ; } void CocosDebugDraw :: DrawPolygon ( const b2Vec2 * old_vertices , int vertexCount , const b2Color & color ) { Vec2 * vertices = new Vec2 [ vertexCount ]; for ( int i = 0 ; i < vertexCount ; i ++ ) { vertices [ i ] = Vec2 ( old_vertices [ i ]. x * mRatio , old_vertices [ i ]. y * mRatio ); } mNode -> drawPoly ( vertices , vertexCount , false , Color4F ( color . r , color . g , color . b , 1.0f )); delete [] vertices ; } void CocosDebugDraw :: DrawSolidPolygon ( const b2Vec2 * old_vertices , int vertexCount , const b2Color & color ) { Vec2 * vertices = new Vec2 [ vertexCount ]; for ( int i = 0 ; i < vertexCount ; i ++ ) { vertices [ i ] = Vec2 ( old_vertices [ i ]. x * mRatio , old_vertices [ i ]. y * mRatio ); } mNode -> drawSolidPoly ( vertices , vertexCount , Color4F ( color . r , color . g , color . b , 1.0f )); delete [] vertices ; } void CocosDebugDraw :: DrawCircle ( const b2Vec2 & center , float32 radius , const b2Color & color ) { mNode -> drawCircle ( Vec2 ( center . x * mRatio , center . y * mRatio ), radius * mRatio , 0.0f , 16.0f , false , 1.0f , 1.0f , Color4F ( color . r , color . g , color . b , 1.0f )); } void CocosDebugDraw :: DrawSolidCircle ( const b2Vec2 & center , float32 radius , const b2Vec2 & axis , const b2Color & color ) { mNode -> drawSolidCircle ( Vec2 ( center . x * mRatio , center . y * mRatio ), radius * mRatio , 0.0f , 16.0f , 1.0f , 1.0f , Color4F ( color . r , color . g , color . b , 1.0f )); } void CocosDebugDraw :: DrawSegment ( const b2Vec2 & p1 , const b2Vec2 & p2 , const b2Color & color ) { mNode -> drawSegment ( Vec2 ( p1 . x * mRatio , p1 . y * mRatio ), Vec2 ( p2 . x * mRatio , p2 . y * mRatio ), 1.0f , Color4F ( color . r , color . g , color . b , 1.0f )); } void CocosDebugDraw :: DrawTransform ( const b2Transform & xf ) { b2Vec2 p1 = xf . p , p2 ; const float32 k_axisScale = 0.4f ; p2 = p1 + k_axisScale * xf . q . GetXAxis (); DrawSegment ( p1 , p2 , b2Color ( 1 , 0 , 0 )); p2 = p1 + k_axisScale * xf . q . GetYAxis (); DrawSegment ( p1 , p2 , b2Color ( 0 , 1 , 0 )); } void CocosDebugDraw :: DrawPoint ( const b2Vec2 & p , float32 size , const b2Color & color ) { mNode -> drawPoint ( Vec2 ( p . x * mRatio , p . y * mRatio ), size * mRatio , Color4F ( color . r , color . g , color . b , 1.0f )); } void CocosDebugDraw :: DrawString ( int x , int y , const char * string , ...) { // No soportado } void CocosDebugDraw :: DrawAABB ( b2AABB * aabb , const b2Color & color ) { mNode -> drawRect ( Vec2 ( aabb -> lowerBound . x * mRatio , aabb -> lowerBound . y * mRatio ), Vec2 ( aabb -> upperBound . x * mRatio , aabb -> upperBound . y * mRatio ), Color4F ( color . r , color . g , color . b , 1.0f )); } Una vez definida dicha clase, la a\u00f1adiremos al mundo f\u00edsico ( b2World ): 1 2 3 4 m_world = new b2World ( b2Vec2 ( 0 , - 10 )); m_debugDraw = new CocosDebugDraw ( PTM_RATIO ); m_world -> SetDebugDraw ( m_debugDraw ); Ser\u00e1 importante tras esto indicar qu\u00e9 tipos de elementos del motor f\u00edsico queremos que se muestre en la capa de depuraci\u00f3n: 1 2 3 4 5 6 7 8 uint32 flags = 0 ; flags += b2Draw :: e_shapeBit ; flags += b2Draw :: e_jointBit ; flags += b2Draw :: e_aabbBit ; flags += b2Draw :: e_pairBit ; flags += b2Draw :: e_centerOfMassBit ; m_debugDraw -> SetFlags ( flags ); Tras esto, a\u00f1adiremos el nodo de depuraci\u00f3n a nuestra escena. Haremos que quede por delante del resto de capas: 1 m_node -> addChild ( m_debugDraw -> GetNode (), 9999 ); Lo \u00faltimo que deberemos hacer es que en cada iteraci\u00f3n, tras actualizar el estado del mundo f\u00edsico, redibujaremos la capa de depuraci\u00f3n: 1 2 3 4 5 6 7 8 9 void Mundo :: update ( float delta ){ m_world -> ClearForces (); m_world -> Step ( 1.0f / 60.0f , 6 , 2 ); m_debugDraw -> Clear (); m_world -> DrawDebugData (); // ... }","title":"Depuraci\u00f3n de las f\u00edsicas"},{"location":"box2d.html#gestion-de-fisicas-con-physicseditor","text":"Hasta ahora hemos visto que es sencillo crear con Box 2D formas rectangulares y circulares, pero si tenemos objetos m\u00e1s complejos la tarea se complicar\u00e1 notablemente. Tendremos que definir la forma del objeto mediante un pol\u00edgono, pero definir este pol\u00edgono en c\u00f3digo es una tarea altamente tediosa. Podemos hacer esto de forma bastante m\u00e1s sencilla con herramientas como Physics Editor . Se trata de una aplicaci\u00f3n de pago, pero podemos obtener de forma gratuita una versi\u00f3n limitada. La aplicaci\u00f3n puede descargarse de: 1 http : // www . codeandweb . com / physicseditor Con esta herramienta podremos abrir determinados sprites , y obtener de forma autom\u00e1tica su contorno. Cuenta con una herramienta similar a la \"varita m\u00e1gica\" de Photoshop, con la que podremos hacer que sea la propia aplicaci\u00f3n la que determine el contorno de nuestros sprites . A continuaci\u00f3n vemos el entorno de la herramienta con el contorno que ha detectado autom\u00e1ticamente para nuestro sprite : En el lateral derecho podemos seleccionar el formato en el que queremos exportar el contorno detectado. En nuestro caso utilizaremos el formato de Box 2D gen\u00e9rico (se exporta como plist ). Tambi\u00e9n debemos especificar el ratio de p\u00edxeles a metros que queremos utilizar en nuestra aplicaci\u00f3n ( PTM-Ratio ). En dicho panel tambi\u00e9n podemos establecer una serie de propiedades de la forma ( fixture ) que estamos definiendo (densidad, fricci\u00f3n, etc). Una vez establecidos los datos anteriores podemos exportar el contorno del objeto pulsando el bot\u00f3n Publish . Con esto generaremos un fichero plist que podremos importar desde nuestro juego Cocos2D. Para ello necesitaremos a\u00f1adir la clase GB2ShapeCache a nuestro proyecto. Esta clase viene incluida en el instalador de Physics Editor (tenemos tanto versi\u00f3n para Cocos2D como para Cocos2D-X). Para utilizar las formas definidas primero deberemos cargar el contenido del fichero plist en la cach\u00e9 de formas mediante la clase anterior: 1 2 3 4 5 #include \"GB2ShapeCache-x.h\" ... GB2ShapeCache :: sharedGB2ShapeCache () -> addShapesWithFile ( \"formas.plist\" ); Una vez cargadas las formas en la cach\u00e9, podremos asignar las propiedades de las fixtures definidas a nuestros objetos de Box2D: 1 2 3 b2Body * body = ... // Inicializar body GB2ShapeCache :: sharedGB2ShapeCache () -> addFixturesToBody ( body , \"roca\" );","title":"Gesti\u00f3n de f\u00edsicas con PhysicsEditor"},{"location":"box2d.html#referencias","text":"(Gamasutra) How to create 2D Physics Games with Box2D library","title":"Referencias"},{"location":"cocos2d-x.html","text":"El motor cocos2d-x \u00b6 Uno de los motores m\u00e1s conocidos y utilizados para desarrollo de videojuegos para dispositivos m\u00f3viles es Cocos2D . Existe gran cantidad de juegos para iOS implementados con este motor. Aunque inicialmente se trataba de un motor escrito en Objective-C \u00fanicamente para iOS, actualmente contamos con Cocos2d-x (http://www.cocos2d-x.org) que es la versi\u00f3n multiplataforma de este motor. El juego se desarrolla con C++, y puede ser portado directamente a distintos tipos de dispositivos (Android, iOS, Windows Phone, etc). Vamos a comenzar estudiando la forma de crear los diferentes componentes de un videojuego mediante el motor Cocos2d-x. Instalaci\u00f3n de Cocos2d-x \u00b6 Existen dos formas de instalar Cocos2d-x: Instalar \u00fanicamente el framework , con lo que tendremos todo el c\u00f3digo fuente de la librer\u00eda y comandos del terminal para crear nuevos proyectos que la utilicen Instalar todo el kit de herramientas de Cocos, que nos proporciona una interfaz para la creaci\u00f3n de nuevos proyectos, una herramienta visual para la creaci\u00f3n de escenas ( Cocos Studio ), y la posibilidad de utilizar una versi\u00f3n precompilada de la librer\u00eda, lo cual ahorrar\u00e1 mucho tiempo de compilaci\u00f3n en nuestro proyecto. Elegiremos la primera opci\u00f3n si queremos modificar el c\u00f3digo de la librer\u00eda y hacer alguna contribuci\u00f3n al proyecto, mientras que en otros casos ser\u00eda m\u00e1s conveniente utilizar la segunda. Creaci\u00f3n del proyecto con Cocos \u00b6 Si instalamos el kit completo de herramientas, contaremos con la herramienta Cocos que nos permitir\u00e1 crear un nuevo proyecto multiplataforma con esta librer\u00eda, y gestionar los proyectos existentes. Al crear un nuevo proyecto nos dejar\u00e1 elegir: Nombre del proyecto . Ruta del directorio de proyectos . Ruta del disco donde se almacenar\u00e1 el proyecto Cocos2d-x. Ser\u00e1 un directorio con el nombre indicado en el campo anterior. Tipo de motor . Podemos elegir si queremos que nuestro proyecto integre los fuentes de la librer\u00eda de Cocos2d-x, o s\u00f3lo los binarios. Con la primera opci\u00f3n la compilaci\u00f3n ser\u00e1 m\u00e1s lenta, pero nos permitir\u00e1 hacer cambios en la librer\u00eda si es necesario. Lenguaje de desarrollo . Adem\u00e1s de C++, podremos tambi\u00e9n crear videojuegos mediante lenguajes de script como Lua o Javascript. Editor . Nos permite indicar si queremos utilizar Cocos Studio para la edici\u00f3n visual de las escenas. SDKs . Nos permite incluir plugins adicionales para integrar servicios nativos de la plataforma o servicios de terceros, como por ejemplo redes sociales o anal\u00edticas. Creaci\u00f3n del proyecto desde la terminal \u00b6 Tanto si tenemos el kit completo como s\u00f3lo el framework , tendremos la opci\u00f3n de crear un nuevo proyecto desde la terminal. Al descargar y descomprimir Cocos2d-x, veremos en el directorio raiz de la libreria un script llamado setup.py . Este hay que ejecutarlo una vez despu\u00e9s de haber descomprimido la libreria (si utilizamos el instalador esto se har\u00e1 de forma autom\u00e1tica). Este mismo script nos introducira en nuestro fichero ~/.profile las rutas necesarias para utilizar la libreria desde l\u00ednea de comandos. De manera manual podr\u00edamos cargar dichas variables mediante el comando source ~/.profile , pero eso se realizar\u00e1 de manera autom\u00e1tica cada vez que abramos una nueva terminal. De esta manera tendremos acceso a un script llamado cocos que permite entre otras cosas crear la plantilla para un nuevo proyecto Cocos2d-x multiplataforma. Deberemos proporcionar la siguiente informaci\u00f3n: 1 2 3 cocos new MiJuego -p es.ua.dccia -l cpp -d MisProyectosCocos Esto nos crear\u00e1 un proyecto (carpeta) MiJuego en la subcarpeta MisProyectosCocos del directorio donde nos encontremos. El lenguaje utilizado ser\u00e1 C++ ( -l cpp ). La plantilla del nuevo proyecto ser\u00e1 la misma para todos los sistema soportados. Por ejemplo, si queremos trabajar con la versi\u00f3n de iOS, dentro del directorio de nuestro proyecto entraremos en la subcarpeta proj.ios_mac y abriremos el proyecto Xcode. Todas las plataformas comparten los mismos directorio de clases ( Classes ) y recursos ( Resources ) de nuestro juego. S\u00f3lo cambian los ficheros de configuraci\u00f3n del proyecto que los \"envuelve\". Podremos de esta forma crear un nuevo proyecto que contendr\u00e1 la base para implementar un videojuego que utilice las librer\u00edas de Cocos2d-x. El elemento central de este motor es un singleton de tipo Director , al que podemos acceder de la siguiente forma: 1 Director :: getInstance () Tipos de datos \u00b6 Como hemos comentado, Cocos2d-x proviene del motor Cocos2d para iOS. Este motor estaba implementado en Objective-C, sobre la API Cocoa Touch, y por lo tanto estaba muy vinculado a sus tipos de datos. Por este motivo Cocos2d-x implementa sus propios tipos de datos equivalentes a los de Cocoa Touch para poder trabajar de la misma forma. Vamos a ver cu\u00e1les son estos tipos de datos. Por un lado tenemos la clase Ref . Todos los objetos de la librer\u00eda heredan en \u00faltima instancia de esta clase. En ella se define por ejemplo el mecanismo de gesti\u00f3n de memoria que utilizan todos los objetos de la librer\u00eda. Tenemos una serie de colecciones como Vector<> , Map<> especiales de Cocos2d-x que tienen en cuenta su modelo particular de memoria, pero con los que podremos utilizar la sintaxis de C++ para este tipo de colecciones. Tambi\u00e9n tenemos los tipos Value , ValueVector y ValueMap para la representaci\u00f3n de estructuras de datos, que nos permiten por ejemplo cargar ficheros .plist de forma autom\u00e1tica. El primero de ellos es un wrapper que permite almacenar tipos b\u00e1sicos ( bool , int , string , etc) o complejos, mientras que los otros dos representan las listas y diccionarios respectivamente. Encontramos tambi\u00e9n una serie de tipos de datos geom\u00e9tricos: Point , Rect y Size . Estos tipos de datos incorporan tambi\u00e9n algunas operaciones, por ejemplo para comprobar si dos rect\u00e1ngulos intersectan. Escena 2D \u00b6 En Cocos2D cada pantalla se representa mediante un objeto de tipo Scene . En la pantalla del juego se dibujar\u00e1n todos los elementos necesarios (fondos, sprites , etc) para construir la escena del juego. De esta manera tendremos el fondo, nuestro personaje, los enemigos y otros objetos que aparezcan durante el juego, adem\u00e1s de marcadores con el n\u00famero de vidas, puntuaci\u00f3n, etc. Todos estos elementos se representan en Cocos2D como nodos del tipo Node . La escena se compondr\u00e1 de una serie de nodos organizados de forma jer\u00e1rquica. Entre estos nodos podemos encontrar diferentes tipos de elementos para construir la interfaz del videojuego, como etiquetas de texto, men\u00fas, sprites , fondos, etc. Otro de estos tipos de nodos son las capas. La escena se podr\u00e1 componer de una o varias capas. Los sprites y fondos pueden organizarse en diferentes capas para construir la escena. Todas las capas podr\u00e1n moverse o cambiar de posici\u00f3n, para mover de esta forma todo su contenido en la pantalla. Pondremos varios elementos en una misma capa cuando queramos poder moverlos de forma conjunta. Las capas en Cocos2D se representan mediante la clase Layer o Node (en las \u00faltimas versiones del motor las diferencias entre ambas clases son m\u00ednimas, y se recomienda organizar el juego mediante nodos). Las escenas podr\u00e1n componerse de una o varias capas, y estas capas contendr\u00e1n los distintos nodos a mostrar en pantalla, que podr\u00edan ser a su vez otras capas. Es decir, la escena se representar\u00e1 como un grafo, en el que tenemos una jerarqu\u00eda de nodos, en la que determinados nodos, como es el caso de la escena o las capas, podr\u00e1n contener otros nodos. Este tipo de representaci\u00f3n se conoce como escena 2D . Normalmente para cada pantalla del juego tendremos una capa principal, y encapsularemos el funcionamiento de dicha pantalla en una subclase de Layer , por ejemplo: 1 2 3 4 5 6 7 8 9 class MenuPrincipal : public cocos2d :: Layer { public : virtual bool init (); static cocos2d :: Scene * scene (); CREATE_FUNC ( MenuPrincipal ); }; Crearemos la escena a partir de su capa principal. Todos los nodos, incluyendo la escena, se instanciar\u00e1n mediante el m\u00e9todo de factor\u00eda create . Este m\u00e9todo de factor\u00eda se genera de forma est\u00e1tica con la macro CREATE_FUNC , por ese motivo est\u00e1 declarada en la interfaz de clase anterior. Podemos a\u00f1adir un nodo como hijo de otro nodo con el m\u00e9todo addChild : 1 2 3 4 5 6 7 Scene * MenuPrincipal :: scene () { Scene * scene = Scene :: create (); MenuPrincipal * layer = MenuPrincipal :: create (); scene -> addChild ( layer , 0 ); return scene ; } Cuando instanciamos un nodo mediante el m\u00e9todo de factor\u00eda create , llamar\u00e1 a su m\u00e9todo init para inicializarse. Si sobrescribimos dicho m\u00e9todo en la capa podremos definir la forma en la que se inicializa: 1 2 3 4 5 6 7 8 9 10 11 12 13 bool MenuPrincipal :: init () { // Inicializar primero la superclase if ( ! Layer :: init () ) { return false ; } // Inicializar componentes de la capa ... return true ; } El orden en el que se mostrar\u00e1n las capas es lo que se conoce como orden Z, que indica la profundidad de esta capa en la escena. La primera capa ser\u00e1 la m\u00e1s cercana al punto de vista del usuario, mientras que la \u00faltima ser\u00e1 la m\u00e1s lejana. Por lo tanto, las primeras capas que a\u00f1adamos quedar\u00e1n por delante de las siguientes capas. Este orden Z se puede controlar mediante la propiedad zOrder de los nodos. Transiciones entre escenas \u00b6 Mostraremos la escena inicial del juego con el m\u00e9todo runWithScene del director: 1 Director :: getInstance () -> runWithScene ( MenuPrincipal :: scene ()); Con esto pondremos en marcha el motor del juego mostrando la escena indicada. Si el motor ya est\u00e1 en marcha y queremos cambiar de escena, deberemos hacerlo con el m\u00e9todo replaceScene : 1 Director :: getInstance () -> replaceScene ( Puntuaciones :: scene ()); Tambi\u00e9n podemos implementar transiciones entre escenas de forma animada utilizando como escena una serie de clases todas ellas con prefijo Transition- , que heredan de TransitionScene , que a su vez hereda de Scene . Podemos mostrar una transici\u00f3n animada reemplazando la escena actual por una escena de transici\u00f3n: 1 2 3 4 Scene * puntuacionesScene = Puntuaciones :: scene (); TransitionCrossFade * transition = TransitionCrossFade :: create ( 0.5 , puntuacionScene ); Director :: getInstance () -> replaceScene ( transition ); Podemos observar que la escena de transici\u00f3n se construye a partir de la duraci\u00f3n de la transici\u00f3n, y de la escena que debe mostrarse una vez finalice la transici\u00f3n. Interfaz de usuario \u00b6 Encontramos distintos tipos de nodos que podemos a\u00f1adir a la escena para crear nuestra interfaz de usuario, como por ejemplo men\u00fas y etiquetas de texto, que nos pueden servir por ejemplo para mostrar el marcador de puntuaci\u00f3n, o el mensaje Game Over . Tenemos dos formas alternativas de crear una etiqueta de texto: Utilizar una fuente TrueType predefinida. Crear nuestro propio tipo de fuente bitmap . La primera opci\u00f3n es la m\u00e1s sencilla, ya que podemos crear la cadena directamente a partir de un tipo de fuente ya existen y a\u00f1adirla a la escena con addChild (por ejemplo a\u00f1adi\u00e9ndola como hija de la capa principal de la escena). Se define mediante la clase LabelTTF : 1 2 LabelTTF * label = LabelTTF :: create ( \"Game Over\" , \"Arial\" , 24 ); this -> addChild ( label ); Sin embargo, en un videojuego debemos cuidar al m\u00e1ximo el aspecto y la personalizaci\u00f3n de los gr\u00e1ficos. Por lo tanto, suele ser m\u00e1s adecuado crear nuestros propios tipos de fuentes. La mayor\u00eda de motores de videojuegos soportan el formato .fnt , con el que podemos definir fuentes de tipo bitmap personalizadas. Para crear una fuente con dicho formato podemos utilizar herramientas como Angel Code o Hiero (http://www.n4te.com/hiero/hiero.jnlp). Una vez creada la fuente con este formato, podemos mostrar una cadena con dicha fuente mediante la clase LabelBMFont : 1 2 LabelBMFont * label = LabelBMFont :: create ( \"Game Over\" , \"fuente.fnt\" ); this -> addChild ( label ); Por otro lado, tambi\u00e9n podemos crear men\u00fas de opciones. Normalmente en la pantalla principal del juego siempre encontraremos un men\u00fa con todas las opciones que nos ofrece dicho juego. Los men\u00fas se crean con la clase Menu , a la que a\u00f1adiremos una serie de items , de tipo MenuItem (o subclases suyas), que representar\u00e1n las opciones del men\u00fa. Estos items pueden ser etiquetas de texto, pero tambi\u00e9n podemos utilizar im\u00e1genes para darles un aspecto m\u00e1s vistoso. El men\u00fa se a\u00f1adir\u00e1 a la escena como cualquier otro tipo de item : 1 2 3 4 5 6 7 8 9 10 11 12 13 MenuItemImage * item1 = MenuItemImage :: create ( \"nuevo_juego.png\" , \"nuevo_juego_selected.png\" , CC_CALLBACK_1 ( MenuPrincipal :: menuNuevoJuegoCallback , this )); MenuItemImage * item2 = MenuItemImage :: create ( \"continuar.png\" , \"continuar_selected.png\" , CC_CALLBACK_1 ( MenuPrincipal :: menuContinuarCallback , this )); MenuItemImage * item3 = MenuItemImage :: create ( \"opciones.png\" , \"opciones_selected.png\" , CC_CALLBACK_1 ( MenuPrincipal :: menuOpcionesCallback , this )); Menu * menu = Menu :: create ( item1 , item2 , item3 , NULL ); menu -> alignItemsVertically (); this -> addChild ( menu ); Vemos que para cada item del men\u00fa a\u00f1adimos dos im\u00e1genes. Una para su estado normal, y otra para cuando est\u00e9 pulsado. Tambi\u00e9n propocionamos la acci\u00f3n a realizar cuando se pulse sobre cada opci\u00f3n, mediante un par target-selector : el target es el objeto sobre el que se va a llamar a la acci\u00f3n (normalmente nuestro propio objeto this ), y el selector es la forma de indicar el m\u00e9todo al que se va a invocar. Los m\u00e9todos indicados como selectores de tipo men\u00fa deber\u00e1n tener la siguiente forma: 1 2 3 4 void MenuPrincipal :: menuNuevoJuegoCallback ( Ref * pSender ) { Director :: getInstance () -> replaceScene ( Game :: scene ()); } Una vez creadas las opciones, construirmos un men\u00fa a partir de ellas, organizamos los items (podemos disponerlos en vertical de forma autom\u00e1tica como vemos en el ejemplo), y a\u00f1adimos el men\u00fa a la escena. Gesti\u00f3n de la memoria \u00b6 La memoria en Cocos2d-x se gestiona mediante cuenta de referencias, siguiendo el mismo mecanismo de gesti\u00f3n de memoria que utiliza Cocos2d al estar implementado en Objective-C. Este mecanismo consiste en que los objetos de la librer\u00eda (todos aquellos derivan de Ref ) tienen un contador de referencias que existen hacia ellos. Cuando el contador de referencias llegue a cero, el objeto se eliminar\u00e1 de memoria. Al instanciar un objeto (con new ) el objeto se crea con 1 referencia. Podemos incrementar el n\u00famero de referencias sobre un objeto llamando a su m\u00e9todo retain , y decrementarlo llamando a release . Deberemos asegurarnos de que el n\u00famero de llamadas a new / retain sobre un objeto sea igual al n\u00famero de llamadas a release . Si el primero fuese superior al segundo, entonces tendr\u00edamos una fuga de memoria. Si fuese inferior tendr\u00edamos un error de acceso a memoria cuando intentemos decrementar las referencias de un objeto que ha sido ya liberado. Si no organizamos bien el c\u00f3digo de gesti\u00f3n de memoria puede ser complicado garantizar que el n\u00famero de llamadas est\u00e9 equilibrado. Para evitar este problema la regla fundamental es que la unidad que incremente el n\u00famero de referencias ( new / retain ) ser\u00e1 responsable de decrementarlo ( release ). Vemos a continuaci\u00f3n con mayor detalle las implicaciones que esta regla tiene en el uso de la librer\u00eda: Cuando instanciamos un nodo con el m\u00e9todo factor\u00eda create este m\u00e9todo crea una referencia, pero \u00e9l mismo es responsable de eliminarla. Para conseguir esto lo que hace es dejar programado que la referencia se librere autom\u00e1ticamente cuando termine la llamada de la funci\u00f3n en la que estamos. Es decir, si nadie retiene el objeto que nos ha devuelto el objeto ser\u00e1 eliminado de memoria autom\u00e1ticamente. Cuando a\u00f1adimos un nodo como hijo de otro en la escena 2D, o cuando se a\u00f1ade a otras estructuras como el director, o alguna de las cach\u00e9s de objetos que gestiona el motor, estas estructuras se encargar de retener el objeto en memoria, y cuando se elimine de ellas lo liberar\u00e1n. Es decir, podemos por ejemplo crear un nodo con create y en ese momento a\u00f1adirlo como hijo a otro con addChild , y no tendremos que preocuparnos de retenerlo ni de liberarlo. El propio grafo de la escena ser\u00e1 el encargado de gestionar la memoria. Si queremos guardar un nodo como campo de nuestro objeto, tras instanciarlo con create deberemos reternarlo con retain para que no se libere autom\u00e1ticamente. Nosotros seremos responsables de liberarlo, por lo que deberemos llamar a release sobre dicho campo cuando nuestro objeto sea destruido, o cuando vayamos a cambiar el valor del campo y el antiguo deba ser liberado. Sprites \u00b6 Podemos crear un sprite en Cocos2D con la clase Sprite a partir de la textura de dicho sprite : 1 Sprite * sprite = Sprite :: create ( \"personaje.png\" ); El sprite podr\u00e1 ser a\u00f1adido a la escena como cualquier otro nodo, a\u00f1adi\u00e9ndolo como hijo de alguna de las capas con addChild: . Posici\u00f3n \u00b6 Al igual que cualquier nodo, un sprite tiene una posici\u00f3n en pantalla representada por su propiedad position , de tipo Vec2 (tambi\u00e9n podemos utilizar como tipo Point , ya que es un alias de Vec2 ). Por ejemplo, para posicionar un sprite en unas determinadas coordenadas le asignaremos un valor a su propiedad position (esto es aplicable a cualquier nodo): 1 sprite -> setPosition ( Vec2 ( 240 , 160 )); La posici\u00f3n indicada corresponde al punto central del sprite , aunque podr\u00edamos modificar esto con la propiedad anchorPoint , de forma similar a las capas de CoreAnimation. El sistema de coordenadas de Cocos2D es el mismo que el de CoreGraphics, el origen de coordenadas se encuentra en la esquina inferior izquierda, y las y son positivas hacia arriba. Podemos aplicar otras transformaciones al sprite , como rotaciones ( rotation ), escalados ( scale , scaleX , scaleY ), o desencajados ( skewX , skewY ). Tambi\u00e9n podemos especificar su orden Z ( zOrder ). Recordamos que todas estas propiedades no son exclusivas de los sprites , sino que son aplicables a cualquier nodo, aunque tienen un especial inter\u00e9s en el caso de los sprites . Fotogramas \u00b6 Estos objetos pueden estar animados. Para ello deberemos definir los distintos fotogramas (o frames ) de la animaci\u00f3n. Podemos definir varias animaciones para cada sprite , seg\u00fan las acciones que pueda hacer. Por ejemplo, si tenemos un personaje podemos tener una animaci\u00f3n para andar hacia la derecha y otra para andar hacia la izquierda. El sprite tendr\u00e1 un determinado tama\u00f1o (ancho y alto), y cada fotograma ser\u00e1 una imagen de este tama\u00f1o. Cambiando el fotograma que se muestra del sprite en cada momento podremos animarlo. Para ello deberemos tener im\u00e1genes para los distintos fotogramas del sprite . Sin embargo, como hemos comentado anteriormente, la memoria de v\u00eddeo es un recurso cr\u00edtico, y debemos aprovechar al m\u00e1ximo el espacio de las texturas que se almacenan en ella. Recordemos que el tama\u00f1o de las texturas en memoria debe ser potencia de 2. Adem\u00e1s, conviene evitar empaquetar con la aplicaci\u00f3n un gran n\u00famero de im\u00e1genes, ya que esto har\u00e1 que el espacio que ocupan sea mayor, y que la carga de las mismas resulte m\u00e1s costosa. Para almacenar los fotogramas de los sprites de forma \u00f3ptima, utilizamos lo que se conoce como sprite sheets . Se trata de im\u00e1genes en las que incluyen de forma conjunta todos los fotogramas de los sprites , dispuestos en forma de mosaico. Podemos crear estos sprite sheets de forma manual, aunque encontramos herramientas que nos facilitar\u00e1n en\u00f3rmemente este trabajo, como TexturePacker (http://www.texturepacker.com). Esta herramienta cuenta con una versi\u00f3n b\u00e1sica gratuita, y opciones adicionales de pago. Adem\u00e1s de organizar los sprites de forma \u00f3ptima en el espacio de una textura OpenGL, nos permite almacenar esta textura en diferentes formatos (RGBA8888, RGBA4444, RGB565, RGBA5551, PVRTC) y aplicar efectos de mejora como dithering . Esta herramienta permite generar los sprite sheets en varios formatos reconocidos por los diferentes motores de videojuegos, como por ejemplo Cocos2D o libgdx. Con esta herramienta simplemente tendremos que arrastrar sobre ella el conjunto de im\u00e1genes con los distintos fotogramas de nuestros sprites , y nos generar\u00e1 una textura optimizada para OpenGL con todos ellos dispuestos en forma de mosaico. Cuando almacenemos esta textura generada, normalmente se guardar\u00e1 un fichero .png con la textura, y un fichero de datos que contendr\u00e1 informaci\u00f3n sobre los distintos fotogramas que contiene la textura, y la regi\u00f3n que ocupa cada uno de ellos. Para poder utilizar los fotogramas a\u00f1adidos a la textura deberemos contar con alg\u00fan mecanismo que nos permita mostrar en pantalla de forma independiente cada regi\u00f3n de la textura anterior (cada fotograma). En pr\u00e1cticamente todos los motores para videojuegos encontraremos mecanismos para hacer esto. En el caso de Cocos2D, tenemos la clase SpriteFrameCache que se encarga de almacenar la cach\u00e9 de fotogramas de sprites que queramos utilizar. Con TexturePacker habremos obtenido un fichero .plist (es el formato utilizado por Cocos2D) y una imagen .png . Podremos a\u00f1adir fotogramas a la cach\u00e9 a partir de estos dos ficheros. En el fichero .plist se incluye la informaci\u00f3n de cada fotograma (tama\u00f1o, regi\u00f3n que ocupa en la textura, etc). Cada fotograma se encuentra indexado por defecto mediante el nombre de la imagen original que a\u00f1adimos a TexturePacker, aunque podr\u00edamos editar esta informaci\u00f3n de forma manual en el .plist . La cach\u00e9 de fotogramas se define como singleton . Podemos a\u00f1adir nuevos fotogramas a este singleton de la siguiente forma: 1 2 SpriteFrameCache :: getInstance () -> addSpriteFramesWithFile ( \"sheet.plist\" ); En el caso anterior, utilizar\u00e1 como textura un fichero con el mismo nombre que el .plist pero con extensi\u00f3n .png . Tambi\u00e9n encontramos una versi\u00f3n del m\u00e9todo anterior que tambi\u00e9n recibe como par\u00e1metro la textura a utilizar, y de esta forma nos permite utilizar un fichero de textura con distinto nombre al .plist . Una vez introducidos los fotogramas empaquetados por TexturePacker en la cach\u00e9 de Cocos2D, podemos crear sprites a partir de dicha cach\u00e9 con: 1 Sprite * sprite = Sprite :: createWithSpriteFrameName ( \"frame01.png\" ); En el caso anterior creamos un nuevo sprite , pero en lugar de hacerlo directamente a partir de una imagen, debemos hacerlo a partir del nombre de un fotograma a\u00f1adido a la cach\u00e9 de textura. No debemos confundirnos con esto, ya que en este caso al especificar \"frame01.png\" no buscar\u00e1 un fichero con este nombre en la aplicaci\u00f3n, sino que buscar\u00e1 un fotograma con ese nombre en la cach\u00e9 de textura. El que los fotogramas se llamen por defecto como la imagen original que a\u00f1adimos a TexturePacker puede llevarnos a confusi\u00f3n. Tambi\u00e9n podemos obtener el fotograma como un objeto SpriteFrame . Esta clase no define un sprite , sino el fotograma almacenado en cach\u00e9. Es decir, no es un nodo que podamos almacenar en la escena, simplemente define la regi\u00f3n de textura correspondiente al fotograma: 1 2 SpriteFrame * frame = SpriteFrameCache :: getInstance () -> spriteFrameByName ( \"frame01.png\" ); Podremos inicializar tambi\u00e9n el sprite a partir del fotograma anterior, en lugar de hacerlo directamente a partir del nombre del fotograma: 1 Sprite * sprite = Sprite :: createWithSpriteFrame ( frame ); Animaci\u00f3n \u00b6 Podremos definir determinadas secuencias de frames para crear animaciones. Las animaciones se representan mediante la clase Animation , y se pueden crear a partir de la secuencia de fotogramas que las definen. Los fotogramas deber\u00e1n indicarse mediante objetos de la clase SpriteFrame : 1 2 3 4 5 Animation * animAndar = Animation :: create (); animAndar -> addSpriteFrame ( SpriteFrameCache :: getInstance () -> spriteFrameByName ( \"frame01.png\" )); animAndar -> addSpriteFrame ( SpriteFrameCache :: getInstance () -> spriteFrameByName ( \"frame02.png\" )); Podemos ver que los fotogramas se pueden obtener de la cach\u00e9 de fotogramas definida anteriormente. Adem\u00e1s de proporcionar una lista de fotogramas a la animaci\u00f3n, deberemos proporcionar su periodicidad, es decir, el tiempo en segundos que tarda en cambiar al siguiente fotograma. Esto se har\u00e1 mediante la propiedad delayPerUnit : 1 animAndar -> setDelayPerUnit ( 0.25 ); Una vez definida la animaci\u00f3n, podemos a\u00f1adirla a una cach\u00e9 de animaciones que, al igual que la cach\u00e9 de texturas, tambi\u00e9n se define como singleton : 1 2 AnimationCache :: getInstance () -> addAnimation ( animAndar , \"animAndar\" ); La animaci\u00f3n se identifica mediante la cadena que proporcionamos como par\u00e1metro name . Podemos cambiar el fotograma que muestra actualmente un sprite con su m\u00e9todo: 1 sprite -> setDisplayFrameWithAnimationName ( \"animAndar\" , 0 ); Con esto buscar\u00e1 en la cach\u00e9 de animaciones la animaci\u00f3n especificada, y mostrar\u00e1 de ella el fotograma cuyo \u00edndice proporcionemos. M\u00e1s adelante cuando estudiemos el motor del juego veremos c\u00f3mo reproducir animaciones de forma autom\u00e1tica. Sprite batch \u00b6 En OpenGL los sprites se dibujan realmente en un contexto 3D. Es decir, son texturas que se mapean sobre pol\u00edgonos 3D (concretamente con una geometr\u00eda rect\u00e1ngular). Muchas veces encontramos en pantalla varios sprites que utilizan la misma textura (o distintas regiones de la misma textura, como hemos visto en el caso de los sprite sheets ). Podemos optimizar el dibujado de estos sprites generando la geometr\u00eda de todos ellos de forma conjunta en una \u00fanica operaci\u00f3n con la GPU. Esto ser\u00e1 posible s\u00f3lo cuando el conjunto de sprites a dibujar est\u00e9n contenidos en una misma textura. Podemos crear un batch de sprites con Cocos2D utilizando la clase 1 2 3 SpriteBatchNode * spriteBatch = SpriteBatchNode :: create ( \"sheet.png\" ); this -> addChild ( spriteBatch ); El sprite batch es un tipo de nodo m\u00e1s que podemos a\u00f1adir a nuestra capa como hemos visto, pero por si s\u00f3lo no genera ning\u00fan contenido. Deberemos a\u00f1adir como hijos los sprites que queremos que dibuje. Es imprescindible que los hijos sean de tipo Sprite (o subclases de \u00e9sta), y que tengan como textura la misma textura que hemos utilizado al crear el batch (o regiones de la misma). No podremos a\u00f1adir sprites con ninguna otra textura dentro de este batch . 1 2 3 4 5 6 7 Sprite * sprite1 = Sprite :: createWithSpriteFrameName ( \"frame01.png\" ); sprite1 -> setPosition ( Vec2 ( 50 , 20 )); Sprite * sprite2 = Sprite :: createWithSpriteFrameName ( \"frame01.png\" ); sprite2 -> setPosition ( Vec2 ( 150 , 20 )); spriteBatch -> addChild ( sprite1 ); spriteBatch -> addChild ( sprite2 ); En el ejemplo anterior consideramos que el frame con nombre \"frame01.png\" es un fotograma que se carg\u00f3 en la cach\u00e9 de fotogramas a partir de la textura sheet.png . De no pertenecer a dicha textura no podr\u00eda cargarse dentro del batch . Colisiones \u00b6 Otro aspecto de los sprites es la interacci\u00f3n entre ellos. Nos interesar\u00e1 saber cu\u00e1ndo somos tocados por un enemigo o una bala para disminuir la vida, o cu\u00e1ndo alcanzamos nosotros a nuestro enemigo. Para ello deberemos detectar las colisiones entre sprites . La colisi\u00f3n con sprites de formas complejas puede resultar costosa de calcular. Por ello se suele realizar el c\u00e1lculo de colisiones con una forma aproximada de los sprites con la que esta operaci\u00f3n resulte m\u00e1s sencilla. Para ello solemos utilizar el bounding box , es decir, un rect\u00e1ngulo que englobe el sprite . La intersecci\u00f3n de rect\u00e1ngulos es una operaci\u00f3n muy sencilla. La clase Sprite contiene un m\u00e9todo getBoundingBox que nos devuelve un objeto Rect que representa la caja en la que el sprite est\u00e1 contenido. Con la funci\u00f3n intersectsRect podemos comprobar de forma sencilla y eficiente si dos rect\u00e1ngulos colisionan: 1 2 3 4 5 6 7 Rect bbPersonaje = spritePersonaje -> getBoundingBox (); Rect bbEnemigo = spriteEnemigo -> getBoundingBox (); if ( bbPersonaje . intersectsRect ( bbEnemigo )) { // Game over ... } Motor del juego \u00b6 El componente b\u00e1sico del motor de un videojuego es lo que se conoce como ciclo del juego ( game loop ). Vamos a ver a continuaci\u00f3n en qu\u00e9 consiste este ciclo. Ciclo del juego \u00b6 Se trata de un bucle infinito en el que tendremos el c\u00f3digo que implementa el funcionamiento del juego. Dentro de este bucle se efect\u00faan las siguientes tareas b\u00e1sicas: Leer la entrada : Lee la entrada del usuario para conocer si el usuario ha pulsado alguna tecla desde la \u00faltima iteraci\u00f3n. Actualizar escena : Actualiza las posiciones de los sprites y su fotograma actual, en caso de que est\u00e9n siendo animados, la posici\u00f3n del fondo si se haya producido scroll , y cualquier otro elemento del juego que deba cambiar. Para hacer esta actualizaci\u00f3n se pueden tomar diferentes criterios. Podemos mover el personaje seg\u00fan la entrada del usuario, la de los enemigos seg\u00fan su inteligencia artificial, o seg\u00fan las interacciones producidas entre ellos y cualquier otro objeto (por ejemplo al ser alcanzados por un disparo, colisionando el sprite del disparo con el del enemigo), etc. Redibujar : Tras actualizar todos los elementos del juego, deberemos redibujar la pantalla para mostrar la escena tal como ha quedado en el instante actual. Dormir : Normalmente tras cada iteraci\u00f3n dormiremos un determinado n\u00famero de milisegundos para controlar la velocidad a la que se desarrolla el juego. De esta forma podemos establecer a cuantos fotogramas por segundo ( fps ) queremos que funcione el juego, siempre que la CPU sea capaz de funcionar a esta velocidad. 1 2 3 4 5 while ( true ) { leeEntrada (); actualizaEscena (); dibujaGraficos (); } Este ciclo no siempre deber\u00e1 comportarse siempre de la misma forma. El juego podr\u00e1 pasar por distintos estados, y en cada uno de ellos deber\u00e1n el comportamiento y los gr\u00e1ficos a mostrar ser\u00e1n distintos (por ejemplo, las pantallas de men\u00fa, selecci\u00f3n de nivel, juego, game over , etc). Podemos modelar esto como una m\u00e1quina de estados, en la que en cada momento, seg\u00fan el estado actual, se realicen unas funciones u otras, y cuando suceda un determinado evento, se pasar\u00e1 a otro estado. Actualizaci\u00f3n de la escena \u00b6 En Cocos2D no deberemos preocuparnos de implementar el ciclo del juego, ya que de esto se encarga el singleton Director . Los estados del juego se controlan mediante las escenas ( Scene ). En un momento dado, el ciclo de juego s\u00f3lo actualizar\u00e1 y mostrar\u00e1 los gr\u00e1ficos de la escena actual. Dicha escena dibujar\u00e1 los gr\u00e1ficos a partir de los nodos que hayamos a\u00f1adido a ella como hijos. Ahora nos queda ver c\u00f3mo actualizar dicha escena en cada iteraci\u00f3n del ciclo del juego, por ejemplo, para ir actualizando la posici\u00f3n de cada personaje, o comprobar si existen colisiones entre diferentes sprites . La escena tiene un m\u00e9todo schedule que permite especificar un m\u00e9todo al que se llamar\u00e1 en cada iteraci\u00f3n del ciclo. De esa forma, podremos especificar en dicho m\u00e9todo la forma de actualizar la escena: 1 scene -> schedule ( CC_SCHEDULE_SELECTOR ( Game :: update )); Tendremos que definir un m\u00e9todo update donde introduciremos el c\u00f3digo que se encargar\u00e1 de actualizar la escena. Como par\u00e1metro recibe el tiempo transcurrido desde la anterior actualizaci\u00f3n (desde la anterior iteraci\u00f3n del ciclo del juego). Deberemos aprovechar este dato para actualizar los movimientos a partir de \u00e9l, y as\u00ed conseguir un movimiento fluido y constante: 1 2 3 4 void Game :: update ( float dt ) { _sprite -> setPosition ( _sprite -> getPosition () + Vec2 ( 100 * dt , 0 )); } En este caso estamos moviendo el sprite en x a una velocidad de 100 pixeles por segundo (el tiempo transcurrido se proporciona en segundos). Es importante remarcar que tanto el dibujado como las actualizaciones s\u00f3lo se llevar\u00e1n a cabo cuando la escena en la que est\u00e1n sea la escena que est\u00e1 ejecutando actualmente el Director . As\u00ed es como se controla el estado del juego. Existe otra versi\u00f3n del m\u00e9todo schedule que nos permite proporcionar el m\u00e9todo a llamar mediante una funci\u00f3n lambda. En este caso deberemos indicar tambi\u00e9n un identificador para nuestra funci\u00f3n, para as\u00ed poder cancelar su planificaci\u00f3n: 1 2 3 scene -> schedule ([ = ]( float dt ) { ... }, \"ia\" ); A esta planificaci\u00f3n le hemos dado el identificador \"ia\" . Podremos cancelarla llamando a unschedule(\"ia\") . Si no queremos tener que especificar la funci\u00f3n de forma inline , tambi\u00e9n podemos especificarla de la siguiente forma: 1 scene -> schedule ( CC_CALLBACK_1 ( Game :: update , this ), \"ia\" ); Acciones \u00b6 En el punto anterior hemos visto c\u00f3mo actualizar la escena de forma manual como se hace habitualmente en el ciclo del juego. Sin embargo, con Cocos2D tenemos formas m\u00e1s sencillas de animar los nodos de la escena, son lo que se conoce como acciones . Estas acciones nos permiten definir determinados comportamientos, como trasladarse a un determinado punto, y aplicarlos sobre un nodo para que realice dicha acci\u00f3n de forma autom\u00e1tica, sin tener que actualizar su posici\u00f3n manualmente en cada iteraci\u00f3n ( tick ) del juego. Todas las acciones derivan de la clase Action . Encontramos acciones instant\u00e1neas (como por ejemplo situar un sprite en una posici\u00f3n determinada), o acciones con una duraci\u00f3n (mover al sprite hasta la posici\u00f3n destino gradualmente). Por ejemplo, para mover un nodo a la posici\u00f3n (200, 50) en 3 segundos, podemos definir una acci\u00f3n como la siguiente: 1 MoveTo * actionMoveTo = MoveTo :: create ( 3 , Vec2 ( 200 , 50 )); Para ejecutarla, deberemos aplicarla sobre el nodo que queremos mover: 1 sprite -> runAction ( actionMoveTo ); Podemos ejecutar varias acciones de forma simult\u00e1nea sobre un mismo nodo. Si queremos detener todas las acci\u00f3nes que pudiera haber en marcha hasta el momento, podremos hacerlo con: 1 sprite -> stopAllActions (); Adem\u00e1s, tenemos la posibilidad de encadenar varias acciones mediante el tipo especial de acci\u00f3n Sequence . En el siguiente ejemplo primero situamos el sprite de forma inmediata en (0, 50) , y despu\u00e9s lo movermos a (200, 50) : 1 2 3 4 5 6 7 Place * actionPlace = Place :: create ( Vec2 ( 0 , 50 )); MoveTo * actionMoveTo = MoveTo :: create ( 3 , Vec2 ( 200 , 50 )); Sequence * actionSequence = Sequence :: create ( actionPlace , actionMoveTo , NULL ); sprite -> runAction ( actionSequence ); Incluso podemos hacer que una acci\u00f3n (o secuencia de acciones) se repita un determinado n\u00famero de veces, o de forma indefinida: 1 2 3 RepeatForever * actionRepeat = RepeatForever :: create ( actionSequence ); sprite -> runAction ( actionRepeat ); De esta forma, el sprite estar\u00e1 continuamente movi\u00e9ndose de (0,50) a (200,50) . Cuando llegue a la posici\u00f3n final volver\u00e1 a aparecer en la inicial y continuar\u00e1 la animaci\u00f3n. Podemos aprovechar este mecanismo de acciones para definir las animaciones de fotogramas de los sprites , con una acci\u00f3n de tipo Animate . Crearemos la acci\u00f3n de animaci\u00f3n a partir de una animaci\u00f3n de la cach\u00e9 de animaciones: 1 2 3 4 5 Animate * animate = Animate :: create ( AnimationCache :: sharedAnimationCache () -> animationByName ( \"animAndar\" )); sprite -> runAction ( RepeatForever :: create ( animate )); Con esto estaremos reproduciendo continuamente la secuencia de fotogramas definida en la animaci\u00f3n, utilizando la periodicidad ( delayPerUnit ) que especificamos al crear dicha animaci\u00f3n. Encontramos tambi\u00e9n acciones que nos permiten realizar tareas personalizadas, proporcionando mediante una pareja target-selector la funci\u00f3n a la que queremos que se llame cuando se produzca la acci\u00f3n: 1 2 CallFunc * actionCall = CallFunc :: create ( CC_CALLBACK_0 ( Game :: accionCallback , this )); Deberemos definir en nuestra clase el m\u00e9todo de callback a llamar. En el caso del ejemplo anterior ser\u00eda: 1 2 3 void Game :: accionCallback () { ... } Otra opci\u00f3n es pasar directamente una funci\u00f3n lambda como par\u00e1metro: 1 2 3 CallFunc :: create ([ = ] { ... }); Tambi\u00e9n encontramos variantes de esta acci\u00f3n que nos permiten pasarle al callback como par\u00e1metro datos propios o el nodo sobre el que se ha ejecutado la acci\u00f3n ( CallFuncN recibe el nodo como par\u00e1metro, y CallFundND recibe el nodo y un puntero a datos gen\u00e9ricos). Cuanto tengamos que pasar un callback con par\u00e1metros utilizaremos CC_CALLBACK_1 , CC_CALLBACK_2 y CC_CALLBACK_3 , para 1, 2 y 3 par\u00e1metros respectivamente. Encontramos gran cantidad de acciones disponibles, que nos permitir\u00e1n crear diferentes efectos (fundido, tinte, rotaci\u00f3n, escalado), e incluso podr\u00edamos crear nuestras propias acciones mediante subclases de Action . Escenario de tipo mosaico \u00b6 Hasta el momento hemos visto c\u00f3mo crear los diferentes elementos din\u00e1micos ( sprites ) de nuestro juego, como por ejemplo nuestro personaje, los enemigos, o los disparos. Pero todos estos elementos normalmente se mover\u00e1n sobre un escenario. Vamos a ver en esta sesi\u00f3n la forma en la que podemos construir este escenario, los fondos, y tambi\u00e9n c\u00f3mo a\u00f1adir m\u00fasica de fondo y efectos de sonido. En los juegos normalmente tendremos un fondo sobre el que se mueven los personajes. Muchas veces los escenarios del juego son muy extensos y no caben enteros en la pantalla. De esta forma lo que se hace es ver s\u00f3lo la parte del escenario donde est\u00e1 nuestro personaje, y conforme nos movamos se ir\u00e1 desplazando esta zona visible para enfocar en todo momento el lugar donde est\u00e1 nuestro personaje. Esto es lo que se conoce como scroll . El tener un fondo con scroll ser\u00e1 m\u00e1s costoso computacionalmente, ya que siempre que nos desplacemos se deber\u00e1 redibujar toda la pantalla, debido a que se est\u00e1 moviendo todo el fondo. Adem\u00e1s para poder dibujar este fondo deberemos tener una imagen con el dibujo del fondo para poder volcarlo en pantalla. Si tenemos un escenario extenso, ser\u00eda totalmente prohibitivo hacer una imagen que contenga todo el fondo. Esta imagen sobrepasar\u00eda con total seguridad el tama\u00f1o m\u00e1ximo de las texturas OpenGL. Para evitar este problema lo que haremos normalmente en este tipo de juegos es construir el fondo como un mosaico. Nos crearemos una imagen con los elementos b\u00e1sicos que vamos a necesitar para nuestro fondo, y construiremos el fondo como un mosaico en el que se utilizan estos elementos. Encontramos herramientas que nos permiten hacer esto de forma sencilla, como Tiled (http://www.mapeditor.org). Con esta herramienta deberemos proporcionar una textura con las distintas piezas con las que construiremos el mosaico, y podemos combinar estas piezas de forma visual para construir mapas extensos. Deberemos proporcionar una imagen con un conjunto de patrones ( Mapa > Nuevo conjunto de patrones ). Deberemos indicar el ancho y alto de cada \"pieza\" ( tile ), para que as\u00ed sea capaz de particionar la imagen y obtener de ella los diferentes patrones con los que construir el mapa. Una vez cargados estos patrones, podremos seleccionar cualquiera de ellos y asignarlo a las diferentes celdas del mapa. El resultado se guardar\u00e1 en un fichero de tipo .tmx , basado en XML, que la mayor parte de motores 2D son capaces de leer. En Cocos2D tenemos la clase CCTMXTiledMap , que puede inicializarse a partir del fichero .tmx : 1 TMXTiledMap * fondo = TMXTiledMap :: create ( \"mapa.tmx\" ); Este objeto es un nodo (hereda de Node ), por lo que podemos a\u00f1adirlo a pantalla (con addChild ) y aplicar cualquier transformaci\u00f3n de las vistas anterioremente. Las dimesiones del mapa ser\u00e1n (columnas ancho)x(filas alto) , siendo ancho x alto las dimensiones de cada tile , y columnas x filas el n\u00famero de celdas que tiene el mapa. Hemos visto la creaci\u00f3n b\u00e1sica de un escenario con Tiled Map Editor , pero esta herramienta nos da m\u00e1s facilidades para la creaci\u00f3n de los fondos. En el caso anterior hemos visto como crear el fondo a partir de una \u00fanica capa de mosaico, pero podemos hacer que nuestros fondos se compongan de varias capas. En el panel de la derecha de la herramienta vemos la lista de capas, y podemos a\u00f1adir nuevas capas. Al a\u00f1adir una nueva capa, nos preguntar\u00e1 si queremos una nueva capa de patrones o de objetos. Las capas de patrones nos permitir\u00e1n crear el aspecto visual del fondo mediante un mosaico, como hemos visto anteriormente, mientras que las de objetos nos permiten marcar diferentes zonas del mapa, por ejemplo para indicar puntos en los que aparecen enemigos, o el punto en el que se debe situar nuestro personaje al comenzar el nivel. Vamos a ver cada uno de estos tipos de capas con m\u00e1s detenimiento. Capas de patrones \u00b6 Como hemos indicado anteriormente, las capas de patrones nos permiten definir el aspecto del nivel mediante un mosaico, utilizando un conjunto de patrones para fijar el contenido de cada celda del mosaico. Cuando creamos varias capas de patrones, ser\u00e1 importante fijar su orden, ya que las capas que est\u00e9n al frente tapar\u00e1n a las que est\u00e9n atr\u00e1s. Este orden viene determinado por el orden en el que las capas aparecen en la lista del panel derecho. Las capas al comienzo de la lista quedar\u00e1n por delante de las dem\u00e1s. Podemos cambiar el orden de las capas en esta lista mediante los botones con las flechas hacia arriba y hacia abajo para conseguir situar cada una de ellas en la profundidad adecuada. Las utilidades de esta divisi\u00f3n en capas son varias: Aspecto : Un primer motivo para utilizar diferentes capas puede ser simplemente por cuestiones de aspecto, para combinar varios elementos en una misma celda. Por ejemplo, en una capa de fondo podr\u00edamos poner el cielo, y en una capa m\u00e1s cercana una reja con fondo transparente. De esa forma ese mismo recuadro con la reja podr\u00eda ser utilizado en otra parte del escenario con un fondo distinto (por ejemplo de monta\u00f1as), pudiendo as\u00ed con \u00fanicamente 3 recuadros obtener 4 configuraciones diferentes: cielo, monta\u00f1a, cielo con reja, y monta\u00f1a con reja. Colisiones : Puede interesarnos que los elementos de una capa nos sirvan para detectar colisiones con los objetos del juego. Por ejemplo, podemos en ella definir muros que los personajes del juego no podr\u00e1n atravesar. Consideraremos desde nuestro juego que todas las celdas definidas en esa capa suponen regiones que deben colisionar con nuestros sprites . Consumibles : Podemos definir una capa con objetos que podamos recoger. Por ejemplo podr\u00edamos definir una capa con monedas, de forma que cada vez que el usuario entra en una celda con una moneda dicha moneda sea eliminada del mapa y se nos a\u00f1ada a un contador de puntuaci\u00f3n. Vamos a ver ahora c\u00f3mo implementar en nuestro juego los anteriores usos, que nos permitan detectar colisiones con las celdas y modificar en el programa el contenido de las mismas para poder introducir en ellas elementos consumibles. La base para hacer todo esto es poder obtener cada capa individual del mapa para poder trabajar con sus elementos. Esto lo haremos con la clase CCTMXLayer : 1 TMXLayer * capa = fondo -> layerNamed ( \"muros\" ); Colisiones con el mapa \u00b6 La detecci\u00f3n de colisiones con los muros del fondo ser\u00e1 muy \u00fatil en juegos de tipo RPG o de plataformas. Para hacer esto lo primero que debemos hacer es obtener la capa que define los elementos que se comportan como \"muro\" tal como hemos visto anteriormente. De esta capa necesitaremos tener alguna forma de identificar qu\u00e9 celdas definen muros. La forma m\u00e1s adecuada de marcar estas celdas consiste en darles una serie de propiedades que nuestro programa podr\u00e1 leer y as\u00ed comprobar si se trata de un muro con el que podemos colisionar o no. Para asignar propiedades a un objeto del conjunto de patrones dentro de Tiled podemos pulsar con el bot\u00f3n derecho sobre \u00e9l, y seleccionar Propiedades del Patr\u00f3n... . Se abrir\u00e1 un cuadro como el siguiente donde podremos definir dichas propiedades: Lo que deberemos hacer es marcar todos los objetos del conjunto de patrones que sirvan para definir muros con una misma propiedad que los marque como tal. En el c\u00f3digo de nuestro juego podremos leer estas propiedades de la siguiente forma: 1 2 3 4 5 6 7 8 9 10 11 12 Point tileCoords = Point ( fila , columna ); int tileGid = capa -> getTileGIDAt ( tileCoords ); if ( tileGid ) { auto properties = fondo -> getPropertiesForGID ( tileGid ); if ( ! properties . isNull ()) { bool collision = properties . asValueMap (). at ( \"colisionable\" ). asBool (); if ( collision ) { ... } } } El gid de cada celda nos indica el tipo de objeto de patr\u00f3n que tenemos en ella. Si la celda est\u00e1 vac\u00eda el gid ser\u00e1 0 . En una versi\u00f3n m\u00e1s sencilla, podr\u00edamos considerar que todas las celdas de la capa son colisionables y simplemente comprobar si el gid es distinto de 0 . De todas formas, el uso de propiedades hace m\u00e1s flexible nuestro motor del juego, para por ejemplo en el futuro implementar distintos tipos de colisiones. Para comprobar las colisiones de nuestro sprite con los muros una primera aproximaci\u00f3n podr\u00eda consistir en hacer la comprobaci\u00f3n con todas las celdas de la capa. Sin embargo esto no resulta nada eficiente ni adecuado. La soluci\u00f3n que se suele utilizar habitualmente consiste en comprobar la colisi\u00f3n \u00fanicamente con las celdas de nuestro entorno. Haremos lo siguiente: Obtendremos la posici\u00f3n en las que est\u00e1 centrado nuestro sprite . Calcularemos las coordenadas de la celda a la que corresponde (dividiendo entre la anchura y altura de cada celda). Obtendremos los gid de las 9 celdas adyacentes. Comprobaremos si colisiona con alguna de ellas, corrigiendo la posici\u00f3n del sprite en tal caso. A continuaci\u00f3n mostramos un ejemplo de c\u00f3digo en el que obtendr\u00edamos cada una de las celdas adyacentes a un sprite . En primer lugar vamos a crear una serie de m\u00e9todos auxiliares. El primero de ellos nos devolver\u00e1 las coordenadas de una celda a partir de las coordenadas de la escena (dividiendo entre el tama\u00f1o de cada celda): 1 2 3 4 5 6 7 8 9 Point Game :: tileCoordForPosition ( Point position ) { Size tileSize = _tiledMap -> getTileSize (); float totalHeight = _tiledMap -> getMapSize (). height * tileSize . height ; float x = floor ( position . x / tileSize . width ); float y = floor (( totalHeight - position . y ) / tileSize . height ); return Point ( x , y ); } Hay que destacar que las coordenadas y del mapa est\u00e1n invertidas respecto a las de la escena. Por ese motivo es necesario calcular la altura total y hacer la resta. Tambi\u00e9n vamos a definir un m\u00e9todo que nos devuelva el \u00e1rea ( Rect ) que ocupa en la escena una celda dada: 1 2 3 4 5 6 7 8 9 Rect Game :: rectForTileAt ( CCPoint tileCoords ) { Size tileSize = _tiledMap -> getTileSize (); float totalHeight = _tiledMap -> getMapSize (). height * tileSize . height ; Point origin ( tileCoords . x * tileSize . width , totalHeight - (( tileCoords . y + 1 ) * tileSize . height )); return Rect ( origin . x , origin . y , tileSize . width , tileSize . height ); } Por \u00faltimo, crearemos un m\u00e9todo que nos diga si una determinada celda es colisionable o no. Consideraremos que las celdas fuera del mapa no son colisionables (aunque seg\u00fan el caso podr\u00eda interesarnos hacerlo al rev\u00e9s): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 bool Game :: isCollidableTileAt ( Point tileCoords ) { // Consideramos que celdas fuera del mapa no son nunca colisionables if ( tileCoords . x < 0 || tileCoords . x >= _tiledMap -> getMapSize (). width || tileCoords . y < 0 || tileCoords . y >= _tiledMap -> getMapSize (). height ) { return false ; } TMXLayer * layerMuros = _tiledMap -> getLayer ( \"muros\" ); int tileGid = layerMuros -> getTileGIDAt ( tileCoords ); if ( tileGid ) { auto properties = _tiledMap -> getPropertiesForGID ( tileGid ); if ( ! properties . isNull ()) { bool collision = properties . asValueMap (). at ( \"colisionable\" ). asBool (); return collision ; } } return false ; } Una vez hecho esto, podremos calcular las colisiones con las celdas adyacentes a nuestro personaje y tomar las acciones oportunas. Por ejemplo, en el caso sencillo en el que s\u00f3lo necesitamos calcular las colisiones a la izquierda y a la derecha, podremos utilizar el siguiente c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 Size tileSize = _tiledMap -> getTileSize (); Point tileCoord = this -> tileCoordForPosition ( _spritePersonaje -> getPosition ()); Point tileLeft ( tileCoord . x - 1 , tileCoord . y ); Point tileRight ( tileCoord . x + 1 , tileCoord . y ); if ( this -> isCollidableTileAt ( tileLeft )) { Rect tileRect = this -> rectForTileAt ( tileLeft ); if ( tileRect . intersectsRect ( _spritePersonaje -> getBoundingBox ())) { this -> detenerPersonaje (); _spritePersonaje -> setPosition ( Vec2 ( tileRect . origin . x + tileRect . size . width + _spritePersonaje -> getContentSize (). width / 2 , tileSize . height + _spritePersonaje -> getContentSize (). height / 2 )); } } if ( this -> isCollidableTileAt ( tileRight )) { Rect tileRect = this -> rectForTileAt ( tileRight ); if ( tileRect . intersectsRect ( _spritePersonaje -> getBoundingBox ())) { this -> detenerPersonaje (); _spritePersonaje -> setPosition ( Vec2 ( tileRect . origin . x - _spritePersonaje -> getContentSize (). width / 2 , tileSize . height + _spritePersonaje -> getContentSize (). height / 2 )); } } Por supuesto, la forma de obtener estas celdas depender\u00e1 del tama\u00f1o del sprite . Si ocupase m\u00e1s de una celda deberemos hacer la comprobaci\u00f3n con todas las celdas de nuestro entorno a las que pudiera alcanzar. Una vez detectada la colisi\u00f3n, el \u00faltimo paso hemos visto que consistir\u00eda en parar el movimiento del sprite . Si conocemos la posici\u00f3n de la celda respecto al sprite (arriba, abajo, izquierda, derecha) nos ser\u00e1 de gran ayuda, ya que sabremos que deberemos posicionarlo justo pegado a esa celda en el lateral que ha colisionado con ella. En el ejemplo anterior, seg\u00fan colisione con la celda izquierda o derecha, posicionamos al sprite pegado a la derecha o a la izquierda del muro respectivamente. Modificaci\u00f3n del mapa \u00b6 En muchos casos nos interesar\u00e1 tener en el mapa objetos que podamos modificar. Por ejemplo, monedas u otros items que podamos recolectar, u objetos que podemos destruir. Para conseguir esto podemos definir una capa con dichos objetos, y marcarlos con una propiedad que nos indique que son \"recolectables\" o \"destruibles\". Una vez hecho esto, desde nuestro c\u00f3digo podemos obtener la capa que contenga dichos objetos recolectables, por ejemplo \"monedas\": 1 TMXLayer * monedas = fondo -> getLayer ( \"monedas\" ); De esta capa podremos eliminar los objetos \"recolectables\" cuando nuestro personaje los recoja. Para hacer esto podemos utilizar el siguiente m\u00e9todo: 1 monedas -> removeTileAt ( tileCoord ); Tambi\u00e9n podr\u00edamos cambiar el tipo de elemento que se muestra en una celda (por ejemplo para que al tocar una moneda cambie de color). Esto lo haremos especificando el nuevo gid que tendr\u00e1 la celda: 1 monedas -> setTileGID ( GID_MONEDA_ROJA , tileCoord ); Para cambiar o modificar los elementos recolectables primero deberemos comprobar si nuestro personaje \"colisiona\" con la celda en la que se encuentran, de forma similar a lo visto en el punto anterior: 1 2 3 4 5 6 7 8 9 10 11 12 Point tileCoords = this -> tileCoordForPosition ( _sprite -> getPosition ()); int tileGid = monedas -> getTileGIDAt ( tileCoords ); if ( tileGid ) { auto properties = fondo -> getPropertiesForGID ( tileGid ); if ( ! properties . isNull ()) { bool recolectable = properties . asValueMap (). at ( \"recolectable\" ). asBool (); if ( recolectable ) { monedas -> removeTileAt ( tileCoords ); } } } En este caso \u00fanicamente comprobamos la celda en la que se encuentra nuestro personaje, no las adyacentes. Si el personaje fuese de mayor tama\u00f1o deber\u00edamos comprobar todas las celdas del entorno que pudiera abarcar. Capas de objetos \u00b6 Hasta el momento hemos visto las capas de patrones, que se construyen como un mosaico de celdas que definir\u00e1 el aspecto del fondo. Existe otro tipo de capa que podemos incluir en nuestro dise\u00f1o del fondo que no se limita al mosaico de celdas, sino que nos permite marcar cualquier regi\u00f3n del mapa sin ajustarse a la rejilla de celdas. Estas son las capas de objetos. En estas capas podremos por ejemplo marcar zonas de mapas donde aparecen enemigos, o donde se situa autom\u00e1ticamente nuestro personaje al iniciar el nivel. Cuando a\u00f1adamos y seleccionemos una capa de objetos, en la barra de herramientas superior se activar\u00e1n dos iconos que nos permitir\u00e1n crear nuevos objetos y seleccionar y cambiar las propiedades de los objetos existentes. Pulsando el bot\u00f3n con el \"cubo azul\" podremos a\u00f1adir un nuevo objeto a la escena. El objeto se definir\u00e1 como un rect\u00e1ngulo (deberemos pulsar y arrastrar el rat\u00f3n sobre el escenario para definir dicho rect\u00e1ngulo). Tras crear un objeto, podremos cambiar a la herramienta para la selecci\u00f3n y modificaci\u00f3n de objetos, seleccionar el objeto que acabamos de crear, pulsar sobre \u00e9l con el bot\u00f3n derecho, y seleccionar la opci\u00f3n Propiedades del Objeto ... . Veremos una ventana como la siguiente, en la que podremos darle un nombre, modificar sus dimensiones, y a\u00f1adir una lista de propiedades. Lectura de la capa de objetos Una vez le hayamos dado un nombre al objeto, podremos obtenerlo desde el c\u00f3digo de nuestro juego. Para ello primero deberemos obtener la capa de objetos (representada con la clase TMXObjectGroup ) a partir del nombre que le hemos dado ( objetos en este ejemplo): 1 TMXObjectGroup * objects = fondo -> getObjectGroup ( \"objetos\" ); A partir de esta capa podremos obtener uno de sus objetos dando su nombre. Por ejemplo, si hemos creado un objeto con nombre inicio , podremos obtenerlo de la siguiente forma: 1 auto inicio = objects -> getObject ( \"inicio\" ); Como vemos, el objeto se obtiene como un diccionario. De \u00e9l podemos obtener diferentes propiedades, como sus coordenadas: 1 2 3 4 int x = inicio . at ( \"x\" ). asInt (); int y = inicio . at ( \"y\" ). asInt (); _sprite -> setPosition ( Vec2 ( x , y )); De esta forma en el c\u00f3digo obtenemos la posici\u00f3n que ocupa el objeto y podemos utilizar esta posici\u00f3n para su prop\u00f3sito (por ejemplo para situar en ella inicialmente a nuestro personaje, o hacer que en ese punto aparezcan nuevos enemigos). Formas geom\u00e9tricas En la capa de objetos podemos incluir formas geom\u00e9tricas, como por ejemplo l\u00edneas o polil\u00edneas. Esto puede ser especialmente \u00fatil para definir la geometr\u00eda de colisi\u00f3n del escenario y posteriormente cargarla en el motor de f\u00edsicas. La capa de objetos geom\u00e9tricos se carga de forma similar a los objetos gen\u00e9ricos definidos por el usuario. Por ejemplo, si nuestros objetos geom\u00e9tricos de la capa de objetos son todos ellos polil\u00edneas, podemos cargarlos de la siguiente forma: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 TMXObjectGroup * groupEdges = _tiledMap -> getTiledMap () -> getObjectGroup ( \"MyEdges\" ); ValueVector edges = groupsEdges -> getObjects (); for ( Value edge : edges ) { ValueVector polyline = edge . asValueMap (). at ( \"polylinePoints\" ). asValueVector (); // Calculamos la coordenadas absolutas del objeto float x = edge . asValueMap (). at ( \"x\" ). asFloat () + _tiledMap -> getTiledMap () -> getPositionX (); float y = edge . asValueMap (). at ( \"y\" ). asFloat () + _tiledMap -> getTiledMap () -> getPositionY (); for ( Value point : polyline ) { float px = point . asValueMap (). at ( \"x\" ). asFloat () + x ; float py = point . asValueMap (). at ( \"y\" ). asFloat () + y ; // Hacemos algo con (px, py) ... } } Si no conocemos c\u00f3mo est\u00e1 organizada la capa de objetos, podemos consultar el fuente XML del fichero .tmx . Tambi\u00e9n tenemos la opci\u00f3n de imprimir en la consola el objeto que nos devuelve getObjects , y de esta forma veremos su estructura en JSON y podremos as\u00ed escribir el c\u00f3digo para leerlo. Scroll del escenario \u00b6 Cuando en el juego tenemos un mapa m\u00e1s extenso que el tama\u00f1o de la pantalla, tendremos que implementar scroll para movernos por \u00e9l. Para hacer scroll podemos desplazar la capa principal del juego, que contiene tanto el mapa de fondo como los sprites : 1 this -> setPosition ( Vec2 ( scrollX , scrollY )); En este ejemplo anterior, this ser\u00eda nuestra capa principal. En este caso es importante resaltar que si queremos implementar un HUD (para mostrar puntuaciones, n\u00famero de vidas, etc) la capa del HUD no debe a\u00f1adirse como hija de la capa principal, sino que deberemos a\u00f1adirla directamente como hija de la escena ( Scene ), ya que de no ser as\u00ed el HUD se mover\u00eda con el scroll . Normalmente el scroll deber\u00e1 seguir la posici\u00f3n de nuestro personaje. Conforme movamos nuestro personaje deberemos centrar el mapa: 1 2 3 4 5 6 7 8 void Game :: centerViewport () { Size screenSize = Director :: getInstance () -> getWinSize (); float x = screenSize . width / 2.0 - _sprite -> getPosition (). x ; float y = screenSize . height / 2.0 - _sprite -> getPosition (). y ; this -> setPosition ( Vec2 ( x , y )); } El m\u00e9todo anterior deber\u00e1 invocarse cada vez que se cambie la posici\u00f3n del sprite . Lo que har\u00e1 es desplazar todo el escenario del juego de forma que el sprite quede situado justo en el centro de la pantalla. Podemos observar que se obtiene el tama\u00f1o de la pantalla a partir de Director , y calculamos el desplazamiento (x,y) necesario para que el sprite quede situado justo en el punto central. L\u00edmites del escenario \u00b6 El problema de la implementaci\u00f3n anterior es que el escenario no es infinito, y cuando lleguemos a sus l\u00edmites normalmente querremos no salirnos de ellos para no dejar en la pantalla espacio vac\u00edo. Deberemos por lo tanto detener el scroll del fondo cuando hayamos llegado a su l\u00edmite. Esto podemos resolverlo a\u00f1adiendo algunos if al c\u00f3digo anterior: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void Game :: centerViewport () { Size screenSize = Director :: getInstance () -> getWinSize (); Size tileSize = _tiledMap -> getTileSize (); float offsetX = screenSize . width / 2.0 - _sprite -> getPosition (). x ; float offsetY = screenSize . height / 2.0 - _sprite -> getPosition (). y ; // Comprueba l\u00edmites en la dimension x if ( offsetX > 0 ) { offsetX = 0 ; } else if ( offsetX < screenSize . width - tileSize . width * _tiledMap -> getMapSize (). width ) { offsetX = screenSize . width - tileSize . width * _tiledMap -> getMapSize (). width ; } // Comprueba l\u00edmites en la dimension y if ( offsetY > 0 ) { offsetY = 0 ; } else if ( offsetY < screenSize . height - tileSize . height * _tiledMap -> getMapSize (). height ) { offsetY = screenSize . height - tileSize . height * _tiledMap -> getMapSize (). height ; } this -> setPosition ( Vec2 ( offsetX , offsetY )); } Con este c\u00f3digo evitaremos que en el visor veamos zonas fuera de los l\u00edmites del mapa. La posici\u00f3n m\u00ednima que se mostrar\u00e1 ser\u00e1 0 , y la m\u00e1xima el tama\u00f1o del mapa (se calcula como el n\u00famero de celdas mapSize por el tama\u00f1o de cada celda tileSize ). Cuando lleguemos a estos l\u00edmites nuestro personaje seguir\u00e1 movi\u00e9ndose, pero ya no estar\u00e1 centrado en la pantalla, el mapa permanecer\u00e1 fijo y el personaje se mover\u00e1 sobre \u00e9l. Scroll parallax \u00b6 En juegos 2D podemos crear una ilusi\u00f3n de profundidad creando varias capas de fondo y haciendo que las capas m\u00e1s lejanas se muevan a velocidad m\u00e1s lenta que las m\u00e1s cercanas al hacer scroll . Esto es lo que se conoce como scroll parallax . En Cocos2D es sencillo implementar este tipo de scroll , ya que contamos con el tipo de nodo ParallaxNode que define este comportamiento. Este nodo nos permite a\u00f1adir varios hijos, y hacer que cada uno de ellos se desplace a una velocidad distinta. 1 2 3 4 5 6 7 ParallaxNode * parallax = ParallaxNode :: create (); parallax -> addChild ( scene , 3 , Vec2 ( 1 , 1 ), Vec2 ( 0 , 0 )); parallax -> addChild ( mountains , 2 , Vec2 ( 0.25 , 1 ), Vec2 ( 0 , 0 )); parallax -> addChild ( sky , 1 , Vec2 ( 0.01 , 1 ), Vec2 ( 0 , 0 )); this -> addChild ( parallax , - 1 ); Podemos a\u00f1adir cualquier nodo como capa al scroll parallax , como por ejemplo sprites o tilemaps . Con parallax ratio especificamos la velocidad a la que se mueve la capa. Si ponemos un ratio de 1 hacemos que se mueva a la velocidad real que estemos moviendo la capa principal de nuestra escena. Si ponemos 0.5 , se mover\u00e1 a mitad de la velocidad. Reproducci\u00f3n de audio \u00b6 En un videojuego normalmente reproduciremos una m\u00fasica de fondo, normalmente de forma c\u00edclica, y una serie de efectos de sonido (disparos, explosiones, etc). En Cocos2D tenemos la librer\u00eda CocosDenshion que nos permite reproducir este tipo de audio de forma apropiada para videojuegos. La forma m\u00e1s sencilla de utilizar esta librer\u00eda es mediante el objeto singleton SimpleAudioEngine . Podemos acceder a \u00e9l de la siguiente forma: 1 2 3 4 5 6 #include \"SimpleAudioEngine.h\" ... SimpleAudioEngine * audio = CocosDenshion :: SimpleAudioEngine :: getInstance (); M\u00fasica de fondo \u00b6 Podemos reproducir como m\u00fasica de fondo cualquier formato soportado por el dispositivo (MP3, M4A, etc). Para ello utilizaremos el m\u00e9todo playBackgroundMusic del objeto audio engine : 1 audio -> playBackgroundMusic ( \"musica.m4a\" , true ); Lo habitual ser\u00e1 reproducir la m\u00fasica en bucle, por ejemplo mientras estamos en un men\u00fa o en un nivel del juego. Por ese motivo contamos con el segundo par\u00e1metro ( loop ) que nos permite utilizar de forma sencilla esta caracter\u00edstica. Podemos deterner la reproducci\u00f3n de la m\u00fasica de fondo en cualquier momento con: 1 audio -> stopBackgroundMusic (); Tambi\u00e9n podemos a trav\u00e9s de este objeto cambiar el volumen de la m\u00fasica de fondo (se debe espeficiar un valor de 0 a 1 ): 1 audio -> setBackgroundMusicVolume ( 0.9 ); Efectos de sonido \u00b6 Los efectos de sonido sonar\u00e1n cuando suceda un determinado evento (disparo, explosi\u00f3n, pulsaci\u00f3n de un bot\u00f3n), y ser\u00e1 normalmente una reproducci\u00f3n de corta duraci\u00f3n. Una caracter\u00edstica de estos efectos es que deben sonar de forma inmediata al suceder el evento que los produce. Causar\u00eda un mal efecto que un disparo sonase con un retardo respecto al momento en el que se produjo. Sin embargo, la reproducci\u00f3n de audio normalmente suele causar un retardo, ya que implica cargar las muestras del audio del fichero y preparar los bufferes de memoria necesarios para su reproducci\u00f3n. Por ello, en un videojuego es importante que todos estos efectos se encuentren de antemano preparados para su reproducci\u00f3n, para evitar estos retardos. Con Cocos2D podremos precargar un fichero de audio de la siguiente forma: 1 2 audio -> preloadEffect ( \"explosion.caf\" ); audio -> preloadEffect ( \"disparo.caf\" ); Esto deberemos hacerlo una \u00fanica vez antes de comenzar el juego (un buen lugar puede ser el m\u00e9todo init de nuestra capa del juego). Una vez cargados, podremos reproducirlos de forma inmediata con playEffect : 1 audio -> playEffect ( \"explosion.caf\" ); Una vez no vayamos a utilizar estos efectos de sonido, deberemos liberarlos de memoria: 1 2 audio -> unloadEffect ( \"explosion.caf\" ); audio -> unloadEffect ( \"disparo.caf\" ); Esto se puede hacer cuando vayamos a pasar a otra escena en la que no se vayan a necesitar estos efectos. Por \u00faltimo, al igual que en el caso de la m\u00fasica de fondo, podremos cambiar el volumen de los efectos de sonido con: 1 audio -> setEffectsVolume ( 0.6 ); De esta forma podremos tener dos niveles de volumen independientes para la m\u00fasica de fondo y para los efectos de sonido. Los videojuegos normalmente nos presentan en sus opciones la posibilidad de que el usuario ajuste cada uno de estos dos vol\u00famenes seg\u00fan sus preferencias.","title":"Cocos2d-x"},{"location":"cocos2d-x.html#el-motor-cocos2d-x","text":"Uno de los motores m\u00e1s conocidos y utilizados para desarrollo de videojuegos para dispositivos m\u00f3viles es Cocos2D . Existe gran cantidad de juegos para iOS implementados con este motor. Aunque inicialmente se trataba de un motor escrito en Objective-C \u00fanicamente para iOS, actualmente contamos con Cocos2d-x (http://www.cocos2d-x.org) que es la versi\u00f3n multiplataforma de este motor. El juego se desarrolla con C++, y puede ser portado directamente a distintos tipos de dispositivos (Android, iOS, Windows Phone, etc). Vamos a comenzar estudiando la forma de crear los diferentes componentes de un videojuego mediante el motor Cocos2d-x.","title":"El motor cocos2d-x"},{"location":"cocos2d-x.html#instalacion-de-cocos2d-x","text":"Existen dos formas de instalar Cocos2d-x: Instalar \u00fanicamente el framework , con lo que tendremos todo el c\u00f3digo fuente de la librer\u00eda y comandos del terminal para crear nuevos proyectos que la utilicen Instalar todo el kit de herramientas de Cocos, que nos proporciona una interfaz para la creaci\u00f3n de nuevos proyectos, una herramienta visual para la creaci\u00f3n de escenas ( Cocos Studio ), y la posibilidad de utilizar una versi\u00f3n precompilada de la librer\u00eda, lo cual ahorrar\u00e1 mucho tiempo de compilaci\u00f3n en nuestro proyecto. Elegiremos la primera opci\u00f3n si queremos modificar el c\u00f3digo de la librer\u00eda y hacer alguna contribuci\u00f3n al proyecto, mientras que en otros casos ser\u00eda m\u00e1s conveniente utilizar la segunda.","title":"Instalaci\u00f3n de Cocos2d-x"},{"location":"cocos2d-x.html#creacion-del-proyecto-con-cocos","text":"Si instalamos el kit completo de herramientas, contaremos con la herramienta Cocos que nos permitir\u00e1 crear un nuevo proyecto multiplataforma con esta librer\u00eda, y gestionar los proyectos existentes. Al crear un nuevo proyecto nos dejar\u00e1 elegir: Nombre del proyecto . Ruta del directorio de proyectos . Ruta del disco donde se almacenar\u00e1 el proyecto Cocos2d-x. Ser\u00e1 un directorio con el nombre indicado en el campo anterior. Tipo de motor . Podemos elegir si queremos que nuestro proyecto integre los fuentes de la librer\u00eda de Cocos2d-x, o s\u00f3lo los binarios. Con la primera opci\u00f3n la compilaci\u00f3n ser\u00e1 m\u00e1s lenta, pero nos permitir\u00e1 hacer cambios en la librer\u00eda si es necesario. Lenguaje de desarrollo . Adem\u00e1s de C++, podremos tambi\u00e9n crear videojuegos mediante lenguajes de script como Lua o Javascript. Editor . Nos permite indicar si queremos utilizar Cocos Studio para la edici\u00f3n visual de las escenas. SDKs . Nos permite incluir plugins adicionales para integrar servicios nativos de la plataforma o servicios de terceros, como por ejemplo redes sociales o anal\u00edticas.","title":"Creaci\u00f3n del proyecto con Cocos"},{"location":"cocos2d-x.html#creacion-del-proyecto-desde-la-terminal","text":"Tanto si tenemos el kit completo como s\u00f3lo el framework , tendremos la opci\u00f3n de crear un nuevo proyecto desde la terminal. Al descargar y descomprimir Cocos2d-x, veremos en el directorio raiz de la libreria un script llamado setup.py . Este hay que ejecutarlo una vez despu\u00e9s de haber descomprimido la libreria (si utilizamos el instalador esto se har\u00e1 de forma autom\u00e1tica). Este mismo script nos introducira en nuestro fichero ~/.profile las rutas necesarias para utilizar la libreria desde l\u00ednea de comandos. De manera manual podr\u00edamos cargar dichas variables mediante el comando source ~/.profile , pero eso se realizar\u00e1 de manera autom\u00e1tica cada vez que abramos una nueva terminal. De esta manera tendremos acceso a un script llamado cocos que permite entre otras cosas crear la plantilla para un nuevo proyecto Cocos2d-x multiplataforma. Deberemos proporcionar la siguiente informaci\u00f3n: 1 2 3 cocos new MiJuego -p es.ua.dccia -l cpp -d MisProyectosCocos Esto nos crear\u00e1 un proyecto (carpeta) MiJuego en la subcarpeta MisProyectosCocos del directorio donde nos encontremos. El lenguaje utilizado ser\u00e1 C++ ( -l cpp ). La plantilla del nuevo proyecto ser\u00e1 la misma para todos los sistema soportados. Por ejemplo, si queremos trabajar con la versi\u00f3n de iOS, dentro del directorio de nuestro proyecto entraremos en la subcarpeta proj.ios_mac y abriremos el proyecto Xcode. Todas las plataformas comparten los mismos directorio de clases ( Classes ) y recursos ( Resources ) de nuestro juego. S\u00f3lo cambian los ficheros de configuraci\u00f3n del proyecto que los \"envuelve\". Podremos de esta forma crear un nuevo proyecto que contendr\u00e1 la base para implementar un videojuego que utilice las librer\u00edas de Cocos2d-x. El elemento central de este motor es un singleton de tipo Director , al que podemos acceder de la siguiente forma: 1 Director :: getInstance ()","title":"Creaci\u00f3n del proyecto desde la terminal"},{"location":"cocos2d-x.html#tipos-de-datos","text":"Como hemos comentado, Cocos2d-x proviene del motor Cocos2d para iOS. Este motor estaba implementado en Objective-C, sobre la API Cocoa Touch, y por lo tanto estaba muy vinculado a sus tipos de datos. Por este motivo Cocos2d-x implementa sus propios tipos de datos equivalentes a los de Cocoa Touch para poder trabajar de la misma forma. Vamos a ver cu\u00e1les son estos tipos de datos. Por un lado tenemos la clase Ref . Todos los objetos de la librer\u00eda heredan en \u00faltima instancia de esta clase. En ella se define por ejemplo el mecanismo de gesti\u00f3n de memoria que utilizan todos los objetos de la librer\u00eda. Tenemos una serie de colecciones como Vector<> , Map<> especiales de Cocos2d-x que tienen en cuenta su modelo particular de memoria, pero con los que podremos utilizar la sintaxis de C++ para este tipo de colecciones. Tambi\u00e9n tenemos los tipos Value , ValueVector y ValueMap para la representaci\u00f3n de estructuras de datos, que nos permiten por ejemplo cargar ficheros .plist de forma autom\u00e1tica. El primero de ellos es un wrapper que permite almacenar tipos b\u00e1sicos ( bool , int , string , etc) o complejos, mientras que los otros dos representan las listas y diccionarios respectivamente. Encontramos tambi\u00e9n una serie de tipos de datos geom\u00e9tricos: Point , Rect y Size . Estos tipos de datos incorporan tambi\u00e9n algunas operaciones, por ejemplo para comprobar si dos rect\u00e1ngulos intersectan.","title":"Tipos de datos"},{"location":"cocos2d-x.html#escena-2d","text":"En Cocos2D cada pantalla se representa mediante un objeto de tipo Scene . En la pantalla del juego se dibujar\u00e1n todos los elementos necesarios (fondos, sprites , etc) para construir la escena del juego. De esta manera tendremos el fondo, nuestro personaje, los enemigos y otros objetos que aparezcan durante el juego, adem\u00e1s de marcadores con el n\u00famero de vidas, puntuaci\u00f3n, etc. Todos estos elementos se representan en Cocos2D como nodos del tipo Node . La escena se compondr\u00e1 de una serie de nodos organizados de forma jer\u00e1rquica. Entre estos nodos podemos encontrar diferentes tipos de elementos para construir la interfaz del videojuego, como etiquetas de texto, men\u00fas, sprites , fondos, etc. Otro de estos tipos de nodos son las capas. La escena se podr\u00e1 componer de una o varias capas. Los sprites y fondos pueden organizarse en diferentes capas para construir la escena. Todas las capas podr\u00e1n moverse o cambiar de posici\u00f3n, para mover de esta forma todo su contenido en la pantalla. Pondremos varios elementos en una misma capa cuando queramos poder moverlos de forma conjunta. Las capas en Cocos2D se representan mediante la clase Layer o Node (en las \u00faltimas versiones del motor las diferencias entre ambas clases son m\u00ednimas, y se recomienda organizar el juego mediante nodos). Las escenas podr\u00e1n componerse de una o varias capas, y estas capas contendr\u00e1n los distintos nodos a mostrar en pantalla, que podr\u00edan ser a su vez otras capas. Es decir, la escena se representar\u00e1 como un grafo, en el que tenemos una jerarqu\u00eda de nodos, en la que determinados nodos, como es el caso de la escena o las capas, podr\u00e1n contener otros nodos. Este tipo de representaci\u00f3n se conoce como escena 2D . Normalmente para cada pantalla del juego tendremos una capa principal, y encapsularemos el funcionamiento de dicha pantalla en una subclase de Layer , por ejemplo: 1 2 3 4 5 6 7 8 9 class MenuPrincipal : public cocos2d :: Layer { public : virtual bool init (); static cocos2d :: Scene * scene (); CREATE_FUNC ( MenuPrincipal ); }; Crearemos la escena a partir de su capa principal. Todos los nodos, incluyendo la escena, se instanciar\u00e1n mediante el m\u00e9todo de factor\u00eda create . Este m\u00e9todo de factor\u00eda se genera de forma est\u00e1tica con la macro CREATE_FUNC , por ese motivo est\u00e1 declarada en la interfaz de clase anterior. Podemos a\u00f1adir un nodo como hijo de otro nodo con el m\u00e9todo addChild : 1 2 3 4 5 6 7 Scene * MenuPrincipal :: scene () { Scene * scene = Scene :: create (); MenuPrincipal * layer = MenuPrincipal :: create (); scene -> addChild ( layer , 0 ); return scene ; } Cuando instanciamos un nodo mediante el m\u00e9todo de factor\u00eda create , llamar\u00e1 a su m\u00e9todo init para inicializarse. Si sobrescribimos dicho m\u00e9todo en la capa podremos definir la forma en la que se inicializa: 1 2 3 4 5 6 7 8 9 10 11 12 13 bool MenuPrincipal :: init () { // Inicializar primero la superclase if ( ! Layer :: init () ) { return false ; } // Inicializar componentes de la capa ... return true ; } El orden en el que se mostrar\u00e1n las capas es lo que se conoce como orden Z, que indica la profundidad de esta capa en la escena. La primera capa ser\u00e1 la m\u00e1s cercana al punto de vista del usuario, mientras que la \u00faltima ser\u00e1 la m\u00e1s lejana. Por lo tanto, las primeras capas que a\u00f1adamos quedar\u00e1n por delante de las siguientes capas. Este orden Z se puede controlar mediante la propiedad zOrder de los nodos.","title":"Escena 2D"},{"location":"cocos2d-x.html#transiciones-entre-escenas","text":"Mostraremos la escena inicial del juego con el m\u00e9todo runWithScene del director: 1 Director :: getInstance () -> runWithScene ( MenuPrincipal :: scene ()); Con esto pondremos en marcha el motor del juego mostrando la escena indicada. Si el motor ya est\u00e1 en marcha y queremos cambiar de escena, deberemos hacerlo con el m\u00e9todo replaceScene : 1 Director :: getInstance () -> replaceScene ( Puntuaciones :: scene ()); Tambi\u00e9n podemos implementar transiciones entre escenas de forma animada utilizando como escena una serie de clases todas ellas con prefijo Transition- , que heredan de TransitionScene , que a su vez hereda de Scene . Podemos mostrar una transici\u00f3n animada reemplazando la escena actual por una escena de transici\u00f3n: 1 2 3 4 Scene * puntuacionesScene = Puntuaciones :: scene (); TransitionCrossFade * transition = TransitionCrossFade :: create ( 0.5 , puntuacionScene ); Director :: getInstance () -> replaceScene ( transition ); Podemos observar que la escena de transici\u00f3n se construye a partir de la duraci\u00f3n de la transici\u00f3n, y de la escena que debe mostrarse una vez finalice la transici\u00f3n.","title":"Transiciones entre escenas"},{"location":"cocos2d-x.html#interfaz-de-usuario","text":"Encontramos distintos tipos de nodos que podemos a\u00f1adir a la escena para crear nuestra interfaz de usuario, como por ejemplo men\u00fas y etiquetas de texto, que nos pueden servir por ejemplo para mostrar el marcador de puntuaci\u00f3n, o el mensaje Game Over . Tenemos dos formas alternativas de crear una etiqueta de texto: Utilizar una fuente TrueType predefinida. Crear nuestro propio tipo de fuente bitmap . La primera opci\u00f3n es la m\u00e1s sencilla, ya que podemos crear la cadena directamente a partir de un tipo de fuente ya existen y a\u00f1adirla a la escena con addChild (por ejemplo a\u00f1adi\u00e9ndola como hija de la capa principal de la escena). Se define mediante la clase LabelTTF : 1 2 LabelTTF * label = LabelTTF :: create ( \"Game Over\" , \"Arial\" , 24 ); this -> addChild ( label ); Sin embargo, en un videojuego debemos cuidar al m\u00e1ximo el aspecto y la personalizaci\u00f3n de los gr\u00e1ficos. Por lo tanto, suele ser m\u00e1s adecuado crear nuestros propios tipos de fuentes. La mayor\u00eda de motores de videojuegos soportan el formato .fnt , con el que podemos definir fuentes de tipo bitmap personalizadas. Para crear una fuente con dicho formato podemos utilizar herramientas como Angel Code o Hiero (http://www.n4te.com/hiero/hiero.jnlp). Una vez creada la fuente con este formato, podemos mostrar una cadena con dicha fuente mediante la clase LabelBMFont : 1 2 LabelBMFont * label = LabelBMFont :: create ( \"Game Over\" , \"fuente.fnt\" ); this -> addChild ( label ); Por otro lado, tambi\u00e9n podemos crear men\u00fas de opciones. Normalmente en la pantalla principal del juego siempre encontraremos un men\u00fa con todas las opciones que nos ofrece dicho juego. Los men\u00fas se crean con la clase Menu , a la que a\u00f1adiremos una serie de items , de tipo MenuItem (o subclases suyas), que representar\u00e1n las opciones del men\u00fa. Estos items pueden ser etiquetas de texto, pero tambi\u00e9n podemos utilizar im\u00e1genes para darles un aspecto m\u00e1s vistoso. El men\u00fa se a\u00f1adir\u00e1 a la escena como cualquier otro tipo de item : 1 2 3 4 5 6 7 8 9 10 11 12 13 MenuItemImage * item1 = MenuItemImage :: create ( \"nuevo_juego.png\" , \"nuevo_juego_selected.png\" , CC_CALLBACK_1 ( MenuPrincipal :: menuNuevoJuegoCallback , this )); MenuItemImage * item2 = MenuItemImage :: create ( \"continuar.png\" , \"continuar_selected.png\" , CC_CALLBACK_1 ( MenuPrincipal :: menuContinuarCallback , this )); MenuItemImage * item3 = MenuItemImage :: create ( \"opciones.png\" , \"opciones_selected.png\" , CC_CALLBACK_1 ( MenuPrincipal :: menuOpcionesCallback , this )); Menu * menu = Menu :: create ( item1 , item2 , item3 , NULL ); menu -> alignItemsVertically (); this -> addChild ( menu ); Vemos que para cada item del men\u00fa a\u00f1adimos dos im\u00e1genes. Una para su estado normal, y otra para cuando est\u00e9 pulsado. Tambi\u00e9n propocionamos la acci\u00f3n a realizar cuando se pulse sobre cada opci\u00f3n, mediante un par target-selector : el target es el objeto sobre el que se va a llamar a la acci\u00f3n (normalmente nuestro propio objeto this ), y el selector es la forma de indicar el m\u00e9todo al que se va a invocar. Los m\u00e9todos indicados como selectores de tipo men\u00fa deber\u00e1n tener la siguiente forma: 1 2 3 4 void MenuPrincipal :: menuNuevoJuegoCallback ( Ref * pSender ) { Director :: getInstance () -> replaceScene ( Game :: scene ()); } Una vez creadas las opciones, construirmos un men\u00fa a partir de ellas, organizamos los items (podemos disponerlos en vertical de forma autom\u00e1tica como vemos en el ejemplo), y a\u00f1adimos el men\u00fa a la escena.","title":"Interfaz de usuario"},{"location":"cocos2d-x.html#gestion-de-la-memoria","text":"La memoria en Cocos2d-x se gestiona mediante cuenta de referencias, siguiendo el mismo mecanismo de gesti\u00f3n de memoria que utiliza Cocos2d al estar implementado en Objective-C. Este mecanismo consiste en que los objetos de la librer\u00eda (todos aquellos derivan de Ref ) tienen un contador de referencias que existen hacia ellos. Cuando el contador de referencias llegue a cero, el objeto se eliminar\u00e1 de memoria. Al instanciar un objeto (con new ) el objeto se crea con 1 referencia. Podemos incrementar el n\u00famero de referencias sobre un objeto llamando a su m\u00e9todo retain , y decrementarlo llamando a release . Deberemos asegurarnos de que el n\u00famero de llamadas a new / retain sobre un objeto sea igual al n\u00famero de llamadas a release . Si el primero fuese superior al segundo, entonces tendr\u00edamos una fuga de memoria. Si fuese inferior tendr\u00edamos un error de acceso a memoria cuando intentemos decrementar las referencias de un objeto que ha sido ya liberado. Si no organizamos bien el c\u00f3digo de gesti\u00f3n de memoria puede ser complicado garantizar que el n\u00famero de llamadas est\u00e9 equilibrado. Para evitar este problema la regla fundamental es que la unidad que incremente el n\u00famero de referencias ( new / retain ) ser\u00e1 responsable de decrementarlo ( release ). Vemos a continuaci\u00f3n con mayor detalle las implicaciones que esta regla tiene en el uso de la librer\u00eda: Cuando instanciamos un nodo con el m\u00e9todo factor\u00eda create este m\u00e9todo crea una referencia, pero \u00e9l mismo es responsable de eliminarla. Para conseguir esto lo que hace es dejar programado que la referencia se librere autom\u00e1ticamente cuando termine la llamada de la funci\u00f3n en la que estamos. Es decir, si nadie retiene el objeto que nos ha devuelto el objeto ser\u00e1 eliminado de memoria autom\u00e1ticamente. Cuando a\u00f1adimos un nodo como hijo de otro en la escena 2D, o cuando se a\u00f1ade a otras estructuras como el director, o alguna de las cach\u00e9s de objetos que gestiona el motor, estas estructuras se encargar de retener el objeto en memoria, y cuando se elimine de ellas lo liberar\u00e1n. Es decir, podemos por ejemplo crear un nodo con create y en ese momento a\u00f1adirlo como hijo a otro con addChild , y no tendremos que preocuparnos de retenerlo ni de liberarlo. El propio grafo de la escena ser\u00e1 el encargado de gestionar la memoria. Si queremos guardar un nodo como campo de nuestro objeto, tras instanciarlo con create deberemos reternarlo con retain para que no se libere autom\u00e1ticamente. Nosotros seremos responsables de liberarlo, por lo que deberemos llamar a release sobre dicho campo cuando nuestro objeto sea destruido, o cuando vayamos a cambiar el valor del campo y el antiguo deba ser liberado.","title":"Gesti\u00f3n de la memoria"},{"location":"cocos2d-x.html#sprites","text":"Podemos crear un sprite en Cocos2D con la clase Sprite a partir de la textura de dicho sprite : 1 Sprite * sprite = Sprite :: create ( \"personaje.png\" ); El sprite podr\u00e1 ser a\u00f1adido a la escena como cualquier otro nodo, a\u00f1adi\u00e9ndolo como hijo de alguna de las capas con addChild: .","title":"Sprites"},{"location":"cocos2d-x.html#posicion","text":"Al igual que cualquier nodo, un sprite tiene una posici\u00f3n en pantalla representada por su propiedad position , de tipo Vec2 (tambi\u00e9n podemos utilizar como tipo Point , ya que es un alias de Vec2 ). Por ejemplo, para posicionar un sprite en unas determinadas coordenadas le asignaremos un valor a su propiedad position (esto es aplicable a cualquier nodo): 1 sprite -> setPosition ( Vec2 ( 240 , 160 )); La posici\u00f3n indicada corresponde al punto central del sprite , aunque podr\u00edamos modificar esto con la propiedad anchorPoint , de forma similar a las capas de CoreAnimation. El sistema de coordenadas de Cocos2D es el mismo que el de CoreGraphics, el origen de coordenadas se encuentra en la esquina inferior izquierda, y las y son positivas hacia arriba. Podemos aplicar otras transformaciones al sprite , como rotaciones ( rotation ), escalados ( scale , scaleX , scaleY ), o desencajados ( skewX , skewY ). Tambi\u00e9n podemos especificar su orden Z ( zOrder ). Recordamos que todas estas propiedades no son exclusivas de los sprites , sino que son aplicables a cualquier nodo, aunque tienen un especial inter\u00e9s en el caso de los sprites .","title":"Posici\u00f3n"},{"location":"cocos2d-x.html#fotogramas","text":"Estos objetos pueden estar animados. Para ello deberemos definir los distintos fotogramas (o frames ) de la animaci\u00f3n. Podemos definir varias animaciones para cada sprite , seg\u00fan las acciones que pueda hacer. Por ejemplo, si tenemos un personaje podemos tener una animaci\u00f3n para andar hacia la derecha y otra para andar hacia la izquierda. El sprite tendr\u00e1 un determinado tama\u00f1o (ancho y alto), y cada fotograma ser\u00e1 una imagen de este tama\u00f1o. Cambiando el fotograma que se muestra del sprite en cada momento podremos animarlo. Para ello deberemos tener im\u00e1genes para los distintos fotogramas del sprite . Sin embargo, como hemos comentado anteriormente, la memoria de v\u00eddeo es un recurso cr\u00edtico, y debemos aprovechar al m\u00e1ximo el espacio de las texturas que se almacenan en ella. Recordemos que el tama\u00f1o de las texturas en memoria debe ser potencia de 2. Adem\u00e1s, conviene evitar empaquetar con la aplicaci\u00f3n un gran n\u00famero de im\u00e1genes, ya que esto har\u00e1 que el espacio que ocupan sea mayor, y que la carga de las mismas resulte m\u00e1s costosa. Para almacenar los fotogramas de los sprites de forma \u00f3ptima, utilizamos lo que se conoce como sprite sheets . Se trata de im\u00e1genes en las que incluyen de forma conjunta todos los fotogramas de los sprites , dispuestos en forma de mosaico. Podemos crear estos sprite sheets de forma manual, aunque encontramos herramientas que nos facilitar\u00e1n en\u00f3rmemente este trabajo, como TexturePacker (http://www.texturepacker.com). Esta herramienta cuenta con una versi\u00f3n b\u00e1sica gratuita, y opciones adicionales de pago. Adem\u00e1s de organizar los sprites de forma \u00f3ptima en el espacio de una textura OpenGL, nos permite almacenar esta textura en diferentes formatos (RGBA8888, RGBA4444, RGB565, RGBA5551, PVRTC) y aplicar efectos de mejora como dithering . Esta herramienta permite generar los sprite sheets en varios formatos reconocidos por los diferentes motores de videojuegos, como por ejemplo Cocos2D o libgdx. Con esta herramienta simplemente tendremos que arrastrar sobre ella el conjunto de im\u00e1genes con los distintos fotogramas de nuestros sprites , y nos generar\u00e1 una textura optimizada para OpenGL con todos ellos dispuestos en forma de mosaico. Cuando almacenemos esta textura generada, normalmente se guardar\u00e1 un fichero .png con la textura, y un fichero de datos que contendr\u00e1 informaci\u00f3n sobre los distintos fotogramas que contiene la textura, y la regi\u00f3n que ocupa cada uno de ellos. Para poder utilizar los fotogramas a\u00f1adidos a la textura deberemos contar con alg\u00fan mecanismo que nos permita mostrar en pantalla de forma independiente cada regi\u00f3n de la textura anterior (cada fotograma). En pr\u00e1cticamente todos los motores para videojuegos encontraremos mecanismos para hacer esto. En el caso de Cocos2D, tenemos la clase SpriteFrameCache que se encarga de almacenar la cach\u00e9 de fotogramas de sprites que queramos utilizar. Con TexturePacker habremos obtenido un fichero .plist (es el formato utilizado por Cocos2D) y una imagen .png . Podremos a\u00f1adir fotogramas a la cach\u00e9 a partir de estos dos ficheros. En el fichero .plist se incluye la informaci\u00f3n de cada fotograma (tama\u00f1o, regi\u00f3n que ocupa en la textura, etc). Cada fotograma se encuentra indexado por defecto mediante el nombre de la imagen original que a\u00f1adimos a TexturePacker, aunque podr\u00edamos editar esta informaci\u00f3n de forma manual en el .plist . La cach\u00e9 de fotogramas se define como singleton . Podemos a\u00f1adir nuevos fotogramas a este singleton de la siguiente forma: 1 2 SpriteFrameCache :: getInstance () -> addSpriteFramesWithFile ( \"sheet.plist\" ); En el caso anterior, utilizar\u00e1 como textura un fichero con el mismo nombre que el .plist pero con extensi\u00f3n .png . Tambi\u00e9n encontramos una versi\u00f3n del m\u00e9todo anterior que tambi\u00e9n recibe como par\u00e1metro la textura a utilizar, y de esta forma nos permite utilizar un fichero de textura con distinto nombre al .plist . Una vez introducidos los fotogramas empaquetados por TexturePacker en la cach\u00e9 de Cocos2D, podemos crear sprites a partir de dicha cach\u00e9 con: 1 Sprite * sprite = Sprite :: createWithSpriteFrameName ( \"frame01.png\" ); En el caso anterior creamos un nuevo sprite , pero en lugar de hacerlo directamente a partir de una imagen, debemos hacerlo a partir del nombre de un fotograma a\u00f1adido a la cach\u00e9 de textura. No debemos confundirnos con esto, ya que en este caso al especificar \"frame01.png\" no buscar\u00e1 un fichero con este nombre en la aplicaci\u00f3n, sino que buscar\u00e1 un fotograma con ese nombre en la cach\u00e9 de textura. El que los fotogramas se llamen por defecto como la imagen original que a\u00f1adimos a TexturePacker puede llevarnos a confusi\u00f3n. Tambi\u00e9n podemos obtener el fotograma como un objeto SpriteFrame . Esta clase no define un sprite , sino el fotograma almacenado en cach\u00e9. Es decir, no es un nodo que podamos almacenar en la escena, simplemente define la regi\u00f3n de textura correspondiente al fotograma: 1 2 SpriteFrame * frame = SpriteFrameCache :: getInstance () -> spriteFrameByName ( \"frame01.png\" ); Podremos inicializar tambi\u00e9n el sprite a partir del fotograma anterior, en lugar de hacerlo directamente a partir del nombre del fotograma: 1 Sprite * sprite = Sprite :: createWithSpriteFrame ( frame );","title":"Fotogramas"},{"location":"cocos2d-x.html#animacion","text":"Podremos definir determinadas secuencias de frames para crear animaciones. Las animaciones se representan mediante la clase Animation , y se pueden crear a partir de la secuencia de fotogramas que las definen. Los fotogramas deber\u00e1n indicarse mediante objetos de la clase SpriteFrame : 1 2 3 4 5 Animation * animAndar = Animation :: create (); animAndar -> addSpriteFrame ( SpriteFrameCache :: getInstance () -> spriteFrameByName ( \"frame01.png\" )); animAndar -> addSpriteFrame ( SpriteFrameCache :: getInstance () -> spriteFrameByName ( \"frame02.png\" )); Podemos ver que los fotogramas se pueden obtener de la cach\u00e9 de fotogramas definida anteriormente. Adem\u00e1s de proporcionar una lista de fotogramas a la animaci\u00f3n, deberemos proporcionar su periodicidad, es decir, el tiempo en segundos que tarda en cambiar al siguiente fotograma. Esto se har\u00e1 mediante la propiedad delayPerUnit : 1 animAndar -> setDelayPerUnit ( 0.25 ); Una vez definida la animaci\u00f3n, podemos a\u00f1adirla a una cach\u00e9 de animaciones que, al igual que la cach\u00e9 de texturas, tambi\u00e9n se define como singleton : 1 2 AnimationCache :: getInstance () -> addAnimation ( animAndar , \"animAndar\" ); La animaci\u00f3n se identifica mediante la cadena que proporcionamos como par\u00e1metro name . Podemos cambiar el fotograma que muestra actualmente un sprite con su m\u00e9todo: 1 sprite -> setDisplayFrameWithAnimationName ( \"animAndar\" , 0 ); Con esto buscar\u00e1 en la cach\u00e9 de animaciones la animaci\u00f3n especificada, y mostrar\u00e1 de ella el fotograma cuyo \u00edndice proporcionemos. M\u00e1s adelante cuando estudiemos el motor del juego veremos c\u00f3mo reproducir animaciones de forma autom\u00e1tica.","title":"Animaci\u00f3n"},{"location":"cocos2d-x.html#sprite-batch","text":"En OpenGL los sprites se dibujan realmente en un contexto 3D. Es decir, son texturas que se mapean sobre pol\u00edgonos 3D (concretamente con una geometr\u00eda rect\u00e1ngular). Muchas veces encontramos en pantalla varios sprites que utilizan la misma textura (o distintas regiones de la misma textura, como hemos visto en el caso de los sprite sheets ). Podemos optimizar el dibujado de estos sprites generando la geometr\u00eda de todos ellos de forma conjunta en una \u00fanica operaci\u00f3n con la GPU. Esto ser\u00e1 posible s\u00f3lo cuando el conjunto de sprites a dibujar est\u00e9n contenidos en una misma textura. Podemos crear un batch de sprites con Cocos2D utilizando la clase 1 2 3 SpriteBatchNode * spriteBatch = SpriteBatchNode :: create ( \"sheet.png\" ); this -> addChild ( spriteBatch ); El sprite batch es un tipo de nodo m\u00e1s que podemos a\u00f1adir a nuestra capa como hemos visto, pero por si s\u00f3lo no genera ning\u00fan contenido. Deberemos a\u00f1adir como hijos los sprites que queremos que dibuje. Es imprescindible que los hijos sean de tipo Sprite (o subclases de \u00e9sta), y que tengan como textura la misma textura que hemos utilizado al crear el batch (o regiones de la misma). No podremos a\u00f1adir sprites con ninguna otra textura dentro de este batch . 1 2 3 4 5 6 7 Sprite * sprite1 = Sprite :: createWithSpriteFrameName ( \"frame01.png\" ); sprite1 -> setPosition ( Vec2 ( 50 , 20 )); Sprite * sprite2 = Sprite :: createWithSpriteFrameName ( \"frame01.png\" ); sprite2 -> setPosition ( Vec2 ( 150 , 20 )); spriteBatch -> addChild ( sprite1 ); spriteBatch -> addChild ( sprite2 ); En el ejemplo anterior consideramos que el frame con nombre \"frame01.png\" es un fotograma que se carg\u00f3 en la cach\u00e9 de fotogramas a partir de la textura sheet.png . De no pertenecer a dicha textura no podr\u00eda cargarse dentro del batch .","title":"Sprite batch"},{"location":"cocos2d-x.html#colisiones","text":"Otro aspecto de los sprites es la interacci\u00f3n entre ellos. Nos interesar\u00e1 saber cu\u00e1ndo somos tocados por un enemigo o una bala para disminuir la vida, o cu\u00e1ndo alcanzamos nosotros a nuestro enemigo. Para ello deberemos detectar las colisiones entre sprites . La colisi\u00f3n con sprites de formas complejas puede resultar costosa de calcular. Por ello se suele realizar el c\u00e1lculo de colisiones con una forma aproximada de los sprites con la que esta operaci\u00f3n resulte m\u00e1s sencilla. Para ello solemos utilizar el bounding box , es decir, un rect\u00e1ngulo que englobe el sprite . La intersecci\u00f3n de rect\u00e1ngulos es una operaci\u00f3n muy sencilla. La clase Sprite contiene un m\u00e9todo getBoundingBox que nos devuelve un objeto Rect que representa la caja en la que el sprite est\u00e1 contenido. Con la funci\u00f3n intersectsRect podemos comprobar de forma sencilla y eficiente si dos rect\u00e1ngulos colisionan: 1 2 3 4 5 6 7 Rect bbPersonaje = spritePersonaje -> getBoundingBox (); Rect bbEnemigo = spriteEnemigo -> getBoundingBox (); if ( bbPersonaje . intersectsRect ( bbEnemigo )) { // Game over ... }","title":"Colisiones"},{"location":"cocos2d-x.html#motor-del-juego","text":"El componente b\u00e1sico del motor de un videojuego es lo que se conoce como ciclo del juego ( game loop ). Vamos a ver a continuaci\u00f3n en qu\u00e9 consiste este ciclo.","title":"Motor del juego"},{"location":"cocos2d-x.html#ciclo-del-juego","text":"Se trata de un bucle infinito en el que tendremos el c\u00f3digo que implementa el funcionamiento del juego. Dentro de este bucle se efect\u00faan las siguientes tareas b\u00e1sicas: Leer la entrada : Lee la entrada del usuario para conocer si el usuario ha pulsado alguna tecla desde la \u00faltima iteraci\u00f3n. Actualizar escena : Actualiza las posiciones de los sprites y su fotograma actual, en caso de que est\u00e9n siendo animados, la posici\u00f3n del fondo si se haya producido scroll , y cualquier otro elemento del juego que deba cambiar. Para hacer esta actualizaci\u00f3n se pueden tomar diferentes criterios. Podemos mover el personaje seg\u00fan la entrada del usuario, la de los enemigos seg\u00fan su inteligencia artificial, o seg\u00fan las interacciones producidas entre ellos y cualquier otro objeto (por ejemplo al ser alcanzados por un disparo, colisionando el sprite del disparo con el del enemigo), etc. Redibujar : Tras actualizar todos los elementos del juego, deberemos redibujar la pantalla para mostrar la escena tal como ha quedado en el instante actual. Dormir : Normalmente tras cada iteraci\u00f3n dormiremos un determinado n\u00famero de milisegundos para controlar la velocidad a la que se desarrolla el juego. De esta forma podemos establecer a cuantos fotogramas por segundo ( fps ) queremos que funcione el juego, siempre que la CPU sea capaz de funcionar a esta velocidad. 1 2 3 4 5 while ( true ) { leeEntrada (); actualizaEscena (); dibujaGraficos (); } Este ciclo no siempre deber\u00e1 comportarse siempre de la misma forma. El juego podr\u00e1 pasar por distintos estados, y en cada uno de ellos deber\u00e1n el comportamiento y los gr\u00e1ficos a mostrar ser\u00e1n distintos (por ejemplo, las pantallas de men\u00fa, selecci\u00f3n de nivel, juego, game over , etc). Podemos modelar esto como una m\u00e1quina de estados, en la que en cada momento, seg\u00fan el estado actual, se realicen unas funciones u otras, y cuando suceda un determinado evento, se pasar\u00e1 a otro estado.","title":"Ciclo del juego"},{"location":"cocos2d-x.html#actualizacion-de-la-escena","text":"En Cocos2D no deberemos preocuparnos de implementar el ciclo del juego, ya que de esto se encarga el singleton Director . Los estados del juego se controlan mediante las escenas ( Scene ). En un momento dado, el ciclo de juego s\u00f3lo actualizar\u00e1 y mostrar\u00e1 los gr\u00e1ficos de la escena actual. Dicha escena dibujar\u00e1 los gr\u00e1ficos a partir de los nodos que hayamos a\u00f1adido a ella como hijos. Ahora nos queda ver c\u00f3mo actualizar dicha escena en cada iteraci\u00f3n del ciclo del juego, por ejemplo, para ir actualizando la posici\u00f3n de cada personaje, o comprobar si existen colisiones entre diferentes sprites . La escena tiene un m\u00e9todo schedule que permite especificar un m\u00e9todo al que se llamar\u00e1 en cada iteraci\u00f3n del ciclo. De esa forma, podremos especificar en dicho m\u00e9todo la forma de actualizar la escena: 1 scene -> schedule ( CC_SCHEDULE_SELECTOR ( Game :: update )); Tendremos que definir un m\u00e9todo update donde introduciremos el c\u00f3digo que se encargar\u00e1 de actualizar la escena. Como par\u00e1metro recibe el tiempo transcurrido desde la anterior actualizaci\u00f3n (desde la anterior iteraci\u00f3n del ciclo del juego). Deberemos aprovechar este dato para actualizar los movimientos a partir de \u00e9l, y as\u00ed conseguir un movimiento fluido y constante: 1 2 3 4 void Game :: update ( float dt ) { _sprite -> setPosition ( _sprite -> getPosition () + Vec2 ( 100 * dt , 0 )); } En este caso estamos moviendo el sprite en x a una velocidad de 100 pixeles por segundo (el tiempo transcurrido se proporciona en segundos). Es importante remarcar que tanto el dibujado como las actualizaciones s\u00f3lo se llevar\u00e1n a cabo cuando la escena en la que est\u00e1n sea la escena que est\u00e1 ejecutando actualmente el Director . As\u00ed es como se controla el estado del juego. Existe otra versi\u00f3n del m\u00e9todo schedule que nos permite proporcionar el m\u00e9todo a llamar mediante una funci\u00f3n lambda. En este caso deberemos indicar tambi\u00e9n un identificador para nuestra funci\u00f3n, para as\u00ed poder cancelar su planificaci\u00f3n: 1 2 3 scene -> schedule ([ = ]( float dt ) { ... }, \"ia\" ); A esta planificaci\u00f3n le hemos dado el identificador \"ia\" . Podremos cancelarla llamando a unschedule(\"ia\") . Si no queremos tener que especificar la funci\u00f3n de forma inline , tambi\u00e9n podemos especificarla de la siguiente forma: 1 scene -> schedule ( CC_CALLBACK_1 ( Game :: update , this ), \"ia\" );","title":"Actualizaci\u00f3n de la escena"},{"location":"cocos2d-x.html#acciones","text":"En el punto anterior hemos visto c\u00f3mo actualizar la escena de forma manual como se hace habitualmente en el ciclo del juego. Sin embargo, con Cocos2D tenemos formas m\u00e1s sencillas de animar los nodos de la escena, son lo que se conoce como acciones . Estas acciones nos permiten definir determinados comportamientos, como trasladarse a un determinado punto, y aplicarlos sobre un nodo para que realice dicha acci\u00f3n de forma autom\u00e1tica, sin tener que actualizar su posici\u00f3n manualmente en cada iteraci\u00f3n ( tick ) del juego. Todas las acciones derivan de la clase Action . Encontramos acciones instant\u00e1neas (como por ejemplo situar un sprite en una posici\u00f3n determinada), o acciones con una duraci\u00f3n (mover al sprite hasta la posici\u00f3n destino gradualmente). Por ejemplo, para mover un nodo a la posici\u00f3n (200, 50) en 3 segundos, podemos definir una acci\u00f3n como la siguiente: 1 MoveTo * actionMoveTo = MoveTo :: create ( 3 , Vec2 ( 200 , 50 )); Para ejecutarla, deberemos aplicarla sobre el nodo que queremos mover: 1 sprite -> runAction ( actionMoveTo ); Podemos ejecutar varias acciones de forma simult\u00e1nea sobre un mismo nodo. Si queremos detener todas las acci\u00f3nes que pudiera haber en marcha hasta el momento, podremos hacerlo con: 1 sprite -> stopAllActions (); Adem\u00e1s, tenemos la posibilidad de encadenar varias acciones mediante el tipo especial de acci\u00f3n Sequence . En el siguiente ejemplo primero situamos el sprite de forma inmediata en (0, 50) , y despu\u00e9s lo movermos a (200, 50) : 1 2 3 4 5 6 7 Place * actionPlace = Place :: create ( Vec2 ( 0 , 50 )); MoveTo * actionMoveTo = MoveTo :: create ( 3 , Vec2 ( 200 , 50 )); Sequence * actionSequence = Sequence :: create ( actionPlace , actionMoveTo , NULL ); sprite -> runAction ( actionSequence ); Incluso podemos hacer que una acci\u00f3n (o secuencia de acciones) se repita un determinado n\u00famero de veces, o de forma indefinida: 1 2 3 RepeatForever * actionRepeat = RepeatForever :: create ( actionSequence ); sprite -> runAction ( actionRepeat ); De esta forma, el sprite estar\u00e1 continuamente movi\u00e9ndose de (0,50) a (200,50) . Cuando llegue a la posici\u00f3n final volver\u00e1 a aparecer en la inicial y continuar\u00e1 la animaci\u00f3n. Podemos aprovechar este mecanismo de acciones para definir las animaciones de fotogramas de los sprites , con una acci\u00f3n de tipo Animate . Crearemos la acci\u00f3n de animaci\u00f3n a partir de una animaci\u00f3n de la cach\u00e9 de animaciones: 1 2 3 4 5 Animate * animate = Animate :: create ( AnimationCache :: sharedAnimationCache () -> animationByName ( \"animAndar\" )); sprite -> runAction ( RepeatForever :: create ( animate )); Con esto estaremos reproduciendo continuamente la secuencia de fotogramas definida en la animaci\u00f3n, utilizando la periodicidad ( delayPerUnit ) que especificamos al crear dicha animaci\u00f3n. Encontramos tambi\u00e9n acciones que nos permiten realizar tareas personalizadas, proporcionando mediante una pareja target-selector la funci\u00f3n a la que queremos que se llame cuando se produzca la acci\u00f3n: 1 2 CallFunc * actionCall = CallFunc :: create ( CC_CALLBACK_0 ( Game :: accionCallback , this )); Deberemos definir en nuestra clase el m\u00e9todo de callback a llamar. En el caso del ejemplo anterior ser\u00eda: 1 2 3 void Game :: accionCallback () { ... } Otra opci\u00f3n es pasar directamente una funci\u00f3n lambda como par\u00e1metro: 1 2 3 CallFunc :: create ([ = ] { ... }); Tambi\u00e9n encontramos variantes de esta acci\u00f3n que nos permiten pasarle al callback como par\u00e1metro datos propios o el nodo sobre el que se ha ejecutado la acci\u00f3n ( CallFuncN recibe el nodo como par\u00e1metro, y CallFundND recibe el nodo y un puntero a datos gen\u00e9ricos). Cuanto tengamos que pasar un callback con par\u00e1metros utilizaremos CC_CALLBACK_1 , CC_CALLBACK_2 y CC_CALLBACK_3 , para 1, 2 y 3 par\u00e1metros respectivamente. Encontramos gran cantidad de acciones disponibles, que nos permitir\u00e1n crear diferentes efectos (fundido, tinte, rotaci\u00f3n, escalado), e incluso podr\u00edamos crear nuestras propias acciones mediante subclases de Action .","title":"Acciones"},{"location":"cocos2d-x.html#escenario-de-tipo-mosaico","text":"Hasta el momento hemos visto c\u00f3mo crear los diferentes elementos din\u00e1micos ( sprites ) de nuestro juego, como por ejemplo nuestro personaje, los enemigos, o los disparos. Pero todos estos elementos normalmente se mover\u00e1n sobre un escenario. Vamos a ver en esta sesi\u00f3n la forma en la que podemos construir este escenario, los fondos, y tambi\u00e9n c\u00f3mo a\u00f1adir m\u00fasica de fondo y efectos de sonido. En los juegos normalmente tendremos un fondo sobre el que se mueven los personajes. Muchas veces los escenarios del juego son muy extensos y no caben enteros en la pantalla. De esta forma lo que se hace es ver s\u00f3lo la parte del escenario donde est\u00e1 nuestro personaje, y conforme nos movamos se ir\u00e1 desplazando esta zona visible para enfocar en todo momento el lugar donde est\u00e1 nuestro personaje. Esto es lo que se conoce como scroll . El tener un fondo con scroll ser\u00e1 m\u00e1s costoso computacionalmente, ya que siempre que nos desplacemos se deber\u00e1 redibujar toda la pantalla, debido a que se est\u00e1 moviendo todo el fondo. Adem\u00e1s para poder dibujar este fondo deberemos tener una imagen con el dibujo del fondo para poder volcarlo en pantalla. Si tenemos un escenario extenso, ser\u00eda totalmente prohibitivo hacer una imagen que contenga todo el fondo. Esta imagen sobrepasar\u00eda con total seguridad el tama\u00f1o m\u00e1ximo de las texturas OpenGL. Para evitar este problema lo que haremos normalmente en este tipo de juegos es construir el fondo como un mosaico. Nos crearemos una imagen con los elementos b\u00e1sicos que vamos a necesitar para nuestro fondo, y construiremos el fondo como un mosaico en el que se utilizan estos elementos. Encontramos herramientas que nos permiten hacer esto de forma sencilla, como Tiled (http://www.mapeditor.org). Con esta herramienta deberemos proporcionar una textura con las distintas piezas con las que construiremos el mosaico, y podemos combinar estas piezas de forma visual para construir mapas extensos. Deberemos proporcionar una imagen con un conjunto de patrones ( Mapa > Nuevo conjunto de patrones ). Deberemos indicar el ancho y alto de cada \"pieza\" ( tile ), para que as\u00ed sea capaz de particionar la imagen y obtener de ella los diferentes patrones con los que construir el mapa. Una vez cargados estos patrones, podremos seleccionar cualquiera de ellos y asignarlo a las diferentes celdas del mapa. El resultado se guardar\u00e1 en un fichero de tipo .tmx , basado en XML, que la mayor parte de motores 2D son capaces de leer. En Cocos2D tenemos la clase CCTMXTiledMap , que puede inicializarse a partir del fichero .tmx : 1 TMXTiledMap * fondo = TMXTiledMap :: create ( \"mapa.tmx\" ); Este objeto es un nodo (hereda de Node ), por lo que podemos a\u00f1adirlo a pantalla (con addChild ) y aplicar cualquier transformaci\u00f3n de las vistas anterioremente. Las dimesiones del mapa ser\u00e1n (columnas ancho)x(filas alto) , siendo ancho x alto las dimensiones de cada tile , y columnas x filas el n\u00famero de celdas que tiene el mapa. Hemos visto la creaci\u00f3n b\u00e1sica de un escenario con Tiled Map Editor , pero esta herramienta nos da m\u00e1s facilidades para la creaci\u00f3n de los fondos. En el caso anterior hemos visto como crear el fondo a partir de una \u00fanica capa de mosaico, pero podemos hacer que nuestros fondos se compongan de varias capas. En el panel de la derecha de la herramienta vemos la lista de capas, y podemos a\u00f1adir nuevas capas. Al a\u00f1adir una nueva capa, nos preguntar\u00e1 si queremos una nueva capa de patrones o de objetos. Las capas de patrones nos permitir\u00e1n crear el aspecto visual del fondo mediante un mosaico, como hemos visto anteriormente, mientras que las de objetos nos permiten marcar diferentes zonas del mapa, por ejemplo para indicar puntos en los que aparecen enemigos, o el punto en el que se debe situar nuestro personaje al comenzar el nivel. Vamos a ver cada uno de estos tipos de capas con m\u00e1s detenimiento.","title":"Escenario de tipo mosaico"},{"location":"cocos2d-x.html#capas-de-patrones","text":"Como hemos indicado anteriormente, las capas de patrones nos permiten definir el aspecto del nivel mediante un mosaico, utilizando un conjunto de patrones para fijar el contenido de cada celda del mosaico. Cuando creamos varias capas de patrones, ser\u00e1 importante fijar su orden, ya que las capas que est\u00e9n al frente tapar\u00e1n a las que est\u00e9n atr\u00e1s. Este orden viene determinado por el orden en el que las capas aparecen en la lista del panel derecho. Las capas al comienzo de la lista quedar\u00e1n por delante de las dem\u00e1s. Podemos cambiar el orden de las capas en esta lista mediante los botones con las flechas hacia arriba y hacia abajo para conseguir situar cada una de ellas en la profundidad adecuada. Las utilidades de esta divisi\u00f3n en capas son varias: Aspecto : Un primer motivo para utilizar diferentes capas puede ser simplemente por cuestiones de aspecto, para combinar varios elementos en una misma celda. Por ejemplo, en una capa de fondo podr\u00edamos poner el cielo, y en una capa m\u00e1s cercana una reja con fondo transparente. De esa forma ese mismo recuadro con la reja podr\u00eda ser utilizado en otra parte del escenario con un fondo distinto (por ejemplo de monta\u00f1as), pudiendo as\u00ed con \u00fanicamente 3 recuadros obtener 4 configuraciones diferentes: cielo, monta\u00f1a, cielo con reja, y monta\u00f1a con reja. Colisiones : Puede interesarnos que los elementos de una capa nos sirvan para detectar colisiones con los objetos del juego. Por ejemplo, podemos en ella definir muros que los personajes del juego no podr\u00e1n atravesar. Consideraremos desde nuestro juego que todas las celdas definidas en esa capa suponen regiones que deben colisionar con nuestros sprites . Consumibles : Podemos definir una capa con objetos que podamos recoger. Por ejemplo podr\u00edamos definir una capa con monedas, de forma que cada vez que el usuario entra en una celda con una moneda dicha moneda sea eliminada del mapa y se nos a\u00f1ada a un contador de puntuaci\u00f3n. Vamos a ver ahora c\u00f3mo implementar en nuestro juego los anteriores usos, que nos permitan detectar colisiones con las celdas y modificar en el programa el contenido de las mismas para poder introducir en ellas elementos consumibles. La base para hacer todo esto es poder obtener cada capa individual del mapa para poder trabajar con sus elementos. Esto lo haremos con la clase CCTMXLayer : 1 TMXLayer * capa = fondo -> layerNamed ( \"muros\" );","title":"Capas de patrones"},{"location":"cocos2d-x.html#colisiones-con-el-mapa","text":"La detecci\u00f3n de colisiones con los muros del fondo ser\u00e1 muy \u00fatil en juegos de tipo RPG o de plataformas. Para hacer esto lo primero que debemos hacer es obtener la capa que define los elementos que se comportan como \"muro\" tal como hemos visto anteriormente. De esta capa necesitaremos tener alguna forma de identificar qu\u00e9 celdas definen muros. La forma m\u00e1s adecuada de marcar estas celdas consiste en darles una serie de propiedades que nuestro programa podr\u00e1 leer y as\u00ed comprobar si se trata de un muro con el que podemos colisionar o no. Para asignar propiedades a un objeto del conjunto de patrones dentro de Tiled podemos pulsar con el bot\u00f3n derecho sobre \u00e9l, y seleccionar Propiedades del Patr\u00f3n... . Se abrir\u00e1 un cuadro como el siguiente donde podremos definir dichas propiedades: Lo que deberemos hacer es marcar todos los objetos del conjunto de patrones que sirvan para definir muros con una misma propiedad que los marque como tal. En el c\u00f3digo de nuestro juego podremos leer estas propiedades de la siguiente forma: 1 2 3 4 5 6 7 8 9 10 11 12 Point tileCoords = Point ( fila , columna ); int tileGid = capa -> getTileGIDAt ( tileCoords ); if ( tileGid ) { auto properties = fondo -> getPropertiesForGID ( tileGid ); if ( ! properties . isNull ()) { bool collision = properties . asValueMap (). at ( \"colisionable\" ). asBool (); if ( collision ) { ... } } } El gid de cada celda nos indica el tipo de objeto de patr\u00f3n que tenemos en ella. Si la celda est\u00e1 vac\u00eda el gid ser\u00e1 0 . En una versi\u00f3n m\u00e1s sencilla, podr\u00edamos considerar que todas las celdas de la capa son colisionables y simplemente comprobar si el gid es distinto de 0 . De todas formas, el uso de propiedades hace m\u00e1s flexible nuestro motor del juego, para por ejemplo en el futuro implementar distintos tipos de colisiones. Para comprobar las colisiones de nuestro sprite con los muros una primera aproximaci\u00f3n podr\u00eda consistir en hacer la comprobaci\u00f3n con todas las celdas de la capa. Sin embargo esto no resulta nada eficiente ni adecuado. La soluci\u00f3n que se suele utilizar habitualmente consiste en comprobar la colisi\u00f3n \u00fanicamente con las celdas de nuestro entorno. Haremos lo siguiente: Obtendremos la posici\u00f3n en las que est\u00e1 centrado nuestro sprite . Calcularemos las coordenadas de la celda a la que corresponde (dividiendo entre la anchura y altura de cada celda). Obtendremos los gid de las 9 celdas adyacentes. Comprobaremos si colisiona con alguna de ellas, corrigiendo la posici\u00f3n del sprite en tal caso. A continuaci\u00f3n mostramos un ejemplo de c\u00f3digo en el que obtendr\u00edamos cada una de las celdas adyacentes a un sprite . En primer lugar vamos a crear una serie de m\u00e9todos auxiliares. El primero de ellos nos devolver\u00e1 las coordenadas de una celda a partir de las coordenadas de la escena (dividiendo entre el tama\u00f1o de cada celda): 1 2 3 4 5 6 7 8 9 Point Game :: tileCoordForPosition ( Point position ) { Size tileSize = _tiledMap -> getTileSize (); float totalHeight = _tiledMap -> getMapSize (). height * tileSize . height ; float x = floor ( position . x / tileSize . width ); float y = floor (( totalHeight - position . y ) / tileSize . height ); return Point ( x , y ); } Hay que destacar que las coordenadas y del mapa est\u00e1n invertidas respecto a las de la escena. Por ese motivo es necesario calcular la altura total y hacer la resta. Tambi\u00e9n vamos a definir un m\u00e9todo que nos devuelva el \u00e1rea ( Rect ) que ocupa en la escena una celda dada: 1 2 3 4 5 6 7 8 9 Rect Game :: rectForTileAt ( CCPoint tileCoords ) { Size tileSize = _tiledMap -> getTileSize (); float totalHeight = _tiledMap -> getMapSize (). height * tileSize . height ; Point origin ( tileCoords . x * tileSize . width , totalHeight - (( tileCoords . y + 1 ) * tileSize . height )); return Rect ( origin . x , origin . y , tileSize . width , tileSize . height ); } Por \u00faltimo, crearemos un m\u00e9todo que nos diga si una determinada celda es colisionable o no. Consideraremos que las celdas fuera del mapa no son colisionables (aunque seg\u00fan el caso podr\u00eda interesarnos hacerlo al rev\u00e9s): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 bool Game :: isCollidableTileAt ( Point tileCoords ) { // Consideramos que celdas fuera del mapa no son nunca colisionables if ( tileCoords . x < 0 || tileCoords . x >= _tiledMap -> getMapSize (). width || tileCoords . y < 0 || tileCoords . y >= _tiledMap -> getMapSize (). height ) { return false ; } TMXLayer * layerMuros = _tiledMap -> getLayer ( \"muros\" ); int tileGid = layerMuros -> getTileGIDAt ( tileCoords ); if ( tileGid ) { auto properties = _tiledMap -> getPropertiesForGID ( tileGid ); if ( ! properties . isNull ()) { bool collision = properties . asValueMap (). at ( \"colisionable\" ). asBool (); return collision ; } } return false ; } Una vez hecho esto, podremos calcular las colisiones con las celdas adyacentes a nuestro personaje y tomar las acciones oportunas. Por ejemplo, en el caso sencillo en el que s\u00f3lo necesitamos calcular las colisiones a la izquierda y a la derecha, podremos utilizar el siguiente c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 Size tileSize = _tiledMap -> getTileSize (); Point tileCoord = this -> tileCoordForPosition ( _spritePersonaje -> getPosition ()); Point tileLeft ( tileCoord . x - 1 , tileCoord . y ); Point tileRight ( tileCoord . x + 1 , tileCoord . y ); if ( this -> isCollidableTileAt ( tileLeft )) { Rect tileRect = this -> rectForTileAt ( tileLeft ); if ( tileRect . intersectsRect ( _spritePersonaje -> getBoundingBox ())) { this -> detenerPersonaje (); _spritePersonaje -> setPosition ( Vec2 ( tileRect . origin . x + tileRect . size . width + _spritePersonaje -> getContentSize (). width / 2 , tileSize . height + _spritePersonaje -> getContentSize (). height / 2 )); } } if ( this -> isCollidableTileAt ( tileRight )) { Rect tileRect = this -> rectForTileAt ( tileRight ); if ( tileRect . intersectsRect ( _spritePersonaje -> getBoundingBox ())) { this -> detenerPersonaje (); _spritePersonaje -> setPosition ( Vec2 ( tileRect . origin . x - _spritePersonaje -> getContentSize (). width / 2 , tileSize . height + _spritePersonaje -> getContentSize (). height / 2 )); } } Por supuesto, la forma de obtener estas celdas depender\u00e1 del tama\u00f1o del sprite . Si ocupase m\u00e1s de una celda deberemos hacer la comprobaci\u00f3n con todas las celdas de nuestro entorno a las que pudiera alcanzar. Una vez detectada la colisi\u00f3n, el \u00faltimo paso hemos visto que consistir\u00eda en parar el movimiento del sprite . Si conocemos la posici\u00f3n de la celda respecto al sprite (arriba, abajo, izquierda, derecha) nos ser\u00e1 de gran ayuda, ya que sabremos que deberemos posicionarlo justo pegado a esa celda en el lateral que ha colisionado con ella. En el ejemplo anterior, seg\u00fan colisione con la celda izquierda o derecha, posicionamos al sprite pegado a la derecha o a la izquierda del muro respectivamente.","title":"Colisiones con el mapa"},{"location":"cocos2d-x.html#modificacion-del-mapa","text":"En muchos casos nos interesar\u00e1 tener en el mapa objetos que podamos modificar. Por ejemplo, monedas u otros items que podamos recolectar, u objetos que podemos destruir. Para conseguir esto podemos definir una capa con dichos objetos, y marcarlos con una propiedad que nos indique que son \"recolectables\" o \"destruibles\". Una vez hecho esto, desde nuestro c\u00f3digo podemos obtener la capa que contenga dichos objetos recolectables, por ejemplo \"monedas\": 1 TMXLayer * monedas = fondo -> getLayer ( \"monedas\" ); De esta capa podremos eliminar los objetos \"recolectables\" cuando nuestro personaje los recoja. Para hacer esto podemos utilizar el siguiente m\u00e9todo: 1 monedas -> removeTileAt ( tileCoord ); Tambi\u00e9n podr\u00edamos cambiar el tipo de elemento que se muestra en una celda (por ejemplo para que al tocar una moneda cambie de color). Esto lo haremos especificando el nuevo gid que tendr\u00e1 la celda: 1 monedas -> setTileGID ( GID_MONEDA_ROJA , tileCoord ); Para cambiar o modificar los elementos recolectables primero deberemos comprobar si nuestro personaje \"colisiona\" con la celda en la que se encuentran, de forma similar a lo visto en el punto anterior: 1 2 3 4 5 6 7 8 9 10 11 12 Point tileCoords = this -> tileCoordForPosition ( _sprite -> getPosition ()); int tileGid = monedas -> getTileGIDAt ( tileCoords ); if ( tileGid ) { auto properties = fondo -> getPropertiesForGID ( tileGid ); if ( ! properties . isNull ()) { bool recolectable = properties . asValueMap (). at ( \"recolectable\" ). asBool (); if ( recolectable ) { monedas -> removeTileAt ( tileCoords ); } } } En este caso \u00fanicamente comprobamos la celda en la que se encuentra nuestro personaje, no las adyacentes. Si el personaje fuese de mayor tama\u00f1o deber\u00edamos comprobar todas las celdas del entorno que pudiera abarcar.","title":"Modificaci\u00f3n del mapa"},{"location":"cocos2d-x.html#capas-de-objetos","text":"Hasta el momento hemos visto las capas de patrones, que se construyen como un mosaico de celdas que definir\u00e1 el aspecto del fondo. Existe otro tipo de capa que podemos incluir en nuestro dise\u00f1o del fondo que no se limita al mosaico de celdas, sino que nos permite marcar cualquier regi\u00f3n del mapa sin ajustarse a la rejilla de celdas. Estas son las capas de objetos. En estas capas podremos por ejemplo marcar zonas de mapas donde aparecen enemigos, o donde se situa autom\u00e1ticamente nuestro personaje al iniciar el nivel. Cuando a\u00f1adamos y seleccionemos una capa de objetos, en la barra de herramientas superior se activar\u00e1n dos iconos que nos permitir\u00e1n crear nuevos objetos y seleccionar y cambiar las propiedades de los objetos existentes. Pulsando el bot\u00f3n con el \"cubo azul\" podremos a\u00f1adir un nuevo objeto a la escena. El objeto se definir\u00e1 como un rect\u00e1ngulo (deberemos pulsar y arrastrar el rat\u00f3n sobre el escenario para definir dicho rect\u00e1ngulo). Tras crear un objeto, podremos cambiar a la herramienta para la selecci\u00f3n y modificaci\u00f3n de objetos, seleccionar el objeto que acabamos de crear, pulsar sobre \u00e9l con el bot\u00f3n derecho, y seleccionar la opci\u00f3n Propiedades del Objeto ... . Veremos una ventana como la siguiente, en la que podremos darle un nombre, modificar sus dimensiones, y a\u00f1adir una lista de propiedades.","title":"Capas de objetos"},{"location":"cocos2d-x.html#scroll-del-escenario","text":"Cuando en el juego tenemos un mapa m\u00e1s extenso que el tama\u00f1o de la pantalla, tendremos que implementar scroll para movernos por \u00e9l. Para hacer scroll podemos desplazar la capa principal del juego, que contiene tanto el mapa de fondo como los sprites : 1 this -> setPosition ( Vec2 ( scrollX , scrollY )); En este ejemplo anterior, this ser\u00eda nuestra capa principal. En este caso es importante resaltar que si queremos implementar un HUD (para mostrar puntuaciones, n\u00famero de vidas, etc) la capa del HUD no debe a\u00f1adirse como hija de la capa principal, sino que deberemos a\u00f1adirla directamente como hija de la escena ( Scene ), ya que de no ser as\u00ed el HUD se mover\u00eda con el scroll . Normalmente el scroll deber\u00e1 seguir la posici\u00f3n de nuestro personaje. Conforme movamos nuestro personaje deberemos centrar el mapa: 1 2 3 4 5 6 7 8 void Game :: centerViewport () { Size screenSize = Director :: getInstance () -> getWinSize (); float x = screenSize . width / 2.0 - _sprite -> getPosition (). x ; float y = screenSize . height / 2.0 - _sprite -> getPosition (). y ; this -> setPosition ( Vec2 ( x , y )); } El m\u00e9todo anterior deber\u00e1 invocarse cada vez que se cambie la posici\u00f3n del sprite . Lo que har\u00e1 es desplazar todo el escenario del juego de forma que el sprite quede situado justo en el centro de la pantalla. Podemos observar que se obtiene el tama\u00f1o de la pantalla a partir de Director , y calculamos el desplazamiento (x,y) necesario para que el sprite quede situado justo en el punto central.","title":"Scroll del escenario"},{"location":"cocos2d-x.html#limites-del-escenario","text":"El problema de la implementaci\u00f3n anterior es que el escenario no es infinito, y cuando lleguemos a sus l\u00edmites normalmente querremos no salirnos de ellos para no dejar en la pantalla espacio vac\u00edo. Deberemos por lo tanto detener el scroll del fondo cuando hayamos llegado a su l\u00edmite. Esto podemos resolverlo a\u00f1adiendo algunos if al c\u00f3digo anterior: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void Game :: centerViewport () { Size screenSize = Director :: getInstance () -> getWinSize (); Size tileSize = _tiledMap -> getTileSize (); float offsetX = screenSize . width / 2.0 - _sprite -> getPosition (). x ; float offsetY = screenSize . height / 2.0 - _sprite -> getPosition (). y ; // Comprueba l\u00edmites en la dimension x if ( offsetX > 0 ) { offsetX = 0 ; } else if ( offsetX < screenSize . width - tileSize . width * _tiledMap -> getMapSize (). width ) { offsetX = screenSize . width - tileSize . width * _tiledMap -> getMapSize (). width ; } // Comprueba l\u00edmites en la dimension y if ( offsetY > 0 ) { offsetY = 0 ; } else if ( offsetY < screenSize . height - tileSize . height * _tiledMap -> getMapSize (). height ) { offsetY = screenSize . height - tileSize . height * _tiledMap -> getMapSize (). height ; } this -> setPosition ( Vec2 ( offsetX , offsetY )); } Con este c\u00f3digo evitaremos que en el visor veamos zonas fuera de los l\u00edmites del mapa. La posici\u00f3n m\u00ednima que se mostrar\u00e1 ser\u00e1 0 , y la m\u00e1xima el tama\u00f1o del mapa (se calcula como el n\u00famero de celdas mapSize por el tama\u00f1o de cada celda tileSize ). Cuando lleguemos a estos l\u00edmites nuestro personaje seguir\u00e1 movi\u00e9ndose, pero ya no estar\u00e1 centrado en la pantalla, el mapa permanecer\u00e1 fijo y el personaje se mover\u00e1 sobre \u00e9l.","title":"L\u00edmites del escenario"},{"location":"cocos2d-x.html#scroll-parallax","text":"En juegos 2D podemos crear una ilusi\u00f3n de profundidad creando varias capas de fondo y haciendo que las capas m\u00e1s lejanas se muevan a velocidad m\u00e1s lenta que las m\u00e1s cercanas al hacer scroll . Esto es lo que se conoce como scroll parallax . En Cocos2D es sencillo implementar este tipo de scroll , ya que contamos con el tipo de nodo ParallaxNode que define este comportamiento. Este nodo nos permite a\u00f1adir varios hijos, y hacer que cada uno de ellos se desplace a una velocidad distinta. 1 2 3 4 5 6 7 ParallaxNode * parallax = ParallaxNode :: create (); parallax -> addChild ( scene , 3 , Vec2 ( 1 , 1 ), Vec2 ( 0 , 0 )); parallax -> addChild ( mountains , 2 , Vec2 ( 0.25 , 1 ), Vec2 ( 0 , 0 )); parallax -> addChild ( sky , 1 , Vec2 ( 0.01 , 1 ), Vec2 ( 0 , 0 )); this -> addChild ( parallax , - 1 ); Podemos a\u00f1adir cualquier nodo como capa al scroll parallax , como por ejemplo sprites o tilemaps . Con parallax ratio especificamos la velocidad a la que se mueve la capa. Si ponemos un ratio de 1 hacemos que se mueva a la velocidad real que estemos moviendo la capa principal de nuestra escena. Si ponemos 0.5 , se mover\u00e1 a mitad de la velocidad.","title":"Scroll parallax"},{"location":"cocos2d-x.html#reproduccion-de-audio","text":"En un videojuego normalmente reproduciremos una m\u00fasica de fondo, normalmente de forma c\u00edclica, y una serie de efectos de sonido (disparos, explosiones, etc). En Cocos2D tenemos la librer\u00eda CocosDenshion que nos permite reproducir este tipo de audio de forma apropiada para videojuegos. La forma m\u00e1s sencilla de utilizar esta librer\u00eda es mediante el objeto singleton SimpleAudioEngine . Podemos acceder a \u00e9l de la siguiente forma: 1 2 3 4 5 6 #include \"SimpleAudioEngine.h\" ... SimpleAudioEngine * audio = CocosDenshion :: SimpleAudioEngine :: getInstance ();","title":"Reproducci\u00f3n de audio"},{"location":"cocos2d-x.html#musica-de-fondo","text":"Podemos reproducir como m\u00fasica de fondo cualquier formato soportado por el dispositivo (MP3, M4A, etc). Para ello utilizaremos el m\u00e9todo playBackgroundMusic del objeto audio engine : 1 audio -> playBackgroundMusic ( \"musica.m4a\" , true ); Lo habitual ser\u00e1 reproducir la m\u00fasica en bucle, por ejemplo mientras estamos en un men\u00fa o en un nivel del juego. Por ese motivo contamos con el segundo par\u00e1metro ( loop ) que nos permite utilizar de forma sencilla esta caracter\u00edstica. Podemos deterner la reproducci\u00f3n de la m\u00fasica de fondo en cualquier momento con: 1 audio -> stopBackgroundMusic (); Tambi\u00e9n podemos a trav\u00e9s de este objeto cambiar el volumen de la m\u00fasica de fondo (se debe espeficiar un valor de 0 a 1 ): 1 audio -> setBackgroundMusicVolume ( 0.9 );","title":"M\u00fasica de fondo"},{"location":"cocos2d-x.html#efectos-de-sonido","text":"Los efectos de sonido sonar\u00e1n cuando suceda un determinado evento (disparo, explosi\u00f3n, pulsaci\u00f3n de un bot\u00f3n), y ser\u00e1 normalmente una reproducci\u00f3n de corta duraci\u00f3n. Una caracter\u00edstica de estos efectos es que deben sonar de forma inmediata al suceder el evento que los produce. Causar\u00eda un mal efecto que un disparo sonase con un retardo respecto al momento en el que se produjo. Sin embargo, la reproducci\u00f3n de audio normalmente suele causar un retardo, ya que implica cargar las muestras del audio del fichero y preparar los bufferes de memoria necesarios para su reproducci\u00f3n. Por ello, en un videojuego es importante que todos estos efectos se encuentren de antemano preparados para su reproducci\u00f3n, para evitar estos retardos. Con Cocos2D podremos precargar un fichero de audio de la siguiente forma: 1 2 audio -> preloadEffect ( \"explosion.caf\" ); audio -> preloadEffect ( \"disparo.caf\" ); Esto deberemos hacerlo una \u00fanica vez antes de comenzar el juego (un buen lugar puede ser el m\u00e9todo init de nuestra capa del juego). Una vez cargados, podremos reproducirlos de forma inmediata con playEffect : 1 audio -> playEffect ( \"explosion.caf\" ); Una vez no vayamos a utilizar estos efectos de sonido, deberemos liberarlos de memoria: 1 2 audio -> unloadEffect ( \"explosion.caf\" ); audio -> unloadEffect ( \"disparo.caf\" ); Esto se puede hacer cuando vayamos a pasar a otra escena en la que no se vayan a necesitar estos efectos. Por \u00faltimo, al igual que en el caso de la m\u00fasica de fondo, podremos cambiar el volumen de los efectos de sonido con: 1 audio -> setEffectsVolume ( 0.6 ); De esta forma podremos tener dos niveles de volumen independientes para la m\u00fasica de fondo y para los efectos de sonido. Los videojuegos normalmente nos presentan en sus opciones la posibilidad de que el usuario ajuste cada uno de estos dos vol\u00famenes seg\u00fan sus preferencias.","title":"Efectos de sonido"},{"location":"escenario_y_fondos.html","text":"Fondo y scroll \u00b6 Hasta el momento hemos visto c\u00f3mo crear los diferentes elementos din\u00e1micos ( sprites ) de nuestro juego, como por ejemplo nuestro personaje, los enemigos, o los disparos. Pero todos estos elementos normalmente se mover\u00e1n sobre un escenario. En los juegos normalmente tendremos un fondo sobre el que se mueven los personajes. Muchas veces los escenarios del juego son muy extensos y no caben enteros en la pantalla. De esta forma lo que se hace es ver s\u00f3lo la parte del escenario donde est\u00e1 nuestro personaje,y conforme nos movamos se ir\u00e1 desplazando esta zona visible para enfocar en todo momento el lugar donde est\u00e1 nuestro personaje. Esto es lo que se conoce como scroll . El tener un fondo con scroll ser\u00e1 m\u00e1s costoso computacionalmente, ya que siempre que nos desplacemos se deber\u00e1 redibujar toda la pantalla, debido a que se est\u00e1 moviendo todo el fondo. Adem\u00e1s para poder dibujar este fondo deberemos tener una imagen con el dibujo del fondo para poder volcarlo en pantalla. Si tenemos un escenario extenso, ser\u00eda totalmente prohibitivo hacer una imagen que contenga todo el fondo. Esta imagen sobrepasar\u00eda con total seguridad el tama\u00f1o m\u00e1ximo de las texturas OpenGL. Para evitar este problema lo que haremos normalmente en este tipo de juegos es construir el fondo como un mosaico ( tilemap ). Tilemaps \u00b6 Los mapas construidos mediante tilemaps se componen de una serie de piezas que combinaremos formando un mosaico. Para ello, en primer lugar deberemos crear una imagen con las piezas b\u00e1sicas que vamos a necesitar para nuestro fondo (lo que se conoce como tileset ). Esta ser\u00e1 una imagen de peque\u00f1as dimensiones, ya que simplemente contiene piezas que posteriormente reutilizaremos. A partir de dichas piezas construiremos el mosaico que ser\u00e1 nuestro tilemap Encontramos herramientas que nos permiten hacer esto de forma sencilla, siendo Tiled (http://www.mapeditor.org) la m\u00e1s conocida. Con esta herramienta podremos proporcionar una textura con las distintas piezas con las que construiremos el mosaico ( tileset ), y combinar estas piezas de forma visual para construir nuestros mapas. En primer lugar debemos proporcionar una imagen con un conjunto de patrones ( Mapa > Nuevo conjunto de patrones ). Deberemos indicar el ancho y alto de cada \"pieza\" ( tile ), para que as\u00ed sea capaz de particionar la imagen y obtener de ella los diferentes patrones con los que construir el mapa. Una vez cargados estos patrones, podremos seleccionar cualquiera de ellos y asignarlo a las diferentes celdas del mapa. El resultado se guardar\u00e1 en un fichero de tipo .tmx , basado en XML, que la mayor parte de motores 2D son capaces de leer. Las dimesiones del mapa ser\u00e1n (columnas ancho)x(filas alto) , siendo ancho x alto las dimensiones de cada tile , y columnas x filas el n\u00famero de celdas que tiene el mapa. Hemos visto la creaci\u00f3n b\u00e1sica de un escenario con Tiled Map Editor , pero esta herramienta nos da m\u00e1s facilidades para la creaci\u00f3n de los fondos. En el caso anterior hemos visto como crear el fondo a partir de una \u00fanica capa de mosaico, pero podemos hacer que nuestros fondos se compongan de varias capas. En el panel de la derecha de la herramienta vemos la lista de capas, y podemos a\u00f1adir nuevas capas. Al a\u00f1adir una nueva capa, nos preguntar\u00e1 si queremos una nueva capa de patrones o de objetos. Las capas de patrones nos permitir\u00e1n crear el aspecto visual del fondo mediante un mosaico, como hemos visto anteriormente. Las capas de objetos nos permiten marcar diferentes zonas del mapa, por ejemplo para indicar puntos en los que aparecen enemigos, o el punto en el que se debe situar nuestro personaje al comenzar el nivel, o incluso marcar zonas geom\u00e9tricas que no se visualizar\u00e1n (por ejemplo para determinar los l\u00edmites del escenario o para ser utilizados por el motor de f\u00edsicas). Vamos a ver cada uno de estos tipos de capas con m\u00e1s detenimiento. Capas de patrones \u00b6 Como hemos indicado anteriormente, las capas de patrones nos permiten definir el aspecto del nivel mediante un mosaico, utilizando un conjunto de patrones para fijar el contenido de cada celda del mosaico. Cada capa se define como una matriz, en la que en cada posici\u00f3n se indica un n\u00famero entero que identifica el tile que ocupar\u00e1 dicha celda. Este identificador de cada tile es lo que se conoce como gid . Dentro del tileset , cada tile se identificar\u00e1 por un gid \u00fanico, empezando a contar desde 1 (normalmente se asignan de forma secuencial siguiendo el orden en el que est\u00e1n en el conjunto de patrones). De esta forma, cuando en la matriz de la capa tenemos un 0 como gid , quiere decir que esa celda est\u00e1 vac\u00eda , mientras que si tiene otro valor, dicho valor representa el identificador del patr\u00f3n correspondiente. Cuando creamos varias capas de patrones, ser\u00e1 importante fijar su orden, ya que las capas que est\u00e9n al frente tapar\u00e1n a las que est\u00e9n atr\u00e1s. Este orden viene determinado por el orden en el que las capas aparecen en la lista del panel derecho. Las capas al comienzo de la lista quedar\u00e1n por delante de las dem\u00e1s. Podemos cambiar el orden de las capas en esta lista mediante los botones con las flechas hacia arriba y hacia abajo para conseguir situar cada una de ellas en la profundidad adecuada. Las utilidades de esta divisi\u00f3n en capas son varias: Aspecto : Un primer motivo para utilizar diferentes capas puede ser simplemente por cuestiones de aspecto, para combinar varios elementos en una misma celda. Por ejemplo, en una capa de fondo podr\u00edamos poner el cielo, y en una capa m\u00e1s cercana una reja con fondo transparente. De esa forma ese mismo recuadro con la reja podr\u00eda ser utilizado en otra parte del escenario con un fondo distinto (por ejemplo de monta\u00f1as), pudiendo as\u00ed con \u00fanicamente 3 recuadros obtener 4 configuraciones diferentes: cielo, monta\u00f1a, cielo con reja, y monta\u00f1a con reja. Colisiones : Puede interesarnos que los elementos de una capa nos sirvan para detectar colisiones con los objetos del juego. Por ejemplo, podemos en ella definir muros que los personajes del juego no podr\u00e1n atravesar. Consideraremos desde nuestro juego que todas las celdas definidas en esa capa suponen regiones que deben colisionar con nuestros sprites . Consumibles : Podemos definir una capa con objetos que podamos recoger. Por ejemplo podr\u00edamos definir una capa con monedas, de forma que cada vez que el jugador entra en una celda con una moneda dicha moneda sea eliminada del mapa y se nos a\u00f1ada a un contador de puntuaci\u00f3n. Colisiones con el mapa La detecci\u00f3n de colisiones con los muros del fondo ser\u00e1 muy \u00fatil en juegos de tipo RPG o de plataformas. Para hacer esto lo primero que debemos hacer es obtener la capa que define los elementos que se comportan como \"muro\" tal como hemos visto anteriormente. De esta capa necesitaremos tener alguna forma de identificar qu\u00e9 celdas definen muros. La forma m\u00e1s sencilla ser\u00eda considerar que todo son muros en dicha capa, de forma que si el gid de una celda es distinto de 0 , entonces tenemos un muro. Una forma m\u00e1s elaborada de marcar estas celdas consiste en darles una serie de propiedades que nuestro programa podr\u00e1 leer y as\u00ed comprobar si se trata de un muro con el que podemos colisionar o no. Para asignar propiedades a un objeto del conjunto de patrones dentro de Tiled podemos pulsar con el bot\u00f3n derecho sobre \u00e9l, y seleccionar Propiedades del Patr\u00f3n... . Se abrir\u00e1 un cuadro como el siguiente donde podremos definir dichas propiedades: Lo que deberemos hacer es marcar todos los objetos del conjunto de patrones que sirvan para definir muros con una misma propiedad que los marque como tal. Cuando entremos en una determinada celda, deberemos desde el c\u00f3digo del juego comprobar las propiedades de dicha celda y ver si es colisionable o no. Para comprobar las colisiones de nuestro sprite con los muros una primera aproximaci\u00f3n podr\u00eda consistir en hacer la comprobaci\u00f3n con todas las celdas de la capa. Sin embargo esto no resulta nada eficiente ni adecuado. La soluci\u00f3n que se suele utilizar habitualmente consiste en comprobar la colisi\u00f3n \u00fanicamente con las celdas de nuestro entorno. Haremos lo siguiente: Obtendremos la posici\u00f3n en las que est\u00e1 centrado nuestro sprite . Calcularemos las coordenadas de la celda a la que corresponde (dividiendo entre la anchura y altura de cada celda). Obtendremos los gid de las 9 celdas adyacentes. Comprobaremos si colisiona con alguna de ellas, corrigiendo la posici\u00f3n del sprite en tal caso. Modificaci\u00f3n del mapa En muchos casos nos interesar\u00e1 tener en el mapa objetos que podamos modificar. Por ejemplo, monedas u otros items que podamos recolectar, u objetos que podemos destruir. Para conseguir esto podemos definir una capa con dichos objetos, y marcarlos con una propiedad que nos indique que son \"recolectables\" o \"destruibles\" (o bien considerar que todos en la capa lo son). Desde el c\u00f3digo del juego podremos modificar el gid de cada celda de la capa. Por ejemplo, poniendo el gid a 0 haremos que una celda de la capa \"se borre\". Capas de objetos \u00b6 Hasta el momento hemos visto las capas de patrones, que se construyen como un mosaico de celdas que definir\u00e1 el aspecto del fondo. Existe otro tipo de capa que podemos incluir en nuestro dise\u00f1o del fondo que no se limita al mosaico de celdas, sino que nos permite marcar cualquier regi\u00f3n del mapa sin ajustarse a la rejilla de celdas. Estas son las capas de objetos. En estas capas podremos por ejemplo marcar zonas de mapas donde aparecen enemigos, o donde se situa autom\u00e1ticamente nuestro personaje al iniciar el nivel. Cuando a\u00f1adamos y seleccionemos una capa de objetos, en la barra de herramientas superior se activar\u00e1n algunos iconos que nos permitir\u00e1n crear nuevos objetos y seleccionar y cambiar las propiedades de los objetos existentes. Podremos a\u00f1adir objetos como puntos, regiones rectangulares, o polil\u00edneas. Tras crear un objeto, podremos cambiar a la herramienta para la selecci\u00f3n y modificaci\u00f3n de objetos, seleccionar el objeto que acabamos de crear, pulsar sobre \u00e9l con el bot\u00f3n derecho, y seleccionar la opci\u00f3n Propiedades del Objeto ... . Veremos una ventana como la siguiente, en la que podremos darle un nombre, modificar sus dimensiones, y a\u00f1adir una lista de propiedades. Estos objetos podr\u00e1n ser leidos desde el c\u00f3digo. Por ejemplo, podemos definir una polil\u00ednea para indicar al motor de f\u00edsicas c\u00f3mo debe crear la geometr\u00eda est\u00e1tica del suelo del escenario. Scroll del escenario \u00b6 Cuando en el juego tenemos un mapa m\u00e1s extenso que el tama\u00f1o de la pantalla, tendremos que implementar scroll para movernos por \u00e9l. Para hacer scroll podemos desplazar la capa principal del juego, que contiene tanto el mapa de fondo como los sprites (pero no los elementos del HUD , como son los marcadores de puntuaci\u00f3n, n\u00famero de vidas, etc). Algunos motores nos permiten utilizar tambi\u00e9n un nodo c\u00e1mara , que se encargar\u00e1 de realizar esta funci\u00f3n (al mover la c\u00e1mara, se mover\u00e1 la regi\u00f3n visualizada del escenario). En tal caso, el HUD debe a\u00f1adirse como hijo a la c\u00e1mara, para que as\u00ed siempre est\u00e9 en pantalla. Normalmente el scroll deber\u00e1 seguir la posici\u00f3n de nuestro personaje. Conforme movamos nuestro personaje deberemos centrar el mapa en \u00e9l. En juegos 2D podemos crear una ilusi\u00f3n de profundidad creando varias capas de fondo y haciendo que las capas m\u00e1s lejanas se muevan a velocidad m\u00e1s lenta que las m\u00e1s cercanas al hacer scroll . Esto es lo que se conoce como scroll parallax . Algunos motores nos proporcionan facilidades para crear este tipo de scroll .","title":"Fondo y _scroll_"},{"location":"escenario_y_fondos.html#fondo-y-scroll","text":"Hasta el momento hemos visto c\u00f3mo crear los diferentes elementos din\u00e1micos ( sprites ) de nuestro juego, como por ejemplo nuestro personaje, los enemigos, o los disparos. Pero todos estos elementos normalmente se mover\u00e1n sobre un escenario. En los juegos normalmente tendremos un fondo sobre el que se mueven los personajes. Muchas veces los escenarios del juego son muy extensos y no caben enteros en la pantalla. De esta forma lo que se hace es ver s\u00f3lo la parte del escenario donde est\u00e1 nuestro personaje,y conforme nos movamos se ir\u00e1 desplazando esta zona visible para enfocar en todo momento el lugar donde est\u00e1 nuestro personaje. Esto es lo que se conoce como scroll . El tener un fondo con scroll ser\u00e1 m\u00e1s costoso computacionalmente, ya que siempre que nos desplacemos se deber\u00e1 redibujar toda la pantalla, debido a que se est\u00e1 moviendo todo el fondo. Adem\u00e1s para poder dibujar este fondo deberemos tener una imagen con el dibujo del fondo para poder volcarlo en pantalla. Si tenemos un escenario extenso, ser\u00eda totalmente prohibitivo hacer una imagen que contenga todo el fondo. Esta imagen sobrepasar\u00eda con total seguridad el tama\u00f1o m\u00e1ximo de las texturas OpenGL. Para evitar este problema lo que haremos normalmente en este tipo de juegos es construir el fondo como un mosaico ( tilemap ).","title":"Fondo y scroll"},{"location":"escenario_y_fondos.html#tilemaps","text":"Los mapas construidos mediante tilemaps se componen de una serie de piezas que combinaremos formando un mosaico. Para ello, en primer lugar deberemos crear una imagen con las piezas b\u00e1sicas que vamos a necesitar para nuestro fondo (lo que se conoce como tileset ). Esta ser\u00e1 una imagen de peque\u00f1as dimensiones, ya que simplemente contiene piezas que posteriormente reutilizaremos. A partir de dichas piezas construiremos el mosaico que ser\u00e1 nuestro tilemap Encontramos herramientas que nos permiten hacer esto de forma sencilla, siendo Tiled (http://www.mapeditor.org) la m\u00e1s conocida. Con esta herramienta podremos proporcionar una textura con las distintas piezas con las que construiremos el mosaico ( tileset ), y combinar estas piezas de forma visual para construir nuestros mapas. En primer lugar debemos proporcionar una imagen con un conjunto de patrones ( Mapa > Nuevo conjunto de patrones ). Deberemos indicar el ancho y alto de cada \"pieza\" ( tile ), para que as\u00ed sea capaz de particionar la imagen y obtener de ella los diferentes patrones con los que construir el mapa. Una vez cargados estos patrones, podremos seleccionar cualquiera de ellos y asignarlo a las diferentes celdas del mapa. El resultado se guardar\u00e1 en un fichero de tipo .tmx , basado en XML, que la mayor parte de motores 2D son capaces de leer. Las dimesiones del mapa ser\u00e1n (columnas ancho)x(filas alto) , siendo ancho x alto las dimensiones de cada tile , y columnas x filas el n\u00famero de celdas que tiene el mapa. Hemos visto la creaci\u00f3n b\u00e1sica de un escenario con Tiled Map Editor , pero esta herramienta nos da m\u00e1s facilidades para la creaci\u00f3n de los fondos. En el caso anterior hemos visto como crear el fondo a partir de una \u00fanica capa de mosaico, pero podemos hacer que nuestros fondos se compongan de varias capas. En el panel de la derecha de la herramienta vemos la lista de capas, y podemos a\u00f1adir nuevas capas. Al a\u00f1adir una nueva capa, nos preguntar\u00e1 si queremos una nueva capa de patrones o de objetos. Las capas de patrones nos permitir\u00e1n crear el aspecto visual del fondo mediante un mosaico, como hemos visto anteriormente. Las capas de objetos nos permiten marcar diferentes zonas del mapa, por ejemplo para indicar puntos en los que aparecen enemigos, o el punto en el que se debe situar nuestro personaje al comenzar el nivel, o incluso marcar zonas geom\u00e9tricas que no se visualizar\u00e1n (por ejemplo para determinar los l\u00edmites del escenario o para ser utilizados por el motor de f\u00edsicas). Vamos a ver cada uno de estos tipos de capas con m\u00e1s detenimiento.","title":"Tilemaps"},{"location":"escenario_y_fondos.html#capas-de-patrones","text":"Como hemos indicado anteriormente, las capas de patrones nos permiten definir el aspecto del nivel mediante un mosaico, utilizando un conjunto de patrones para fijar el contenido de cada celda del mosaico. Cada capa se define como una matriz, en la que en cada posici\u00f3n se indica un n\u00famero entero que identifica el tile que ocupar\u00e1 dicha celda. Este identificador de cada tile es lo que se conoce como gid . Dentro del tileset , cada tile se identificar\u00e1 por un gid \u00fanico, empezando a contar desde 1 (normalmente se asignan de forma secuencial siguiendo el orden en el que est\u00e1n en el conjunto de patrones). De esta forma, cuando en la matriz de la capa tenemos un 0 como gid , quiere decir que esa celda est\u00e1 vac\u00eda , mientras que si tiene otro valor, dicho valor representa el identificador del patr\u00f3n correspondiente. Cuando creamos varias capas de patrones, ser\u00e1 importante fijar su orden, ya que las capas que est\u00e9n al frente tapar\u00e1n a las que est\u00e9n atr\u00e1s. Este orden viene determinado por el orden en el que las capas aparecen en la lista del panel derecho. Las capas al comienzo de la lista quedar\u00e1n por delante de las dem\u00e1s. Podemos cambiar el orden de las capas en esta lista mediante los botones con las flechas hacia arriba y hacia abajo para conseguir situar cada una de ellas en la profundidad adecuada. Las utilidades de esta divisi\u00f3n en capas son varias: Aspecto : Un primer motivo para utilizar diferentes capas puede ser simplemente por cuestiones de aspecto, para combinar varios elementos en una misma celda. Por ejemplo, en una capa de fondo podr\u00edamos poner el cielo, y en una capa m\u00e1s cercana una reja con fondo transparente. De esa forma ese mismo recuadro con la reja podr\u00eda ser utilizado en otra parte del escenario con un fondo distinto (por ejemplo de monta\u00f1as), pudiendo as\u00ed con \u00fanicamente 3 recuadros obtener 4 configuraciones diferentes: cielo, monta\u00f1a, cielo con reja, y monta\u00f1a con reja. Colisiones : Puede interesarnos que los elementos de una capa nos sirvan para detectar colisiones con los objetos del juego. Por ejemplo, podemos en ella definir muros que los personajes del juego no podr\u00e1n atravesar. Consideraremos desde nuestro juego que todas las celdas definidas en esa capa suponen regiones que deben colisionar con nuestros sprites . Consumibles : Podemos definir una capa con objetos que podamos recoger. Por ejemplo podr\u00edamos definir una capa con monedas, de forma que cada vez que el jugador entra en una celda con una moneda dicha moneda sea eliminada del mapa y se nos a\u00f1ada a un contador de puntuaci\u00f3n.","title":"Capas de patrones"},{"location":"escenario_y_fondos.html#capas-de-objetos","text":"Hasta el momento hemos visto las capas de patrones, que se construyen como un mosaico de celdas que definir\u00e1 el aspecto del fondo. Existe otro tipo de capa que podemos incluir en nuestro dise\u00f1o del fondo que no se limita al mosaico de celdas, sino que nos permite marcar cualquier regi\u00f3n del mapa sin ajustarse a la rejilla de celdas. Estas son las capas de objetos. En estas capas podremos por ejemplo marcar zonas de mapas donde aparecen enemigos, o donde se situa autom\u00e1ticamente nuestro personaje al iniciar el nivel. Cuando a\u00f1adamos y seleccionemos una capa de objetos, en la barra de herramientas superior se activar\u00e1n algunos iconos que nos permitir\u00e1n crear nuevos objetos y seleccionar y cambiar las propiedades de los objetos existentes. Podremos a\u00f1adir objetos como puntos, regiones rectangulares, o polil\u00edneas. Tras crear un objeto, podremos cambiar a la herramienta para la selecci\u00f3n y modificaci\u00f3n de objetos, seleccionar el objeto que acabamos de crear, pulsar sobre \u00e9l con el bot\u00f3n derecho, y seleccionar la opci\u00f3n Propiedades del Objeto ... . Veremos una ventana como la siguiente, en la que podremos darle un nombre, modificar sus dimensiones, y a\u00f1adir una lista de propiedades. Estos objetos podr\u00e1n ser leidos desde el c\u00f3digo. Por ejemplo, podemos definir una polil\u00ednea para indicar al motor de f\u00edsicas c\u00f3mo debe crear la geometr\u00eda est\u00e1tica del suelo del escenario.","title":"Capas de objetos"},{"location":"escenario_y_fondos.html#scroll-del-escenario","text":"Cuando en el juego tenemos un mapa m\u00e1s extenso que el tama\u00f1o de la pantalla, tendremos que implementar scroll para movernos por \u00e9l. Para hacer scroll podemos desplazar la capa principal del juego, que contiene tanto el mapa de fondo como los sprites (pero no los elementos del HUD , como son los marcadores de puntuaci\u00f3n, n\u00famero de vidas, etc). Algunos motores nos permiten utilizar tambi\u00e9n un nodo c\u00e1mara , que se encargar\u00e1 de realizar esta funci\u00f3n (al mover la c\u00e1mara, se mover\u00e1 la regi\u00f3n visualizada del escenario). En tal caso, el HUD debe a\u00f1adirse como hijo a la c\u00e1mara, para que as\u00ed siempre est\u00e9 en pantalla. Normalmente el scroll deber\u00e1 seguir la posici\u00f3n de nuestro personaje. Conforme movamos nuestro personaje deberemos centrar el mapa en \u00e9l. En juegos 2D podemos crear una ilusi\u00f3n de profundidad creando varias capas de fondo y haciendo que las capas m\u00e1s lejanas se muevan a velocidad m\u00e1s lenta que las m\u00e1s cercanas al hacer scroll . Esto es lo que se conoce como scroll parallax . Algunos motores nos proporcionan facilidades para crear este tipo de scroll .","title":"Scroll del escenario"},{"location":"fundamentos-motores.html","text":"Fundamentos de los motores \u00b6 En esta secci\u00f3n vamos a empezar estudiando una serie de conceptos que ser\u00e1n comunes a la mayor\u00eda de motores. Una vez conocidos estos conceptos, nos ser\u00e1 sencillo aprender a utilizar los diferentes motores existentes, ya que cuentan con librer\u00edas muy similares. Escenas \u00b6 El primer componente que nos vamos a encontrar en el motor del videojuego es la escena . Dentro de nuestro videojuego podremos definir varias escenas y transiciones entre ellas. Estas escenas representar\u00e1n las diferentes \"pantallas\" que componen nuestro videojuego, como podr\u00edan ser por ejemplo: Men\u00fa principal Pantalla donde se desarrolla el juego Pantalla de Game Over Pantalla de introducci\u00f3n de nuestro nombre Pantalla con las puntuaciones m\u00e1ximas Cr\u00e9ditos Transiciones entre escenas \u00b6 Podremos realizar transiciones entre dichas pantallas. Por ejemplo, cuando en el men\u00fa principal pulsemos sobre el bot\u00f3n Play iremos a la pantalla del juego , y cuando nos maten iremos a game over . El motor nos dar\u00e1 facilidades para hacer la transici\u00f3n entre escenas, permitiendo normalmente que la transici\u00f3n se haga mediante alguna animaci\u00f3n (fundido, volteado de la pantalla, etc). De esta forma, podemos ver estas pantallas y las transiciones entre ellas como una m\u00e1quina de estados . Seg\u00fan la escena en la que nos encontremos ( escena activa ), el contenido que se muestre en pantalla y su comportamiento ser\u00e1n distintos. Ciclo del juego \u00b6 La escena que est\u00e9 activa en un momento dado ser\u00e1 la que se ejecute en lo que se conoce como el ciclo del juego . Este ciclo es un bucle que el motor ejecuta a una determinada tasa de iteraciones por segundo, habitualmente a 60 fps ( fotogramas por segundo ). Esta tasa deber\u00eda ser fija, y con un valor que el dispositivo pueda soportar de forma estable. Si nuestro juego fuese muy complejo, podr\u00edamos por ejemplo plantearnos bajarla a 30 fps. Debemos evitar que el juego sufra ca\u00eddas considerables de esta tasa debido a la complejidad del contenido de la escena, ya que causar\u00e1 una mala experiencia para el usuario. En cada iteraci\u00f3n el motor utilizar\u00e1 la escena activa para realizar dos tareas: Update : Se actualiza el contenido de la escena. Esta tarea deberemos programarla nosotros, ya que es donde definiremos el comportamiento de la escena. Habitualmente se realizan las siguientes acciones: Leemos la entrada del usuario (mandos, teclas, pantalla t\u00e1ctil, ...). Normalmente el motor nos facilitar\u00e1 la obtenci\u00f3n de la lectura de la entrada. Actualizamos la posici\u00f3n de nuestro personaje, enemigos y otros elementos. Comprobamos las interacciones entre las entidades del juego y realizamos las acciones oportunas (por ejemplo, si una bala toca un enemigo, matamos al enemigo). Render : Dibuja en pantalla el contenido de la escena en el estado en el que se encuentre actualmente. De esto normalmente se encargar\u00e1 el motor. Nosotros simplemente actualizaremos la posici\u00f3n y otras propiedades de los diferentes elementos de la escena, y el motor se encargar\u00e1 de dibujar todo el contenido en el estado en el que lo hayamos dejado. A continuaci\u00f3n veremos c\u00f3mo se organiza el contenido de la escena. \u00c1rbol de la escena \u00b6 El contenido de la escena se compone de una serie de nodos organizados de forma jer\u00e1rquica. Esto es lo que se conoce como \u00e1rbol de la escena . Normalmente tendremos una clase Node que definir\u00e1 los nodos que pueden formar parte del \u00e1rbol, y de la que derivan diferentes subclases para determinados tipos especializados de nodos. Los m\u00e1s comunes son: Scene : La propia escena habitualmente es un tipo de nodo m\u00e1s, que siempre ser\u00e1 la ra\u00edz del \u00e1rbol. Node : La clase base de los nodos, adem\u00e1s de ser utilizada para heredar de ella y crear tipos especializados de nodos, se utiliza habitualmente tambi\u00e9n como nodo vac\u00edo en el \u00e1rbol que nos permita agrupar otros nodos dentro de \u00e9l. De esta forma, podremos tratar dicho grupo de nodos de forma conjunta, como por ejemplo para moverlos en bloque. LabelNode : Nos permite introducir etiquetas de texto en la escena. Esto resulta de gran utilidad por ejemplo en el men\u00fa, o para los marcadores dentro del juego. SpriteNode : Los sprites son uno de los elementos m\u00e1s utilizados en los videojuegos 2D. Se trata de una imagen que ubicaremos en un determinado lugar de la escena, y que utilizaremos normalmente para mostrar objetos o personajes que pueden moverse por la escena y/o con los que podemos interactuar. En muchas ocasiones, en lugar de mostrar una imagen fija mostrar\u00e1n una animaci\u00f3n por fotogramas (por ejemplo para el ciclo de andar de un personaje) TilemapNode : Se trata de un nodo que nos facilitar\u00e1 crear mapeados extensos para nuestra escena. Existen herramientas, como Tiled , que nos permiten crear mapas con este formato, a partir de un conjunto de piezas ( tiles ) con las que compondremos el mapa. En el siguiente gr\u00e1fico podemos ver un ejemplo de lo que podr\u00eda ser un \u00e1rbol de la escena de un videojuego 2D. Dependiendo del motor que utilicemos, encontraremos tipos adicionales de nodos que podremos incluir en la escena, e incluso podremos definir nuestros propios tipos de nodos especializados en caso necesario. En el caso de videojuegos 3D , tendremos tambi\u00e9n un \u00e1rbol de la escena, aunque en tal caso los nodos que encontraremos representar\u00e1n habitualmente formas geom\u00e9tricas, mallas 3D, luces o c\u00e1maras. Propiedades de los nodos \u00b6 Todos los nodos de la escena comparten una serie de propiedades (todas ellas heredadas de Node ). Vamos a ver a continuaci\u00f3n las propiedades que utilizaremos de forma habitual. Grupo Propiedad Descripci\u00f3n Identificaci\u00f3n name Nos permite buscar el nodo en la escena Posicionamiento position Coordenadas del nodo dentro del sistema de coordenadas de su nodo padre anchorPoint Punto del nodo que se ubicar\u00e1 en sus coordenadas. Tomar\u00e1 valores entre (0,0) , que representa su esquina inferior izquierda, y (1,1) , que representa su esquina superior derecha. A continuaci\u00f3n se muestra una figura ilustrativa sobre el uso de esta propiedad Transformaci\u00f3n rotation Permite rotar el nodo indicando un \u00e1ngulo scale Permite escalar el nodo. Habitualmente se puede tambi\u00e9n escalar el nodo \u00fanicamente en uno de sus ejes ( x o y ) Visibilidad alpha Nos permite indicar la opacidad del nodo, tomando valores desde 0 (transparente) hasta 1 (opaco) hidden Nos permite ocultar totalmente el nodo (no se renderizar\u00e1, ahorrando el correspondiente tiempo de procesamiento) Tama\u00f1o size Tama\u00f1o del \u00e1rea rectangular que ocupa el nodo en la escena. Dada la posici\u00f3n y esta propiedad, podremos saber la regi\u00f3n en la escena que ocupa exactamente el nodo, permitiendo de esta forma comprobar si dos nodos est\u00e1n en contacto, o bien si estamos tocando sobre alguno de los nodos Orden z Establece el orden z , es decir, qu\u00e9 nodos se dibujan delante de otros. En la pr\u00f3xima secci\u00f3n hablaremos en mayor detalle sobre esta propiedad. Capas y orden Z \u00b6 El orden en el que se dibujar\u00e1n los nodos en pantalla es lo que se conoce como orden Z , que indica la profundidad de cada nodo en la escena. Cuando mayor sea Z, m\u00e1s delante estar\u00e1 el nodo (tapar\u00e1 a los nodos con menor Z). Dicho orden Z determina el orden en el que se dibujar\u00e1n los nodos hermanos . Los hermanos con menor Z se dibujar\u00e1n antes, y por lo tanto ser\u00e1n tapados por los hermanos con mayor Z. Para dibujar cada hermano, se dibujar\u00e1 el propio nodo, y en caso de tener hijos, se dibujar\u00e1n siguiendo el orden Z establecido entre ellos, y as\u00ed recursivamente. Es decir, el \u00e1rbol se recorre en preorden para su dibujado. De esta forma, podemos ver cada nodo como una capa compuesta por el nodo y todos sus hijos, cuyo orden Z determinar\u00e1 si queda por delante o por detr\u00e1s de sus hermanos. Es importante destacar tambi\u00e9n que el orden Z es una propiedad local entre los hijos de cada nodo. Algunos motores nos permiten tambi\u00e9n calcular un orden Z global a partir de la estructura del \u00e1rbol. A\u00f1adiendo y eliminando nodos de la escena \u00b6 La escena en ocasiones la podremos construir mediante un editor visual, o bien de forma programada. En cualquier caso, deberemos organizar los nodos de forma jer\u00e1rquica. Para manipular dicha jerarqu\u00eda (a\u00f1adir o eliminar nodos), contaremos con los siguientes m\u00e9todos de los nodos: Funci\u00f3n M\u00e9todo A\u00f1adir nodos nodoPadre.addChild(nodoHijo) Eliminar un nodo nodoHijo.removeFromParent() Podemos observar que cuando queramos a\u00f1adir un nuevo nodo, deberemos hacerlo sobre el nodo que ser\u00e1 su padre, para indicar en qu\u00e9 lugar de la jerarqu\u00eda estar\u00e1. Sin embargo, para eliminarlo bastar\u00e1 con indica que lo elimine de quien sea su padre, sin necesidad de especificarlo. De esta forma se eliminar\u00e1 el nodo de la jerarqu\u00eda, y por lo tanto la escena dejar\u00e1 de actualizarlo y de renderizarlo . Adem\u00e1s, normalmente los motores nos proporcionar\u00e1n m\u00e9todos adicionales para: Buscar un nodo en la jerarqu\u00eda a partir de su nombre. Especialmente necesario cuando hemos dise\u00f1ado la escena mediante un editor visual y queremos manipularla desde el c\u00f3digo. Consultar la lista de hijos de un nodo. Reordenar los nodos del \u00e1rbol.","title":"Escena y nodos"},{"location":"fundamentos-motores.html#fundamentos-de-los-motores","text":"En esta secci\u00f3n vamos a empezar estudiando una serie de conceptos que ser\u00e1n comunes a la mayor\u00eda de motores. Una vez conocidos estos conceptos, nos ser\u00e1 sencillo aprender a utilizar los diferentes motores existentes, ya que cuentan con librer\u00edas muy similares.","title":"Fundamentos de los motores"},{"location":"fundamentos-motores.html#escenas","text":"El primer componente que nos vamos a encontrar en el motor del videojuego es la escena . Dentro de nuestro videojuego podremos definir varias escenas y transiciones entre ellas. Estas escenas representar\u00e1n las diferentes \"pantallas\" que componen nuestro videojuego, como podr\u00edan ser por ejemplo: Men\u00fa principal Pantalla donde se desarrolla el juego Pantalla de Game Over Pantalla de introducci\u00f3n de nuestro nombre Pantalla con las puntuaciones m\u00e1ximas Cr\u00e9ditos","title":"Escenas"},{"location":"fundamentos-motores.html#transiciones-entre-escenas","text":"Podremos realizar transiciones entre dichas pantallas. Por ejemplo, cuando en el men\u00fa principal pulsemos sobre el bot\u00f3n Play iremos a la pantalla del juego , y cuando nos maten iremos a game over . El motor nos dar\u00e1 facilidades para hacer la transici\u00f3n entre escenas, permitiendo normalmente que la transici\u00f3n se haga mediante alguna animaci\u00f3n (fundido, volteado de la pantalla, etc). De esta forma, podemos ver estas pantallas y las transiciones entre ellas como una m\u00e1quina de estados . Seg\u00fan la escena en la que nos encontremos ( escena activa ), el contenido que se muestre en pantalla y su comportamiento ser\u00e1n distintos.","title":"Transiciones entre escenas"},{"location":"fundamentos-motores.html#ciclo-del-juego","text":"La escena que est\u00e9 activa en un momento dado ser\u00e1 la que se ejecute en lo que se conoce como el ciclo del juego . Este ciclo es un bucle que el motor ejecuta a una determinada tasa de iteraciones por segundo, habitualmente a 60 fps ( fotogramas por segundo ). Esta tasa deber\u00eda ser fija, y con un valor que el dispositivo pueda soportar de forma estable. Si nuestro juego fuese muy complejo, podr\u00edamos por ejemplo plantearnos bajarla a 30 fps. Debemos evitar que el juego sufra ca\u00eddas considerables de esta tasa debido a la complejidad del contenido de la escena, ya que causar\u00e1 una mala experiencia para el usuario. En cada iteraci\u00f3n el motor utilizar\u00e1 la escena activa para realizar dos tareas: Update : Se actualiza el contenido de la escena. Esta tarea deberemos programarla nosotros, ya que es donde definiremos el comportamiento de la escena. Habitualmente se realizan las siguientes acciones: Leemos la entrada del usuario (mandos, teclas, pantalla t\u00e1ctil, ...). Normalmente el motor nos facilitar\u00e1 la obtenci\u00f3n de la lectura de la entrada. Actualizamos la posici\u00f3n de nuestro personaje, enemigos y otros elementos. Comprobamos las interacciones entre las entidades del juego y realizamos las acciones oportunas (por ejemplo, si una bala toca un enemigo, matamos al enemigo). Render : Dibuja en pantalla el contenido de la escena en el estado en el que se encuentre actualmente. De esto normalmente se encargar\u00e1 el motor. Nosotros simplemente actualizaremos la posici\u00f3n y otras propiedades de los diferentes elementos de la escena, y el motor se encargar\u00e1 de dibujar todo el contenido en el estado en el que lo hayamos dejado. A continuaci\u00f3n veremos c\u00f3mo se organiza el contenido de la escena.","title":"Ciclo del juego"},{"location":"fundamentos-motores.html#arbol-de-la-escena","text":"El contenido de la escena se compone de una serie de nodos organizados de forma jer\u00e1rquica. Esto es lo que se conoce como \u00e1rbol de la escena . Normalmente tendremos una clase Node que definir\u00e1 los nodos que pueden formar parte del \u00e1rbol, y de la que derivan diferentes subclases para determinados tipos especializados de nodos. Los m\u00e1s comunes son: Scene : La propia escena habitualmente es un tipo de nodo m\u00e1s, que siempre ser\u00e1 la ra\u00edz del \u00e1rbol. Node : La clase base de los nodos, adem\u00e1s de ser utilizada para heredar de ella y crear tipos especializados de nodos, se utiliza habitualmente tambi\u00e9n como nodo vac\u00edo en el \u00e1rbol que nos permita agrupar otros nodos dentro de \u00e9l. De esta forma, podremos tratar dicho grupo de nodos de forma conjunta, como por ejemplo para moverlos en bloque. LabelNode : Nos permite introducir etiquetas de texto en la escena. Esto resulta de gran utilidad por ejemplo en el men\u00fa, o para los marcadores dentro del juego. SpriteNode : Los sprites son uno de los elementos m\u00e1s utilizados en los videojuegos 2D. Se trata de una imagen que ubicaremos en un determinado lugar de la escena, y que utilizaremos normalmente para mostrar objetos o personajes que pueden moverse por la escena y/o con los que podemos interactuar. En muchas ocasiones, en lugar de mostrar una imagen fija mostrar\u00e1n una animaci\u00f3n por fotogramas (por ejemplo para el ciclo de andar de un personaje) TilemapNode : Se trata de un nodo que nos facilitar\u00e1 crear mapeados extensos para nuestra escena. Existen herramientas, como Tiled , que nos permiten crear mapas con este formato, a partir de un conjunto de piezas ( tiles ) con las que compondremos el mapa. En el siguiente gr\u00e1fico podemos ver un ejemplo de lo que podr\u00eda ser un \u00e1rbol de la escena de un videojuego 2D. Dependiendo del motor que utilicemos, encontraremos tipos adicionales de nodos que podremos incluir en la escena, e incluso podremos definir nuestros propios tipos de nodos especializados en caso necesario. En el caso de videojuegos 3D , tendremos tambi\u00e9n un \u00e1rbol de la escena, aunque en tal caso los nodos que encontraremos representar\u00e1n habitualmente formas geom\u00e9tricas, mallas 3D, luces o c\u00e1maras.","title":"\u00c1rbol de la escena"},{"location":"fundamentos-motores.html#propiedades-de-los-nodos","text":"Todos los nodos de la escena comparten una serie de propiedades (todas ellas heredadas de Node ). Vamos a ver a continuaci\u00f3n las propiedades que utilizaremos de forma habitual. Grupo Propiedad Descripci\u00f3n Identificaci\u00f3n name Nos permite buscar el nodo en la escena Posicionamiento position Coordenadas del nodo dentro del sistema de coordenadas de su nodo padre anchorPoint Punto del nodo que se ubicar\u00e1 en sus coordenadas. Tomar\u00e1 valores entre (0,0) , que representa su esquina inferior izquierda, y (1,1) , que representa su esquina superior derecha. A continuaci\u00f3n se muestra una figura ilustrativa sobre el uso de esta propiedad Transformaci\u00f3n rotation Permite rotar el nodo indicando un \u00e1ngulo scale Permite escalar el nodo. Habitualmente se puede tambi\u00e9n escalar el nodo \u00fanicamente en uno de sus ejes ( x o y ) Visibilidad alpha Nos permite indicar la opacidad del nodo, tomando valores desde 0 (transparente) hasta 1 (opaco) hidden Nos permite ocultar totalmente el nodo (no se renderizar\u00e1, ahorrando el correspondiente tiempo de procesamiento) Tama\u00f1o size Tama\u00f1o del \u00e1rea rectangular que ocupa el nodo en la escena. Dada la posici\u00f3n y esta propiedad, podremos saber la regi\u00f3n en la escena que ocupa exactamente el nodo, permitiendo de esta forma comprobar si dos nodos est\u00e1n en contacto, o bien si estamos tocando sobre alguno de los nodos Orden z Establece el orden z , es decir, qu\u00e9 nodos se dibujan delante de otros. En la pr\u00f3xima secci\u00f3n hablaremos en mayor detalle sobre esta propiedad.","title":"Propiedades de los nodos"},{"location":"fundamentos-motores.html#capas-y-orden-z","text":"El orden en el que se dibujar\u00e1n los nodos en pantalla es lo que se conoce como orden Z , que indica la profundidad de cada nodo en la escena. Cuando mayor sea Z, m\u00e1s delante estar\u00e1 el nodo (tapar\u00e1 a los nodos con menor Z). Dicho orden Z determina el orden en el que se dibujar\u00e1n los nodos hermanos . Los hermanos con menor Z se dibujar\u00e1n antes, y por lo tanto ser\u00e1n tapados por los hermanos con mayor Z. Para dibujar cada hermano, se dibujar\u00e1 el propio nodo, y en caso de tener hijos, se dibujar\u00e1n siguiendo el orden Z establecido entre ellos, y as\u00ed recursivamente. Es decir, el \u00e1rbol se recorre en preorden para su dibujado. De esta forma, podemos ver cada nodo como una capa compuesta por el nodo y todos sus hijos, cuyo orden Z determinar\u00e1 si queda por delante o por detr\u00e1s de sus hermanos. Es importante destacar tambi\u00e9n que el orden Z es una propiedad local entre los hijos de cada nodo. Algunos motores nos permiten tambi\u00e9n calcular un orden Z global a partir de la estructura del \u00e1rbol.","title":"Capas y orden Z"},{"location":"fundamentos-motores.html#anadiendo-y-eliminando-nodos-de-la-escena","text":"La escena en ocasiones la podremos construir mediante un editor visual, o bien de forma programada. En cualquier caso, deberemos organizar los nodos de forma jer\u00e1rquica. Para manipular dicha jerarqu\u00eda (a\u00f1adir o eliminar nodos), contaremos con los siguientes m\u00e9todos de los nodos: Funci\u00f3n M\u00e9todo A\u00f1adir nodos nodoPadre.addChild(nodoHijo) Eliminar un nodo nodoHijo.removeFromParent() Podemos observar que cuando queramos a\u00f1adir un nuevo nodo, deberemos hacerlo sobre el nodo que ser\u00e1 su padre, para indicar en qu\u00e9 lugar de la jerarqu\u00eda estar\u00e1. Sin embargo, para eliminarlo bastar\u00e1 con indica que lo elimine de quien sea su padre, sin necesidad de especificarlo. De esta forma se eliminar\u00e1 el nodo de la jerarqu\u00eda, y por lo tanto la escena dejar\u00e1 de actualizarlo y de renderizarlo . Adem\u00e1s, normalmente los motores nos proporcionar\u00e1n m\u00e9todos adicionales para: Buscar un nodo en la jerarqu\u00eda a partir de su nombre. Especialmente necesario cuando hemos dise\u00f1ado la escena mediante un editor visual y queremos manipularla desde el c\u00f3digo. Consultar la lista de hijos de un nodo. Reordenar los nodos del \u00e1rbol.","title":"A\u00f1adiendo y eliminando nodos de la escena"},{"location":"mandos.html","text":"Controles del videojuego \u00b6 La principal forma de control del m\u00f3vil es la pantalla t\u00e1ctil, por lo que los videojuegos dise\u00f1ados espec\u00edficamente para m\u00f3viles normalmente se adaptan a esta forma de entrada. Encontramos tambi\u00e9n algunos juegos dise\u00f1ados para ser manejados mediante el aceler\u00f3metro. Sin embargo, cuando se quiere trasladar a m\u00f3vil un juego dise\u00f1ado originalmente para otro sistema en el que contamos con teclado, rat\u00f3n o joystick deberemos adaptar su forma de manejo, ya que en la mayor\u00eda de casos no contamos con dichos mecanismos de entrada en m\u00f3viles. Vamos a ver los diferentes mecanismos de entrada que podemos utilizar en los videojuegos para m\u00f3viles, y una serie de buenas pr\u00e1cticas a la hora de implementar el control de estos videojuegos. Teclado en Cocos2d-x \u00b6 Cocos2d-x soporta eventos de teclado, pero \u00e9stos no funcionan en plataformas m\u00f3viles. Aunque nuestro proyecto est\u00e9 orientado exclusivamente a estas plataformas, si el control de nuestro juego se realiza mediante mando es recomendable que implementemos tambi\u00e9n la posibilidad de controlarlo mediante teclado. Esto ser\u00e1 de gran utilidad durante el desarrollo, ya que no existe forma de emular un mando, y la forma m\u00e1s parecida al mando para manejar nuestro juego en las pruebas que hagamos durante el desarrollo es el control mediante teclado. Para leer los eventos de teclado desde Cocos2d-x podemos utilizar la clase EventListenerKeyboard como se muestra a continuaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 bool MiEscena :: init () { if ( ! Layer :: init () ) { return false ; } configuraTeclado (); return true ; } void MiEscena :: configurarTeclado () { _listener = EventListenerKeyboard :: create (); // Registramos callbacks _listener -> onKeyPressed = CC_CALLBACK_2 ( MiEscena :: onConnectController , this ); _listener -> onReleased = CC_CALLBACK_2 ( MiEscena :: onDisconnectedController , this ); // A\u00f1adimos el listener el mando al gestor de eventos _eventDispatcher -> addEventListenerWithSceneGraphPriority ( _listener , this ); } void MiEscena :: onKeyDown ( EventKeyboard :: KeyCode code , Event * event ) { } void MiEscena :: onKeyUp ( EventKeyboard :: KeyCode code , Event * event ) { } Por ejemplo, para reconocer los controles izquierda-derecha mediante las teclas A-D podr\u00edamos escribir los m\u00e9todos onKeyDown y onKeyUp como se muestra a continuaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void MiEscena :: onKeyDown ( EventKeyboard :: KeyCode code , Event * event ) { switch ( keyCode ){ case EventKeyboard :: KeyCode :: KEY_A : _izquierdaPulsado = true ; break ; case EventKeyboard :: KeyCode :: KEY_D : _derechaPulsado = true ; break ; } } void MiEscena :: onKeyUp ( EventKeyboard :: KeyCode code , Event * event ) { switch ( keyCode ){ case EventKeyboard :: KeyCode :: KEY_A : _izquierdaPulsado = false ; break ; case EventKeyboard :: KeyCode :: KEY_D : _derechaPulsado = false ; break ; } } Pantalla t\u00e1ctil \u00b6 Como hemos comentado, es el mecanismo m\u00e1s habitual de entrada en los videojuegos para m\u00f3viles. En muchos tipos de videojuegos esta es la forma de control m\u00e1s natural. Por ejemplo, tenemos puzzles en los que tenemos que interactuar con diferentes elementos del escenario tocando sobre ellos. Tambi\u00e9n en el g\u00e9nero tower defense resulta natural posicionar nuestras diferentes unidades tocando sobre la pantalla, o de forma m\u00e1s amplia en el g\u00e9nero de la estrategia interactuar con nuestros recursos y unidades pulsando sobre ellos. La pantalla t\u00e1ctil tiene ciertas similitudes con el control mediante rat\u00f3n, pudiendo trasladar muchos juegos que originalmente se controlaban mediante rat\u00f3n a dispositivos t\u00e1ctiles. Sin embargo, debemos tener en cuenta algunas diferencias importantes. Los juegos en los que el rat\u00f3n se utiliza para el control de la c\u00e1mara y para apuntar desliz\u00e1ndolo (como es el caso fundamentalmente de los First Person Shooters ), encontraremos una p\u00e9rdida al pasarlos a la pantalla t\u00e1ctil, y no ser\u00e1 trivial implementarlo de forma correcta. Sin embargo, aquellos en los que se utilice para seleccionar elementos mediante el puntero ganar\u00e1n con la pantalla t\u00e1ctil, ya que ser\u00e1 m\u00e1s r\u00e1pido pulsar sobre estos elementos con el dedo que tener que deslizar el puntero del rat\u00f3n. Adem\u00e1s, tenemos que tener en cuenta una ventaja muy importante de la pantalla t\u00e1ctil sobre el rat\u00f3n: es multit\u00e1ctil. Esto quiere decir que podemos tener al mismo tiempo varios contactos en pantalla, cosa que con el rat\u00f3n no es posible. Esto nos da un gran abanico de posibilidades a la hora de implementar el control en nuestros videojuegos. Pantalla t\u00e1ctil en Cocos2d-x \u00b6 Vamos a ver la forma de implementar este mecanismo de control en Cocos2d-x. Para la detecci\u00f3n de eventos de la pantalla t\u00e1ctil crearemos un listener de tipo EventListenerTouch : Encontramos dos variantes: EventListenerTouchOneByOne : Procesa los eventos de la pantalla t\u00e1ctil de uno en uno. Cada vez que se reciba un evento ser\u00e1 sobre un \u00fanico contacto ( Touch ). Es m\u00e1s sencillo de implementar, y resultar\u00e1 adecuado para aquellos juegos en los que no necesitemos detectar m\u00e1s de un contacto al mismo tiempo. EventListenerTouchAllAtOnce : En este caso podremos recibir en cada evento informaci\u00f3n de varios contactos (recibiremos una lista de objetos Touch ). Ser\u00e1 m\u00e1s complicado de gestionar, pero nos permitir\u00e1 implementar juegos que hagan uso de la pantalla multit\u00e1ctil. Una vez seleccionado el listener que m\u00e1s nos interese para nuestro videojuego, lo inicializaremos de la siguiente forma: 1 auto listener = EventListenerTouchOneByOne :: create (); Eventos de la pantalla t\u00e1ctil en Cocos2d-x \u00b6 Hablaremos de un gesto t\u00e1ctil para referirnos a la secuencia que consiste en tocar sobre la pantalla, deslizar el dedo, y levantarlo de la pantalla. Durante el gesto se producir\u00e1n tres tipos de eventos: onTouchBegan : Evento de comienzo de un gesto. En este evento podemos decidir si queremos procesar el resto del gesto o no. En caso de no estar interesados en este gesto ya no recibiremos ning\u00fan evento m\u00e1s del mismo (ni de movimiento ni de finalizaci\u00f3n). onTouchMoved : Evento de continuaci\u00f3n del gesto. Mientras desplacemos el contacto por la pantalla recibiremos eventos de movimiento con sus nuevas coordenadas. onTouchEnded : Evento de finalizaci\u00f3n del gesto. Al levantar el dedo de la pantalla el gesto finalizar\u00e1. Podemos indicar callbacks para estos eventos mediante funciones lambda , o utilizandos la macro CC_CALLBACK_2 . Comenzamos con el evento de comienzo del gesto. La funci\u00f3n callback deber\u00e1 devolver un booleano indicando si estamos interesados en el gesto o no. Por ejemplo, podemos considerar que nos interesa el gesto si hemos pulsado sobre un determinado sprite , y que no nos interesa en caso contrario. 1 2 3 4 5 6 7 listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ){ if ( estaSobreSprite ( touch )) { return true ; } else { return false ; } }; De forma similar definiremos los eventos de movimiento y finalizaci\u00f3n, aunque en estos casos no deberemos devolver ning\u00fan valor: 1 2 3 4 5 6 7 listener -> onTouchMoved = [ = ]( Touch * touch , Event * event ){ ... }; listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ){ ... }; Prioridad de los eventos \u00b6 Una vez definidos los eventos, a\u00f1adimos el listener a la escena: 1 m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , m_sprite ); En este caso m_node ser\u00eda el nodo principal que contiene nuestra escena, y m_sprite el nodo que queremos que act\u00fae como objetivo ( target ) de nuestro listener . Podemos a\u00f1adir el listener con dos sistemas de prioridad distintos: Prioridad de grafo de la escena : La prioridad en la que se ejecutan los diferentes listeners viene determinada por el orden de los nodos en el grafo de la escena. El nodo que pasamos como target al a\u00f1adir el listener ser\u00e1 el que determine dicha prioridad. Se ejecutar\u00e1n antes los eventos definidos sobre nodos que queden delante de otros en la pantalla (es decir, primero aquellos que tengan mayor Z). Prioridad fija : En este caso la prioridad se especifica mediante un valor fijo al a\u00f1adir el listener . Consumo de eventos \u00b6 Al crear un listener podemos indicar que consuma los eventos: 1 listener -> setSwallowTouches ( true ); Si hacemos esto, en caso de que nuestro listener devuelva true en onTouchBegan consumir\u00e1 el evento y \u00e9ste no pasar\u00e1 a otros listeners de menor prioridad. En caso contrario, el evento se propagar\u00e1 al siguiente listener Nodo objetivo del listener \u00b6 Hemos visto que al utilizar prioridad basada en el grafo de la escena cada listener tiene un nodo objetivo. Podemos aprovechar esto para utilizar dicho nodo como nodo sobre el que estamos interesados en pulsar: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point locationInNode = target -> convertToNodeSpace ( touch -> getLocation ()); Size s = target -> getContentSize (); Rect rect = Rect ( 0 , 0 , s . width , s . height ); if ( rect . containsPoint ( locationInNode )) { return true ; } else { return false ; } }; Con Event::getCurrentTarget podemos obtener el nodo que act\u00faa de target . Podemos convertir las coordenadas globales del touch a coordenadas locales del nodo target , y en caso de estar dentro del \u00e1rea que ocupa dicho nodo entonces devolvemos true para seguir procesando eventos de este gesto. De esta forma podemos hacer por ejemplo que al pulsar sobre nuestro sprite podamos arrastrarlo por la pantalla, mientras que si pulsamos fuera este listener no har\u00e1 nada. Pantalla multit\u00e1ctil \u00b6 Cocos2d-x soporta pantalla multit\u00e1ctil, pero por defecto se encuentra deshabilitada en iOS. Para habilitar el soporte para recibir varios contactos simult\u00e1neos en esta plataforma, deberemos abrir el fichero AppController.mm y localizar la siguiente l\u00ednea: 1 [ eaglView setMultipleTouchEnabled : NO ]; La modificaremos de forma que si que est\u00e9 habilitado el soporte para m\u00faltiples contactos: 1 [ eaglView setMultipleTouchEnabled : YES ]; En Android no ser\u00e1 necesario que hagamos nada, el soporte para pantalla multit\u00e1ctil est\u00e1 habilitado por defecto. Aceler\u00f3metro \u00b6 Encontramos tambi\u00e9n algunos juegos en los que el mecanismo de control m\u00e1s natural es el uso del aceler\u00f3metro. Por ejemplo juegos que cambian la gravedad en la escena seg\u00fan la inclinaci\u00f3n del m\u00f3vil, como es el caso de los juegos en los que manejamos una bola a trav\u00e9s de un laberinto, o juegos de conducci\u00f3n en los que la inclinaci\u00f3n del m\u00f3vil hace de volante. En Cocos2d-x implementaremos soporte para el aceler\u00f3metro mediante un listener de tipo EventListenerAcceleration . Para que este listener funcione, en primer lugar deberemos activar el uso del aceler\u00f3metro: 1 Device :: setAccelerometerEnabled ( true ); Una vez hecho esto, creamos el listener especificando directamente un callback mediante una funci\u00f3n lambda : 1 2 3 auto listener = EventListenerAcceleration :: create ([ = ]( Acceleration * acc , Event * event ) { ... } Tambi\u00e9n podemos utilizar la macro CC_CALLBACK_2 : 1 auto listener = EventListenerAcceleration :: create ( CC_CALLBACK_2 ( Game :: onAcceleration , this )); 1 2 3 4 void Game :: onAcceleration ( Acceleration * acc , Event * event ) { ... } Por \u00faltimo, a\u00f1adiremos el listener al gestor de eventos de la escena: 1 m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , m_node ); Es importante tener en cuenta que en los juegos que se manejen mediante aceler\u00f3metro, al no ser necesario tocar la pantalla, no debemos permitir que esta se apague de forma autom\u00e1tica por inactividad. Esto no se puede hacer directamente con Cocos2d-x, sino que tendremos que especificarlo de forma nativa para cada plataforma. Mandos \u00b6 Los juegos dise\u00f1ados para videoconsolas o m\u00e1quinas recreativas se manejan normalmente mediante joystick o pad . Al portar uno de estos juegos a m\u00f3vil podemos optar por: Adaptar el control de videojuego a pantalla t\u00e1ctil. Esto implica grandes cambios en el dise\u00f1o del juego y en el gameplay y no siempre es posible hacerlo. A\u00f1adir un pad virtual en pantalla. Permite mantener el mismo mecanismo de control que el juego original, pero resulta m\u00e1s complicado de manejar que con un mando real. A\u00f1adir soporte para mandos f\u00edsicos. Nos permitir\u00e1 trasladar la misma experiencia de juego que la versi\u00f3n de videoconsola/recreativa pero necesita que el usuario cuente con este dispositivo. Se pierde una de las ventajas de los juegos m\u00f3viles, que es el llevarlos siempre con nosotros. Vamos ahora a centrarnos en este tipo de juegos y en la forma de dise\u00f1ar un control adecuado para ellos. Veremos tanto la forma de incorporar un pad virtual como la forma de a\u00f1adir soporte para diferentes tipos de mandos f\u00edsicos. Dentro de estos mandos encontramos tanto mandos soportados por las APIs oficiales de iOS y Android, como mandos con APIs de terceros, como por ejemplo iCade. Buenas pr\u00e1cticas para juegos basados en control pad \u00b6 Si queremos implementar un juego cuyo manejo est\u00e9 basado en control pad , ser\u00e1 recomendable seguir las siguientes pr\u00e1cticas: Permitir el manejo del juego mediante pad virtual en pantalla si no se dispone de mando real. A\u00f1adir compatibilidad con mandos reales. Se recomienda a\u00f1adir soporte para las APIs oficiales y para aquellos mandos m\u00e1s utilizados, como iCade. En caso de tener conectado un mando real, ocultar el pad virtual para que no moleste en pantalla. Respetaremos la funci\u00f3n est\u00e1ndar de cada bot\u00f3n. El bot\u00f3n de pausa del mando debe permitir pausar el juego en cualquier momento. Determinados botones se suelen utilizar para realizar las mismas acciones en todos los juegos (saltos, ataque, acci\u00f3n, etc). Deberemos intentar seguir estas convenciones. La pantalla del m\u00f3vil no debe apagarse mientras utilizamos el juego con el mando externo. Mandos virtuales \u00b6 Cuando la mecanica de nuestro juego exige que se controles mediante un mando tradicional, y no contamos con ning\u00fan mando hardware que podamos utilizar, la \u00fanica soluci\u00f3n ser\u00e1 introducir en nuestro juego un mando virtual en pantalla. Vamos a ver diferentes tipos de mandos que podemos implementar en pantalla, emulando controles tanto digitales como anal\u00f3gicos. Controles virtuales \u00b6 Antes de implementar un mecanismo de control concreto, es conveniente generar una estructura de clases que haga de fachada y nos permita implementar el control del videojuego de forma gen\u00e9rica, sin hacer referencia expresa al teclado, mandos f\u00edsicos, o mandos virtuales. En esta secci\u00f3n proponemos un sistema de control virtual basado en herencia. Implementaremos una clase VirtualControls que nos dar\u00e1 la informaci\u00f3n necesaria para leer los controles que necesite nuestro videojuego. Por ejemplo, si necesitamos un joystick anal\u00f3gico con dos ejes (horizontal y vertical) y tres botones digitales, nuestra clase nos dar\u00e1 informaci\u00f3n sobre estos controles virtuales, sin determinar qu\u00e9 mecanismo concreto se utiliza para implementarlos. Esto ser\u00e1 responsabilidad de las subclases de VirtualControls , que ser\u00e1n las que implementen el mapeo entre un mecanismo de control concreto y los controles virtuales definidos en VirtualControls . De esta forma, simplemente cambiando la subclase de VirtualControls que instanciamos podremos cambiar la forma de controlar el videojuego. Vamos a ver un ejemplo de implementaci\u00f3n de sistema gen\u00e9rico de control. En primer lugar definiremos los botones y ejes virtuales que necesitamos reconocer en el videojuego: 1 2 3 4 5 6 7 8 9 10 11 12 13 #define kNUM_BUTTONS 3 #define kNUM_AXIS 2 enum Button { BUTTON_ACTION = 0 , BUTTON_LEFT = 1 , BUTTON_RIGHT = 2 }; enum Axis { AXIS_HORIZONTAL = 0 , AXIS_VERTICAL = 1 }; En este caso hemos definido tres botones (acci\u00f3n, izquierda y derecha), y dos ejes (horizontal y vertical), aunque podr\u00edamos adaptar esto a las necesidades de cada juego. Indicamos mediante constantes el n\u00famero de botones y ejes, e identificamos cada uno mediante elementos mediante enumeraciones. Los botones tendr\u00e1n como estado un booleano (pulsado o no pulsado), mientras que los ejes tendr\u00e1n como valor un valor de tipo float entre -1 y 1 (palanca totalmente inclinada en un sentido o en el contrario), y valdr\u00e1 0 si est\u00e1 en reposo. Mostramos a continuaci\u00f3n la estructura completa que podr\u00eda tener la clase que implemente el control virtual : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class VirtualControls : public Ref { public : bool init (); virtual void preloadResources (){}; virtual Node * getNode () { return NULL ;}; bool isButtonPressed ( Button button ); float getAxis ( Axis axis ); std :: function < void ( Button ) > onButtonPressed ; std :: function < void ( Button ) > onButtonReleased ; // Keyboard controls void onKeyPressed ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ); void onKeyReleased ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ); void addKeyboardListeners ( cocos2d :: Node * node ); CREATE_FUNC ( VirtualControls ); protected : bool buttonState [ kNUM_BUTTONS ]; float axisState [ kNUM_AXIS ]; }; Como vemos, la clase controla el estado de los botones (pulsados o sin pulsar) y el de los ejes, que oscilar\u00e1 entre -1 (totalmente a la izquierda) y 1 (totalmente a la derecha). Deberemos poder leer el estado de estos controles virtuales en cualquier momento. Para ello hemos incorporado las propiedades buttonState y axisState , en las que almacenamos este estado, y proporcionamos los m\u00e9todos isButtonPressed y getAxis para consultarlos. Definimos tambi\u00e9n los eventos onButtonPressed y onButtonReleased para los cuales podremos definir callbacks . De esta forma podremos tener constancia de que un bot\u00f3n ha sido pulsado o soltado, sin tener que comprobar continuamente su estado. Adem\u00e1s, incluimos la posibilidad de devolver un nodo (m\u00e9todo getNode ) que nos permita pintar controles virtuales en pantalla (de momento estar\u00e1 vac\u00edo), y tambi\u00e9n un m\u00e9todo para cargar los recursos necesarios para pintar estos controles ( preloadResources ). Estos m\u00e9todos se definir\u00e1n en las subclases de VirtualControls . Vamos a ver a continuaci\u00f3n c\u00f3mo implementar cada m\u00e9todo de esta clase. En primer lugar, el m\u00e9todo para su inicializaci\u00f3n ( init ) simplemente establecer\u00e1 el estado de los botones a \"no pulsado\" ( false ) y los ejes en reposo ( 0 ): 1 2 3 4 5 6 7 8 9 10 11 bool VirtualControls :: init (){ for ( int i = 0 ; i < kNUM_BUTTONS ; i ++ ) { buttonState [ i ] = false ; } for ( int i = 0 ; i < kNUM_AXIS ; i ++ ) { axisState [ i ] = 0.0f ; } return true ; } Tambi\u00e9n ser\u00e1 necesario definir los m\u00e9todos para poder leer el estado de los controles (botones y ejes): 1 2 3 4 5 6 7 bool VirtualControls :: isButtonPressed ( Button button ) { return buttonState [ button ]; } float VirtualControls :: getAxis ( Axis axis ) { return clampf ( axisState [ axis ], - 1.0 , 1.0 ); } De momento s\u00f3lo hemos definido en esta clase los controles que se utilizar\u00e1n en el juego y lo m\u00e9todos para consultarlos, pero de momento no se ha establecido la forma de darles valor a estos controles. Esto es algo que deber\u00e1 implementar cada subclase concreta. Sin embargo, para depuraci\u00f3n puede ser conveniente poder activar al control por teclado. Vamos a hacer que la clase base implemente controles de teclado para depuraci\u00f3n. En primer lugar actualizamos la definici\u00f3n de la clase VirtualControls . A\u00f1adimos a ella los callbacks necesarios para recibir los controles de teclado, y un m\u00e9todo para activar el control por teclado en nuestro juego ( addKeyboardListeners ): 1 2 3 4 5 6 7 8 9 10 11 12 class VirtualControls : public Ref { public : ... // Keyboard controls void onKeyPressed ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ); void onKeyReleased ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ); void addKeyboardListeners ( cocos2d :: Node * node ); ... }; A continuaci\u00f3n, en la implementaci\u00f3n de la clase introducimos el c\u00f3digo de los callbacks de los eventos de teclado: las teclas Cursor Izquierda y Cursor Derecha modificar\u00e1n el valor del eje horizontal (al mismo tiempo que el estado de los botones BUTTON_LEFT y BUTTON_RIGHT ), y la tecla espacio modificar\u00e1 el estado del bot\u00f3n BUTTON_ACTION : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 void VirtualControls :: onKeyPressed ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ){ if ( onButtonPressed ) { if ( keyCode == EventKeyboard :: KeyCode :: KEY_LEFT_ARROW ) { onButtonPressed ( Button :: BUTTON_LEFT ); axisState [ Axis :: AXIS_HORIZONTAL ] -= 1.0 ; } else if ( keyCode == EventKeyboard :: KeyCode :: KEY_RIGHT_ARROW ) { onButtonPressed ( Button :: BUTTON_RIGHT ); axisState [ Axis :: AXIS_HORIZONTAL ] += 1.0 ; } else if ( keyCode == EventKeyboard :: KeyCode :: KEY_SPACE ) { onButtonPressed ( Button :: BUTTON_ACTION ); } } } void VirtualControls :: onKeyReleased ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ){ if ( onButtonReleased ) { if ( keyCode == EventKeyboard :: KeyCode :: KEY_LEFT_ARROW ) { onButtonReleased ( Button :: BUTTON_LEFT ); axisState [ Axis :: AXIS_HORIZONTAL ] += 1.0 ; } else if ( keyCode == EventKeyboard :: KeyCode :: KEY_RIGHT_ARROW ) { onButtonReleased ( Button :: BUTTON_RIGHT ); axisState [ Axis :: AXIS_HORIZONTAL ] -= 1.0 ; } else if ( keyCode == EventKeyboard :: KeyCode :: KEY_SPACE ) { onButtonReleased ( Button :: BUTTON_ACTION ); } } } De esta forma mapeamos la lectura del teclado sobre nuestro sistema de control virtual. Debemos a\u00f1adir tambi\u00e9n un m\u00e9todo que cree el listener necesario para escuchar los eventos de teclado, y programarlo para que avise a los callbacks definidos anteriormente. Esto lo podemos hacer de la siguiente forma: 1 2 3 4 5 6 7 8 9 10 11 void VirtualControls :: addKeyboardListeners ( cocos2d :: Node * node ) { //Creo listeners del teclado auto listener = cocos2d :: EventListenerKeyboard :: create (); listener -> onKeyPressed = CC_CALLBACK_2 ( VirtualControls :: onKeyPressed , this ); Director :: getInstance () -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , node ); listener = cocos2d :: EventListenerKeyboard :: create (); listener -> onKeyReleased = CC_CALLBACK_2 ( VirtualControls :: onKeyReleased , this ); Director :: getInstance () -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , node ); Mostramos a continuaci\u00f3n el c\u00f3digo completo de la clase VirtualControls : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 // VirtualControls.h #define kNUM_BUTTONS 1 #define kNUM_AXIS 2 enum Button { BUTTON_ACTION = 0 , BUTTON_LEFT = 1 , BUTTON_RIGHT = 2 }; enum Axis { AXIS_HORIZONTAL = 0 , AXIS_VERTICAL = 1 }; class VirtualControls : public Ref { public : bool init (); virtual void preloadResources (){}; virtual Node * getNode (){ return NULL ;}; bool isButtonPressed ( Button button ); float getAxis ( Axis axis ); std :: function < void ( Button ) > onButtonPressed ; std :: function < void ( Button ) > onButtonReleased ; // Keyboard controls void onKeyPressed ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ); void onKeyReleased ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ); void addKeyboardListeners ( cocos2d :: Node * node ); CREATE_FUNC ( VirtualControls ); protected : bool buttonState [ kNUM_BUTTONS ]; float axisState [ kNUM_AXIS ]; }; // VirtualControls.cpp bool VirtualControls :: init (){ for ( int i = 0 ; i < kNUM_BUTTONS ; i ++ ) { buttonState [ i ] = false ; } for ( int i = 0 ; i < kNUM_AXIS ; i ++ ) { axisState [ i ] = 0.0f ; } return true ; } bool VirtualControls :: isButtonPressed ( Button button ) { return buttonState [ button ]; } float VirtualControls :: getAxis ( Axis axis ) { return clampf ( axisState [ axis ], - 1.0 , 1.0 ); } // Keyboard input support void VirtualControls :: addKeyboardListeners ( cocos2d :: Node * node ) { //Creo listeners del teclado auto listener = cocos2d :: EventListenerKeyboard :: create (); listener -> onKeyPressed = CC_CALLBACK_2 ( VirtualControls :: onKeyPressed , this ); Director :: getInstance () -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , node ); listener = cocos2d :: EventListenerKeyboard :: create (); listener -> onKeyReleased = CC_CALLBACK_2 ( VirtualControls :: onKeyReleased , this ); Director :: getInstance () -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , node ); } void VirtualControls :: onKeyPressed ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ){ if ( onButtonPressed ) { if ( keyCode == EventKeyboard :: KeyCode :: KEY_LEFT_ARROW ) { onButtonPressed ( Button :: BUTTON_LEFT ); axisState [ Axis :: AXIS_HORIZONTAL ] -= 1.0 ; } else if ( keyCode == EventKeyboard :: KeyCode :: KEY_RIGHT_ARROW ) { onButtonPressed ( Button :: BUTTON_RIGHT ); axisState [ Axis :: AXIS_HORIZONTAL ] += 1.0 ; } else if ( keyCode == EventKeyboard :: KeyCode :: KEY_SPACE ) { onButtonPressed ( Button :: BUTTON_ACTION ); } } } void VirtualControls :: onKeyReleased ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ){ if ( onButtonReleased ) { if ( keyCode == EventKeyboard :: KeyCode :: KEY_LEFT_ARROW ) { onButtonReleased ( Button :: BUTTON_LEFT ); axisState [ Axis :: AXIS_HORIZONTAL ] += 1.0 ; } else if ( keyCode == EventKeyboard :: KeyCode :: KEY_RIGHT_ARROW ) { onButtonReleased ( Button :: BUTTON_RIGHT ); axisState [ Axis :: AXIS_HORIZONTAL ] -= 1.0 ; } else if ( keyCode == EventKeyboard :: KeyCode :: KEY_SPACE ) { onButtonReleased ( Button :: BUTTON_ACTION ); } } } A continuaci\u00f3n veremos c\u00f3mo crear subclases de VirtualControls que nos permitan implementar formar alternativas de control, con un mando dibujado sobre pantalla. Adem\u00e1s de incorporar un mando virtual en pantalla, podremos aprovechar esta estructura de clases para implementar otros mecanismos de control alternativos como aceler\u00f3metro o mandos f\u00edsicos. Pad virtual \u00b6 El pad virtual consiste en dibujar la cruceta de control digital sobre la pantalla y mediante los eventos de la pantalla t\u00e1ctil detectar cu\u00e1ndo se pulsa sobre \u00e9l. Esta es la forma m\u00e1s sencilla de implementar un control virtual, y ser\u00e1 suficiente en el caso de juegos que s\u00f3lo requieran controles digitales. Aprovecharemos la clase VirtualControls introducida en el apartado anterior, y crearemos una subclase que lea la entrada a partir de un pad virtual en pantalla, y mapee dicha entrada sobre los eventos de control virtuales gen\u00e9ricos definidos en la VirtualControls (ejes horizontal y vertical y estado de los botones). 1 2 3 4 5 6 7 8 9 10 11 12 13 class VirtualPad : public VirtualControls { public : bool init (); void preloadResources (); Node * getNode (); CREATE_FUNC ( VirtualPad ); private : ... }; Crearemos los diferentes botones del pad virtual como sprites , los posicionaremos en pantalla, y programaremos los eventos necesarios para detectar cu\u00e1ndo pulsamos sobre ellos. Vamos a ver un ejemplo sencillo con tres botones, un pad direccional con botones para movernos a la izquierda y derecha, y un bot\u00f3n de acci\u00f3n: 1 2 3 4 5 private : cocos2d :: Sprite * m_buttonAction ; cocos2d :: Sprite * m_buttonLeft ; cocos2d :: Sprite * m_buttonRight ; ... Adem\u00e1s, a\u00f1adimos un listener para leer los eventos de la pantalla t\u00e1ctil que se produzcan sobre los controles anteriores: 1 2 3 private : ... cocos2d :: EventListenerTouchOneByOne * m_listener ; Vamos a pasar ahora a ver la implementaci\u00f3n de la clase VirtualPad . En primer lugar, podemos proporcionar un m\u00e9todo para cargar los recursos necesarios para dibujar el mando en pantalla. Podemos cargarlos desde un sprite sheet : 1 2 3 4 5 6 7 8 9 10 void VirtualPad :: preloadResources (){ //Cache de sprites auto spriteFrameCache = SpriteFrameCache :: getInstance (); //Si no estaba el spritesheet en la cach\u00e9 lo cargo if ( ! spriteFrameCache -> getSpriteFrameByName ( \"boton-direccion.png\" )) { spriteFrameCache -> addSpriteFramesWithFile ( \"mando.plist\" ); } } A continuaci\u00f3n vamos a ver c\u00f3mo crear la interfaz del pad virtual en pantalla, posicionando de forma correcta los gr\u00e1ficos que hemos cargado y a\u00f1adiendo los correspondiente listeners de pantalla t\u00e1ctil sobre ellos. Algo que debemos tener en cuenta al posicionar los controles es que \u00e9stos siempre deben quedar en la parte visible de la pantalla. Por ejemplo, al inicializar nuestro pad virtual podemos posicionar los botones de la siguiente forma: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Size visibleSize = Director :: getInstance () -> getVisibleSize (); Vec2 visibleOrigin = Director :: getInstance () -> getVisibleOrigin (); m_buttonLeft = Sprite :: createWithSpriteFrameName ( \"boton-direccion.png\" ); m_buttonLeft -> setAnchorPoint ( Vec2 ( 0 , 0 )); m_buttonLeft -> setPosition ( visibleOrigin . x + kPAD_MARGIN , visibleOrigin . y + kPAD_MARGIN ); m_buttonLeft -> setOpacity ( 127 ); m_buttonLeft -> setTag ( Button :: BUTTON_LEFT ); m_buttonRight = Sprite :: createWithSpriteFrameName ( \"boton-direccion.png\" ); m_buttonRight -> setAnchorPoint ( Vec2 ( 1 , 0 )); m_buttonRight -> setScaleX ( - 1 ); m_buttonRight -> setOpacity ( 127 ); m_buttonRight -> setPosition ( visibleOrigin . x + kPAD_MARGIN + m_buttonLeft -> getContentSize (). width + kPAD_MARGIN , visibleOrigin . y + kPAD_MARGIN ); m_buttonRight -> setTag ( Button :: BUTTON_RIGHT ); m_buttonAction = Sprite :: createWithSpriteFrameName ( \"boton-accion.png\" ); m_buttonAction -> setAnchorPoint ( Vec2 ( 1 , 0 )); m_buttonAction -> setPosition ( visibleOrigin . x + visibleSize . width - kPAD_MARGIN , visibleOrigin . y + kPAD_MARGIN ); m_buttonAction -> setOpacity ( 127 ); m_buttonAction -> setTag ( Button :: BUTTON_ACTION ); En este ejemplo vemos adem\u00e1s que hacemos los botones semitransparentes . Esta es una pr\u00e1ctica habitual, que har\u00e1 que los botones virtuales afecten menos al apartado visual de nuestro videojuego. Tambi\u00e9n podemos observar que hemos aprovechado la propiedad tag de los botones para identificarlos mediante los elementos de la enumeraci\u00f3n Button . Veremos que esto ser\u00e1 de especial inter\u00e9s cuando procesemos los eventos, para saber a qu\u00e9 bot\u00f3n virtual corresponde cada bot\u00f3n en pantalla. Una vez hemos creado los sprites de los botones los a\u00f1adiremos a la pantalla: 1 2 3 4 5 m_node = Node :: create (); m_node -> addChild ( m_buttonLeft , 0 ); m_node -> addChild ( m_buttonRight , 0 ); m_node -> addChild ( m_buttonAction , 0 ); m_node -> setLocalZOrder ( 100 ); Tras esto, debemos definir un listener de eventos t\u00e1ctiles para detectar cu\u00e1ndo pulsamos sobre ellos: 1 2 m_listener = EventListenerTouchOneByOne :: create (); m_listener -> setSwallowTouches ( true ); Aprovecharemos las funciones onButttonPressed y onButtonReleased definidas en la superclase VirtualControls para avisar al callback que tuviesen asignado (si hubiese alguno) de que un bot\u00f3n ha sido pulsado o liberado, y actualizaremos tambi\u00e9n el estado de los botones ( buttonState ). Empezamos detectando cuando comienza un contacto en pantalla. Si se ha pulsado sobre unos de los botones, lo marcaremos como pulsado y llamamos a los callbacks correspondientes (si no son NULL ): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 m_listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point locationInNode = target -> convertToNodeSpace ( touch -> getLocation ()); Size s = target -> getContentSize (); Rect rect = Rect ( 0 , 0 , s . width , s . height ); if ( rect . containsPoint ( locationInNode )) { buttonState [ target -> getTag ()] = true ; // Solo llama al callback si no es NULL if ( onButtonPressed ) { onButtonPressed (( PadButton ) target -> getTag ()); } target -> setOpacity ( 255 ); return true ; } return false ; }; En este caso target se refiere al bot\u00f3n sobre el que se ha definido el listener . Comprobamos si hemos pulsado sobre el \u00e1rea del bot\u00f3n ( target ) y en tal caso anotamos que dicho bot\u00f3n est\u00e1 pulsado y avisamos al callback correspondiente, en caso de que se haya asignado uno. De forma similar podemos programar el evento de finalizaci\u00f3n del contacto, y en ese caso marcamos el bot\u00f3n como no pulsado y llamamos al callback correspondiente: 1 2 3 4 5 6 7 8 9 10 m_listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); target -> setOpacity ( 127 ); buttonState [ target -> getTag ()] = false ; // Solo llama al callback si no es NULL if ( onButtonReleased ) { onButtonReleased (( PadButton ) target -> getTag ()); } }; Obtenemos el bot\u00f3n ( target ) sobre el que se ha definido el listener y anotamos que el bot\u00f3n ya no est\u00e1 pulsado, adem\u00e1s de llamar al callback correspondiente en caso de estar asignado. Por \u00faltimo, a\u00f1adiremos el listener sobre cada uno de los botones. Podemos observar que hay una instancia del listener para cada bot\u00f3n, con lo que en cada uno de ellos el target ser\u00e1 un \u00fanico bot\u00f3n concreto: 1 2 3 m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( m_listener , m_buttonLeft ); m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( m_listener -> clone (), m_buttonRight ); m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( m_listener -> clone (), m_buttonAction ); Mostramos a continuaci\u00f3n el c\u00f3digo completo de esta implementaci\u00f3n sencilla de un pad virtual: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 // VirtualPad.h #define kPAD_MARGIN 20 class VirtualPad : public VirtualControls { public : bool init (); void preloadResources (); Node * getNode (); CREATE_FUNC ( VirtualPad ); private : cocos2d :: Sprite * m_buttonAction ; cocos2d :: Sprite * m_buttonLeft ; cocos2d :: Sprite * m_buttonRight ; cocos2d :: EventListenerTouchOneByOne * m_listener ; }; // VirtualPad.cpp bool VirtualPad :: init (){ VirtualControls :: init (); return true ; } void VirtualPad :: preloadResources (){ //Cache de sprites auto spriteFrameCache = SpriteFrameCache :: getInstance (); //Si no estaba el spritesheet en la cach\u00e9 lo cargo if ( ! spriteFrameCache -> getSpriteFrameByName ( \"boton-direccion.png\" )) { spriteFrameCache -> addSpriteFramesWithFile ( \"mando.plist\" ); } } Node * VirtualPad :: getNode (){ if ( m_node == NULL ) { Size visibleSize = Director :: getInstance () -> getVisibleSize (); Vec2 visibleOrigin = Director :: getInstance () -> getVisibleOrigin (); m_buttonLeft = Sprite :: createWithSpriteFrameName ( \"boton-direccion.png\" ); m_buttonLeft -> setAnchorPoint ( Vec2 ( 0 , 0 )); m_buttonLeft -> setPosition ( visibleOrigin . x + kPAD_MARGIN , visibleOrigin . y + kPAD_MARGIN ); m_buttonLeft -> setOpacity ( 127 ); m_buttonLeft -> setTag ( Button :: BUTTON_LEFT ); m_buttonRight = Sprite :: createWithSpriteFrameName ( \"boton-direccion.png\" ); m_buttonRight -> setAnchorPoint ( Vec2 ( 1 , 0 )); m_buttonRight -> setScaleX ( - 1 ); m_buttonRight -> setOpacity ( 127 ); m_buttonRight -> setPosition ( visibleOrigin . x + kPAD_MARGIN + m_buttonLeft -> getContentSize (). width + kPAD_MARGIN , visibleOrigin . y + kPAD_MARGIN ); m_buttonRight -> setTag ( Button :: BUTTON_RIGHT ); m_buttonAction = Sprite :: createWithSpriteFrameName ( \"boton-accion.png\" ); m_buttonAction -> setAnchorPoint ( Vec2 ( 1 , 0 )); m_buttonAction -> setPosition ( visibleOrigin . x + visibleSize . width - kPAD_MARGIN , visibleOrigin . y + kPAD_MARGIN ); m_buttonAction -> setOpacity ( 127 ); m_buttonAction -> setTag ( Button :: BUTTON_ACTION ); m_node = Node :: create (); m_node -> addChild ( m_buttonLeft , 0 ); m_node -> addChild ( m_buttonRight , 0 ); m_node -> addChild ( m_buttonAction , 0 ); m_node -> setLocalZOrder ( 100 ); m_listener = EventListenerTouchOneByOne :: create (); m_listener -> setSwallowTouches ( true ); m_listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point locationInNode = target -> convertToNodeSpace ( touch -> getLocation ()); Size s = target -> getContentSize (); Rect rect = Rect ( 0 , 0 , s . width , s . height ); if ( rect . containsPoint ( locationInNode )) { buttonState [ target -> getTag ()] = true ; if ( onButtonPressed ) { onButtonPressed (( Button ) target -> getTag ()); } target -> setOpacity ( 255 ); return true ; } return false ; }; m_listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); target -> setOpacity ( 127 ); buttonState [ target -> getTag ()] = false ; if ( onButtonReleased ) { onButtonReleased (( Button ) target -> getTag ()); } }; m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( m_listener , m_buttonLeft ); m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( m_listener -> clone (), m_buttonRight ); m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( m_listener -> clone (), m_buttonAction ); } return m_node ; } Stick virtual \u00b6 El stick virtual emula el stick anal\u00f3gico de un mando. Podremos pulsar sobre \u00e9l y arrastrar para as\u00ed graduar cu\u00e1nto queremos moverlo en una determinada direcci\u00f3n. En el caso del pad por ejemplo la direcci\u00f3n izquierda puede estar pulsada o no estarlo. En el stick podemos moverlo m\u00e1s o menos a la izquierda. Podremos leer el estado del stick anal\u00f3gico a partir del valor de sus ejes vertical y horizontal, que tomar\u00e1n valores reales entre -1 y 1 . Para crear el aspecto visual de nuestro stick anal\u00f3gico utilizaremos dos sprites , uno para la base, que no se mover\u00e1 nunca, y otro para la \"palanca\", que se desplazar\u00e1 conforme la arrastremos: 1 2 3 private : cocos2d :: Sprite * m_stickLeft ; cocos2d :: Sprite * m_stickLeftBase ; Adem\u00e1s, para facilitar la gesti\u00f3n del stick almacenaremos su posici\u00f3n central y el radio en el que puede moverse: 1 2 3 4 5 private : ... cocos2d :: Size m_radioStick ; cocos2d :: Point m_centerStick ; Una vez definidas estas propiedades de la clase de nuestro stick vamos a pasar a implementar el c\u00f3digo. Inicializaremos los sprites que componen el stick de la siguiente forma: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Size visibleSize = Director :: getInstance () -> getVisibleSize (); Vec2 visibleOrigin = Director :: getInstance () -> getVisibleOrigin (); m_stickLeftBase = Sprite :: createWithSpriteFrameName ( \"base-stick.png\" ); m_stickLeftBase -> setAnchorPoint ( Vec2 ( 0 , 0 )); m_stickLeftBase -> setPosition ( visibleOrigin . x + kSTICK_MARGIN , visibleOrigin . y + kSTICK_MARGIN ); m_stickLeftBase -> setOpacity ( 127 ); m_stickLeft = Sprite :: createWithSpriteFrameName ( \"bola-stick.png\" ); m_stickLeft -> setAnchorPoint ( Vec2 ( 0.5 , 0.5 )); m_stickLeft -> setOpacity ( 127 ); m_radioStick = m_stickLeftBase -> getContentSize () * 0.5 - m_stickLeft -> getContentSize () * 0.5 ; m_centerStick = m_stickLeftBase -> getPosition () + m_stickLeftBase -> getContentSize () * 0.5 ; m_stickLeft -> setPosition ( m_centerStick ); Como podemos ver, posicionamos en primer lugar la base del stick en la esquina inferior-izquierda de la pantalla, haci\u00e9ndola semiopaca. Tras esto, creamos la palanca y la posicionamos justo en el centro de la base. Definimos m_centerStick como la posici\u00f3n central de la base de la palanca, y m_radioStick como el radio en el que la palanca podr\u00e1 moverse. Este radio se obtiene a partir de la media anchura y altura de la base, rest\u00e1ndole la media anchura y altura de la palanca, para que as\u00ed esta \u00faltima quede siempre dentro de la base al desplazarla. Una vez creado y configurado el stick , lo a\u00f1adimos a la pantalla: 1 2 3 4 m_node = Node :: create (); m_node -> addChild ( m_stickLeftBase , 0 ); m_node -> addChild ( m_stickLeft , 1 ); m_node -> setLocalZOrder ( 100 ); A continuaci\u00f3n, definiremos un listener de eventos t\u00e1ctiles para controlar el stick : 1 2 EventListenerTouchOneByOne * listener = EventListenerTouchOneByOne :: create (); listener -> setSwallowTouches ( true ); En el evento del comienzo del contacto comprobaremos si estamos tocando dentro de la palanca, y en tal caso devolveremos true para seguir procesando el gesto. En caso contrario, devolvemos false para ignorar los siguientes eventos de movimiento de dicho contacto. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point locationInNode = target -> convertToNodeSpace ( touch -> getLocation ()); Size s = target -> getContentSize (); Rect rect = Rect ( 0 , 0 , s . width , s . height ); if ( rect . containsPoint ( locationInNode )) { target -> setOpacity ( 255 ); return true ; } return false ; }; El evento m\u00e1s importante ser\u00e1 el de movimiento del contacto: 1 2 3 4 5 6 7 8 9 10 11 12 13 listener -> onTouchMoved = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point offset = touch -> getLocation () - touch -> getStartLocation (); Point max ( m_radioStick ); Point min ( Point :: ZERO - m_radioStick ); offset . clamp ( min , max ); axisState [ Axis :: AXIS_VERTICAL ] = offset . y / max . y ; axisState [ Axis :: AXIS_HORIZONTAL ] = offset . x / max . x ; target -> setPosition ( m_centerStick + offset ); }; En este caso calculamos el desplazamiento ( offset ) de la posici\u00f3n a la que hemos movido el dedo respecto a la posici\u00f3n del contacto que inici\u00f3 el gesto ( getStartLocation() ). En funci\u00f3n de dicho desplazamiento calculamos el valor de cada uno de los ejes, no permitiendo que se salga nunca del radio permitido (esto lo hacemos con la funci\u00f3n clamp , para hacer que offset nunca pueda ser mayor que la posici\u00f3n m\u00e1xima ni menor que la m\u00ednima). Por \u00faltimo, en el evento de finalizaci\u00f3n del gesto volveremos a poner ambos ejes en la posici\u00f3n central (0,0): 1 2 3 4 5 6 7 8 listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); target -> setOpacity ( 127 ); target -> setPosition ( m_centerStick ); axisState [ Axis :: AXIS_VERTICAL ] = 0 ; axisState [ Axis :: AXIS_HORIZONTAL ] = 0 ; }; A\u00f1adiremos el listener al gestor de eventos: 1 m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , m_stickLeft ); Para terminar incluimos el c\u00f3digo completo de la clase que implementa el stick anal\u00f3gico y un bot\u00f3n digital: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 // VirtualStick.h #define kSTICK_MARGIN 20 class VirtualStick : public VirtualControls { public : bool init (); void preloadResources (); Node * getNode (); CREATE_FUNC ( VirtualStick ); private : cocos2d :: Sprite * m_buttonAction ; cocos2d :: Sprite * m_stickLeft ; cocos2d :: Sprite * m_stickLeftBase ; cocos2d :: Size m_radioStick ; cocos2d :: Point m_centerStick ; }; // VirtualStick.cpp bool VirtualStick :: init (){ VirtualControls :: init (); return true ; } void VirtualStick :: preloadResources (){ //Cache de sprites auto spriteFrameCache = SpriteFrameCache :: getInstance (); //Si no estaba el spritesheet en la cach\u00e9 lo cargo if ( ! spriteFrameCache -> getSpriteFrameByName ( \"boton-direccion.png\" )) { spriteFrameCache -> addSpriteFramesWithFile ( \"mando.plist\" ); } } Node * VirtualStick :: getNode (){ if ( m_node == NULL ) { Size visibleSize = Director :: getInstance () -> getVisibleSize (); Vec2 visibleOrigin = Director :: getInstance () -> getVisibleOrigin (); m_stickLeftBase = Sprite :: createWithSpriteFrameName ( \"base-stick.png\" ); m_stickLeftBase -> setAnchorPoint ( Vec2 ( 0 , 0 )); m_stickLeftBase -> setPosition ( visibleOrigin . x + kSTICK_MARGIN , visibleOrigin . y + kSTICK_MARGIN ); m_stickLeftBase -> setOpacity ( 127 ); m_stickLeft = Sprite :: createWithSpriteFrameName ( \"bola-stick.png\" ); m_stickLeft -> setAnchorPoint ( Vec2 ( 0.5 , 0.5 )); m_stickLeft -> setOpacity ( 127 ); m_radioStick = m_stickLeftBase -> getContentSize () * 0.5 - m_stickLeft -> getContentSize () * 0.5 ; m_centerStick = m_stickLeftBase -> getPosition () + m_stickLeftBase -> getContentSize () * 0.5 ; m_stickLeft -> setPosition ( m_centerStick ); m_buttonAction = Sprite :: createWithSpriteFrameName ( \"boton-accion.png\" ); m_buttonAction -> setAnchorPoint ( Vec2 ( 1 , 0 )); m_buttonAction -> setPosition ( visibleOrigin . x + visibleSize . width - kSTICK_MARGIN , visibleOrigin . y + kSTICK_MARGIN ); m_buttonAction -> setOpacity ( 127 ); m_buttonAction -> setTag ( Button :: BUTTON_ACTION ); m_node = Node :: create (); m_node -> addChild ( m_stickLeftBase , 0 ); m_node -> addChild ( m_stickLeft , 1 ); m_node -> addChild ( m_buttonAction , 0 ); m_node -> setLocalZOrder ( 100 ); EventListenerTouchOneByOne * listener = EventListenerTouchOneByOne :: create (); listener -> setSwallowTouches ( true ); listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point locationInNode = target -> convertToNodeSpace ( touch -> getLocation ()); Size s = target -> getContentSize (); Rect rect = Rect ( 0 , 0 , s . width , s . height ); if ( rect . containsPoint ( locationInNode )) { buttonState [ target -> getTag ()] = true ; if ( onButtonPressed ) { onButtonPressed (( Button ) target -> getTag ()); } target -> setOpacity ( 255 ); return true ; } return false ; }; listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); target -> setOpacity ( 127 ); buttonState [ target -> getTag ()] = false ; if ( onButtonReleased ) { onButtonReleased (( Button ) target -> getTag ()); } }; m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , m_buttonAction ); // Listener stick listener = EventListenerTouchOneByOne :: create (); listener -> setSwallowTouches ( true ); listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point locationInNode = target -> convertToNodeSpace ( touch -> getLocation ()); Size s = target -> getContentSize (); Rect rect = Rect ( 0 , 0 , s . width , s . height ); if ( rect . containsPoint ( locationInNode )) { target -> setOpacity ( 255 ); return true ; } return false ; }; listener -> onTouchMoved = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point offset = touch -> getLocation () - touch -> getStartLocation (); Point max ( m_radioStick ); Point min ( Point :: ZERO - m_radioStick ); offset . clamp ( min , max ); axisState [ Axis :: AXIS_VERTICAL ] = offset . y / max . y ; axisState [ Axis :: AXIS_HORIZONTAL ] = offset . x / max . x ; target -> setPosition ( m_centerStick + offset ); }; listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); target -> setOpacity ( 127 ); target -> setPosition ( m_centerStick ); axisState [ Axis :: AXIS_VERTICAL ] = 0 ; axisState [ Axis :: AXIS_HORIZONTAL ] = 0 ; }; m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , m_stickLeft ); } return m_node ; } Stick virtual con posicionamiento autom\u00e1tico \u00b6 El stick virtual tiene el problema de no tener feedback f\u00edsico, por lo que si tenemos la atenci\u00f3n centrada en la escena del juego es posible que no sepamos si estamos tocando en el centro del mando o no, al intentar hacer un moviemiento. Para evitar esto podemos hacer que al tocar sobre la pantalla el stick se sit\u00fae autom\u00e1ticamente centrado en la posici\u00f3n donde hemos tocado. As\u00ed sabremos que siempre tocamos en el centro, y s\u00f3lo tendremos que arrastrar. Una posible estrategia para implementar este tipo de sticks es dividir el tama\u00f1o de la pantalla en dos: el lado izquierdo dedicado al stick anal\u00f3gico, y el lado derecho a los botones de acci\u00f3n. Al pulsar en cualquier lugar del lado izquierdo crearemos un stick anal\u00f3gico en dicha posici\u00f3n, y al arrastrar moveremos sus ejes. Al pulsar en el lado derecho realizaremos una acci\u00f3n (por ejemplo saltar). Deberemos crear una variante adecuada para nuestro tipo de juego. Crearemos los sprites necesarios para el stick anal\u00f3gico autoposicionado de forma similar al caso anterior, pero con la diferencia de que en este caso los haremos invisibles y no les daremos ninguna posici\u00f3n inicial: 1 2 3 4 5 6 7 8 9 10 11 12 Size visibleSize = Director :: getInstance () -> getVisibleSize (); Vec2 visibleOrigin = Director :: getInstance () -> getVisibleOrigin (); m_stickLeftBase = Sprite :: createWithSpriteFrameName ( \"base-stick.png\" ); m_stickLeftBase -> setAnchorPoint ( Vec2 ( 0.5 , 0.5 )); m_stickLeftBase -> setVisible ( false ); m_stickLeft = Sprite :: createWithSpriteFrameName ( \"bola-stick.png\" ); m_stickLeft -> setAnchorPoint ( Vec2 ( 0.5 , 0.5 )); m_stickLeft -> setVisible ( false ); m_radioStick = m_stickLeftBase -> getContentSize () * 0.5 - m_stickLeft -> getContentSize () * 0.5 ; Los a\u00f1adimos a la pantalla: 1 2 3 4 m_node = Node :: create (); m_node -> addChild ( m_stickLeftBase , 0 ); m_node -> addChild ( m_stickLeft , 1 ); m_node -> setLocalZOrder ( 100 ); Y creamos un listener para los eventos de la pantalla t\u00e1ctil: 1 2 EventListenerTouchOneByOne * listener = EventListenerTouchOneByOne :: create (); listener -> setSwallowTouches ( true ); Donde si que introduciremos notables diferencias es en los eventos del listener . En primer lugar, onTouchBegan comprobar\u00e1 si tocamos en la mitad izquierda de la pantalla, y en tal caso har\u00e1 aparecer el stick en la posici\u00f3n donde hemos tocado y devolver\u00e1 true para seguir procesando el gesto. En caso contrario devuelve false para ignorar los siguientes eventos de movimento de dicho gesto (en tal caso se deja que lo procese el listener encargado de los botones de acci\u00f3n a la derecha): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); m_centerStick = target -> convertToNodeSpace ( touch -> getLocation ()); Size winSize = Director :: getInstance () -> getWinSize (); if ( m_centerStick . x < winSize . width / 2 ) { m_stickLeftBase -> setPosition ( m_centerStick ); m_stickLeftBase -> setVisible ( true ); m_stickLeft -> setPosition ( m_centerStick ); m_stickLeft -> setVisible ( true ); return true ; } else { return false ; } }; Destacamos que en este caso utilizamos tambi\u00e9n la propiedad m_centerStick , pero no le damos una posici\u00f3n fija en la actualizaci\u00f3n, sino que la modificamos cada vez que comenzamos un nuevo gesto t\u00e1ctil en onTouchBegan . En segundo lugar, onTouchMoved se comporar\u00e1 igual que en el caso del stick con posici\u00f3n fija: 1 2 3 4 5 6 7 8 9 10 11 12 listener -> onTouchMoved = [ = ]( Touch * touch , Event * event ) { Point offset = touch -> getLocation () - touch -> getStartLocation (); Point max ( m_radioStick ); Point min ( Point :: ZERO - m_radioStick ); offset . clamp ( min , max ); axisState [ Axis :: AXIS_VERTICAL ] = offset . y / max . y ; axisState [ Axis :: AXIS_HORIZONTAL ] = offset . x / max . x ; m_stickLeft -> setPosition ( m_centerStick + offset ); }; Por \u00faltimo, onTouchEnded tiene como diferencia que en este caso volveremos a ocultar el stick : 1 2 3 4 5 6 7 listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ) { m_stickLeftBase -> setVisible ( false ); m_stickLeft -> setVisible ( false ); axisState [ Axis :: AXIS_VERTICAL ] = 0 ; axisState [ Axis :: AXIS_HORIZONTAL ] = 0 ; }; A continuaci\u00f3n incluimos el c\u00f3digo completo de las clases que incorporan el stick anal\u00f3gico con posicionamiento autom\u00e1tico, combinado con un bot\u00f3n de acci\u00f3n en la parte derecha: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 // VirtualStickAuto.h #define kAUTOSTICK_MARGIN 20 class VirtualStickAuto : public VirtualControls { public : bool init (); void preloadResources (); Node * getNode (); CREATE_FUNC ( VirtualStickAuto ); private : cocos2d :: Sprite * m_buttonAction ; cocos2d :: Sprite * m_stickLeft ; cocos2d :: Sprite * m_stickLeftBase ; cocos2d :: Size m_radioStick ; cocos2d :: Point m_centerStick ; }; // VirtualStickAuto.cpp bool VirtualStickAuto :: init (){ VirtualControls :: init (); return true ; } void VirtualStickAuto :: preloadResources (){ //Cache de sprites auto spriteFrameCache = SpriteFrameCache :: getInstance (); //Si no estaba el spritesheet en la cach\u00e9 lo cargo if ( ! spriteFrameCache -> getSpriteFrameByName ( \"boton-direccion.png\" )) { spriteFrameCache -> addSpriteFramesWithFile ( \"mando.plist\" ); } } Node * VirtualStickAuto :: getNode (){ if ( m_node == NULL ) { Size visibleSize = Director :: getInstance () -> getVisibleSize (); Vec2 visibleOrigin = Director :: getInstance () -> getVisibleOrigin (); m_stickLeftBase = Sprite :: createWithSpriteFrameName ( \"base-stick.png\" ); m_stickLeftBase -> setAnchorPoint ( Vec2 ( 0.5 , 0.5 )); m_stickLeftBase -> setVisible ( false ); m_stickLeft = Sprite :: createWithSpriteFrameName ( \"bola-stick.png\" ); m_stickLeft -> setAnchorPoint ( Vec2 ( 0.5 , 0.5 )); m_stickLeft -> setVisible ( false ); m_radioStick = m_stickLeftBase -> getContentSize () * 0.5 - m_stickLeft -> getContentSize () * 0.5 ; m_buttonAction = Sprite :: createWithSpriteFrameName ( \"boton-accion.png\" ); m_buttonAction -> setAnchorPoint ( Vec2 ( 1 , 0 )); m_buttonAction -> setOpacity ( 127 ); m_buttonAction -> setPosition ( visibleOrigin . x + visibleSize . width - kAUTOSTICK_MARGIN , visibleOrigin . y + kAUTOSTICK_MARGIN ); m_buttonAction -> setTag ( Button :: BUTTON_ACTION ); m_node = Node :: create (); m_node -> addChild ( m_stickLeftBase , 0 ); m_node -> addChild ( m_stickLeft , 1 ); m_node -> addChild ( m_buttonAction , 0 ); m_node -> setLocalZOrder ( 100 ); EventListenerTouchOneByOne * listener = EventListenerTouchOneByOne :: create (); listener -> setSwallowTouches ( true ); listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point locationInNode = target -> convertToNodeSpace ( touch -> getLocation ()); Size s = target -> getContentSize (); Rect rect = Rect ( 0 , 0 , s . width , s . height ); if ( rect . containsPoint ( locationInNode )) { buttonState [ target -> getTag ()] = true ; if ( onButtonPressed ) { onButtonPressed (( Button ) target -> getTag ()); } target -> setOpacity ( 255 ); return true ; } return false ; }; listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); target -> setOpacity ( 127 ); buttonState [ target -> getTag ()] = false ; if ( onButtonReleased ) { onButtonReleased (( Button ) target -> getTag ()); } }; m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , m_buttonAction ); // Listener stick listener = EventListenerTouchOneByOne :: create (); listener -> setSwallowTouches ( true ); listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); m_centerStick = target -> convertToNodeSpace ( touch -> getLocation ()); Size winSize = Director :: getInstance () -> getWinSize (); if ( m_centerStick . x < winSize . width / 2 ) { m_stickLeftBase -> setPosition ( m_centerStick ); m_stickLeftBase -> setVisible ( true ); m_stickLeft -> setPosition ( m_centerStick ); m_stickLeft -> setVisible ( true ); return true ; } else { return false ; } }; listener -> onTouchMoved = [ = ]( Touch * touch , Event * event ) { Point offset = touch -> getLocation () - touch -> getStartLocation (); Point max ( m_radioStick ); Point min ( Point :: ZERO - m_radioStick ); offset . clamp ( min , max ); axisState [ Axis :: AXIS_VERTICAL ] = offset . y / max . y ; axisState [ Axis :: AXIS_HORIZONTAL ] = offset . x / max . x ; m_stickLeft -> setPosition ( m_centerStick + offset ); }; listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ) { m_stickLeftBase -> setVisible ( false ); m_stickLeft -> setVisible ( false ); axisState [ Axis :: AXIS_VERTICAL ] = 0 ; axisState [ Axis :: AXIS_HORIZONTAL ] = 0 ; }; m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , m_node ); } return m_node ; } Es importante remarcar que con esta implementaci\u00f3n de controles virtuales podremos reemplazar un tipo de control por otro sin afectar al c\u00f3digo de nuestro juego, que siempre utilizar\u00e1 VirtualControls . Simplemente cambiando la subclase concreta que instanciamos podremos alternar entre diferentes formas de control. Mandos f\u00edsicos \u00b6 Vamos a ver en esta secci\u00f3n diferentes tipos de mandos hardware que podremos integrar en nuestros videojuegos. Tipos de mandos f\u00edsicos \u00b6 Controladores oficiales iOS La especificaci\u00f3n de mandos para dispositivos iOS aparece a partir de iOS 7. En dicha versi\u00f3n del SDK se incorpora el framework GameController que nos permitir\u00e1 a\u00f1adir soporte para este tipo de mandos, que llevan la etiqueta MFI ( Made for iPhone/iPod/iPad ), la cual se refiere a todos los dispositivos hardware dise\u00f1ados para estos dispositivos iOS. https://developer.apple.com/library/ios/documentation/ServicesDiscovery/Conceptual/GameControllerPG/Introduction/Introduction.html Controladores oficiales Android El soporte para controladores de juego en Android est\u00e1 presente a partir de la API 9, aunque se han ido incorporando mejoras en APIs sucesivas. http://developer.android.com/training/game-controllers/index.html Encontramos en Android diferentes mandos que soportan el est\u00e1ndar definido en esta plataforma. Tambi\u00e9n tenemos mandos que nos proporcionan su SDK espec\u00edfico para que podamos optimizar su integraci\u00f3n en nuestro juego, como por ejemplo los mandos de OUYA TV, Moga y Nibiru. Controladores iCade Estos controladores no utilizan la API oficial, ya que salieron a la venta antes de que \u00e9sta existiese. Se comportan como un teclado bluetooth , por lo que para utilizarlos simplemente deberemos conocer a qu\u00e9 tecla est\u00e1 mapeado cada bot\u00f3n. Est\u00e1 dise\u00f1ado para ser utilizado con el iPad, pero puede utilizarse en cualquier dispositivo m\u00f3vil que lo reconozca como teclado bluetooth . En los siguientes enlaces se puede encontrar documentaci\u00f3n para integrar estos controladores en nuestras aplicaciones: http://www.ionaudio.com/downloads/ION%20Arcade%20Dev%20Resource%20v1.5.pdf http://www.raywenderlich.com/8618/adding-icade-support-to-your-game Controladores f\u00edsicos en Cocos2d-x \u00b6 Cocos2d-x soporta tanto los mandos oficiales de Android como los oficiales de iOS, ofreci\u00e9ndonos una API \u00fanica para utilizarlos en cualquiera de estas plataformas. Vamos a centrarnos en la API com\u00fan de Cocos2d-x y en las cuestiones espec\u00edficas para utilizarla en Android e iOS. Eventos del mando En Cocos2d-x encontramos el listener EventListenerController que nos permite incorporar soporte para mandos f\u00edsicos de forma sencilla. Este listener nos permite recibir los siguientes eventos: onConnected : Se ha conectado un mando. onDisconnected : Se ha desconectado un mando. onKeyDown : Se ha pulsado un bot\u00f3n del mando. onKeyUp : Se ha soltado un bot\u00f3n del mando. onKeyRepeat : Se mantiene pulsado un bot\u00f3n. onAxisEvent : Notifica cambios en el stick anal\u00f3gico. A continuaci\u00f3n vemos el esqueleto de la clase de una escena de nuestro juego en la que utilizamos como entrada el mando. Al iniciar la escena registraremos el listener de eventos del mando y configuraremos los callbacks necesarios para cada uno de los eventos anteriores: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 bool MiEscena :: init () { if ( ! Layer :: init () ) { return false ; } configuraMandos (); return true ; } void MiEscena :: configurarMando () { _listener = EventListenerController :: create (); // Registramos callbacks _listener -> onConnected = CC_CALLBACK_2 ( MiEscena :: onConnectController , this ); _listener -> onDisconnected = CC_CALLBACK_2 ( MiEscena :: onDisconnectedController , this ); _listener -> onKeyDown = CC_CALLBACK_3 ( MiEscena :: onKeyDown , this ); _listener -> onKeyUp = CC_CALLBACK_3 ( MiEscena :: onKeyUp , this ); _listener -> onAxisEvent = CC_CALLBACK_3 ( MiEscena :: onAxisEvent , this ); // A\u00f1adimos el listener el mando al gestor de eventos _eventDispatcher -> addEventListenerWithSceneGraphPriority ( _listener , this ); // Inicia b\u00fasqueda de controladores (necesario en iOS) Controller :: startDiscoveryController (); } void MiEscena :: onKeyDown ( cocos2d :: Controller * controller , int keyCode , cocos2d :: Event * event ) { } void MiEscena :: onKeyUp ( cocos2d :: Controller * controller , int keyCode , cocos2d :: Event * event ) { } void MiEscena :: onAxisEvent ( cocos2d :: Controller * controller , int keyCode , cocos2d :: Event * event ) { } void MiEscena :: onConnectController ( Controller * controller , Event * event ) { } void MiEscena :: onDisconnectedController ( Controller * controller , Event * event ) { } A continuaci\u00f3n veremos con m\u00e1s detalle estos eventos. Conexi\u00f3n y desconexi\u00f3n del mando Los mandos se conectar\u00e1n de forma inal\u00e1mbrica al m\u00f3vil, por lo que deberemos poder conectar nuevos mandos, o desconectar los que tenemos conectados. Podemos estar al tanto de los eventos de conexi\u00f3n y desconexi\u00f3n de mandos. A partir del par\u00e1metros Controller que nos proporcionan estos eventos podremos saber adem\u00e1s datos sobre el mando que se ha conectado: 1 2 3 4 5 6 7 8 9 void MiEscena :: onConnectController ( Controller * controller , Event * event ) { CCLOG ( \"Tag:%d\" , controller -> getTag ()); CCLOG ( \"Id:%d\" , controller -> getDeviceId ()); CCLOG ( \"Nombre:%s\" , controller -> getDeviceName (). c_str ()); } void MiEscena :: onDisconnectedController ( Controller * controller , Event * event ) { } Como vemos, una propiedad de los controladores es su etiqueta ( tag ). Podemos poner una etiqueta a los mandos para poder acceder a ellos de forma sencilla con setTag y consultarla con getTag . Esta etiqueta ser\u00e1 un n\u00famero entero. Por ejemplo, podr\u00edamos utilizar las etiquetas 1 y 2 para identificar los mandos para el primer y segundo jugador respectivamente. Podremos localizar uno de estos mandos de forma inmediata con el m\u00e9todo est\u00e1tico Controller::getControllerByTag . 1 Controller * primerJugador = Controller :: getControllerByTag ( 1 ); Pulsaci\u00f3n de teclas A partir de un objeto Controller podremos conocer el estado de sus botones con el m\u00e9todo getKeyStatus . Este m\u00e9todo recibe como par\u00e1metro el c\u00f3digo del bot\u00f3n que queremos consultar. En la siguiente imagen mostramos los grupos de botones que encontramos en los mandos para m\u00f3viles: Los c\u00f3digos para los botones de cada grupo se encuentran en la enumeraci\u00f3n Key y son: Anal\u00f3gico izquierdo: JOYSTICK_LEFT_X , JOYSTICK_LEFT_Y , BUTTON_LEFT_THUMBSTICK Anal\u00f3gico derecho: JOYSTICK_RIGHT_X , JOYSTICK_RIGHT_Y , BUTTON_RIGHT_THUMBSTICK Pad digital: BUTTON_DPAD_UP , BUTTON_DPAD_DOWN , BUTTON_DPAD_LEFT , BUTTON_DPAD_RIGHT , BUTTON_DPAD_CENTER Botones frontales: BUTTON_A , BUTTON_B , BUTTON_C , BUTTON_X , BUTTON_Y , BUTTON_Z , BUTTON_START , BUTTON_SELECT , BUTTON_PAUSE Gatillos: AXIS_LEFT_TRIGGER , AXIS_RIGHT_TRIGGER Botones superiores: BUTTON_LEFT_SHOULDER , BUTTON_RIGHT_SHOULDER Por ejemplo, si queremos consultar el estado del bot\u00f3n A en el mando del primer jugador haremos lo siguiente: 1 KeyStatus estado = primerJugador -> getKeyStatus ( BUTTON_A ); El estado es una estructura que nos da la siguiente informaci\u00f3n: isPressed : Booleano que nos indica si est\u00e1 presionado el bot\u00f3n (para el caso de botones digitales). isAnalog : Nos indica si el bot\u00f3n es anal\u00f3gico ( sticks anal\u00f3gicos o gatillos). value : Nos indica el valor del estado del bot\u00f3n como n\u00famero flotante. Depender\u00e1 del tipo de bot\u00f3n. Por ejemplo en caso de sticks anal\u00f3gicos nos dar\u00e1 un valor entre -1 y 1 . En caso de gatillos ser\u00e1 entre 0 y 1 . En otros botones nos puede dar valores concretos como 0 \u00f3 1 . Por ejemplo, podemos hacer que al pulsar el bot\u00f3n A nuestro personaje dispare y que con el stick izquierdo se mueva horizontalmente: 1 2 3 4 5 6 7 KeyStatus estadoA = primerJugador -> getKeyStatus ( BUTTON_A ); if ( estado . isPressed ) { player -> dispara (); } KeyStatus estadoHorizontal = primerJugador -> getKeyStatus ( JOYSTICK_LEFT_X ); player -> setVelocity ( estadoHorizontal . value ); Configuraci\u00f3n de mandos para Android Cocos2d-x en Android soporta los mandos est\u00e1ndar para videojuegos, y tambi\u00e9n contiene optimizaciones para tipos concretos de mando como son los de tipo Ouya TV, Moga y Nibiru. Deberemos hacer algunos cambios en el proyecto Android para soportar cualquier tipo de mando hardware . En primer lugar, deberemos a\u00f1adir al proyecto de Android Studio las librer\u00edas de apoyo para la gesti\u00f3n de mandos de videojuegos. Para ello, cambiaremos en el fichero settings.gradle la referencia al m\u00f3dulo libcocos2dx por libcocos2dx-with-controller , que incluye las librer\u00edas y clases de apoyo necesarias: 1 2 include ' :libcocos2dx ' project ( ' :libcocos2dx ' ) . projectDir = new File ( settingsDir , ' ../cocos2d/cocos/platform/android/libcocos2dx-with-controller ' ) Una vez a\u00f1adida la librer\u00eda, a\u00f1adiremos los siguientes cambios a la actividad AppActivity : Haremos que la actividad herede de GameControllerActivity . En caso de querer utilizar internamente los SDK espec\u00edficos para determinados tipos de mandos y optimizar la adaptaci\u00f3n a ellos, deberemos especificarlo de forma expl\u00edcita en onCreate : 1 2 3 this . connectController ( DRIVERTYPE_NIBIRU ); this . connectController ( DRIVERTYPE_MOGA ); this . connectController ( DRIVERTYPE_OUYA ); Por ejemplo, para dar soporte espec\u00edfico a controladores de tipo OUYA tendr\u00edamos: 1 2 3 4 5 6 7 public class AppActivity extends GameControllerActivity { @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); this . connectController ( DRIVERTYPE_OUYA ); } } Tambi\u00e9n ser\u00e1 necesario que en nuestro dispositivo Android descarguemos los drivers para el controlador que vayamos a utilizar y lo conectemos al dispositivo. Configuraci\u00f3n de mandos para iOS En el caso de iOS, para que nuestro proyecto soporte los mandos oficiales aparecidos a partir de iOS 7, tendremos que a\u00f1adir el framework GameController.Framework a nuestro proyecto. Adem\u00e1s, ser\u00e1 importante que en nuestro proyecto llamemos a Controller::startDiscoveryController() para que inicie la b\u00fasqueda de mandos y establezca una conexi\u00f3n con ellos, tal como hemos indicado anteriormente.","title":"Controles del videojuego"},{"location":"mandos.html#controles-del-videojuego","text":"La principal forma de control del m\u00f3vil es la pantalla t\u00e1ctil, por lo que los videojuegos dise\u00f1ados espec\u00edficamente para m\u00f3viles normalmente se adaptan a esta forma de entrada. Encontramos tambi\u00e9n algunos juegos dise\u00f1ados para ser manejados mediante el aceler\u00f3metro. Sin embargo, cuando se quiere trasladar a m\u00f3vil un juego dise\u00f1ado originalmente para otro sistema en el que contamos con teclado, rat\u00f3n o joystick deberemos adaptar su forma de manejo, ya que en la mayor\u00eda de casos no contamos con dichos mecanismos de entrada en m\u00f3viles. Vamos a ver los diferentes mecanismos de entrada que podemos utilizar en los videojuegos para m\u00f3viles, y una serie de buenas pr\u00e1cticas a la hora de implementar el control de estos videojuegos.","title":"Controles del videojuego"},{"location":"mandos.html#teclado-en-cocos2d-x","text":"Cocos2d-x soporta eventos de teclado, pero \u00e9stos no funcionan en plataformas m\u00f3viles. Aunque nuestro proyecto est\u00e9 orientado exclusivamente a estas plataformas, si el control de nuestro juego se realiza mediante mando es recomendable que implementemos tambi\u00e9n la posibilidad de controlarlo mediante teclado. Esto ser\u00e1 de gran utilidad durante el desarrollo, ya que no existe forma de emular un mando, y la forma m\u00e1s parecida al mando para manejar nuestro juego en las pruebas que hagamos durante el desarrollo es el control mediante teclado. Para leer los eventos de teclado desde Cocos2d-x podemos utilizar la clase EventListenerKeyboard como se muestra a continuaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 bool MiEscena :: init () { if ( ! Layer :: init () ) { return false ; } configuraTeclado (); return true ; } void MiEscena :: configurarTeclado () { _listener = EventListenerKeyboard :: create (); // Registramos callbacks _listener -> onKeyPressed = CC_CALLBACK_2 ( MiEscena :: onConnectController , this ); _listener -> onReleased = CC_CALLBACK_2 ( MiEscena :: onDisconnectedController , this ); // A\u00f1adimos el listener el mando al gestor de eventos _eventDispatcher -> addEventListenerWithSceneGraphPriority ( _listener , this ); } void MiEscena :: onKeyDown ( EventKeyboard :: KeyCode code , Event * event ) { } void MiEscena :: onKeyUp ( EventKeyboard :: KeyCode code , Event * event ) { } Por ejemplo, para reconocer los controles izquierda-derecha mediante las teclas A-D podr\u00edamos escribir los m\u00e9todos onKeyDown y onKeyUp como se muestra a continuaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void MiEscena :: onKeyDown ( EventKeyboard :: KeyCode code , Event * event ) { switch ( keyCode ){ case EventKeyboard :: KeyCode :: KEY_A : _izquierdaPulsado = true ; break ; case EventKeyboard :: KeyCode :: KEY_D : _derechaPulsado = true ; break ; } } void MiEscena :: onKeyUp ( EventKeyboard :: KeyCode code , Event * event ) { switch ( keyCode ){ case EventKeyboard :: KeyCode :: KEY_A : _izquierdaPulsado = false ; break ; case EventKeyboard :: KeyCode :: KEY_D : _derechaPulsado = false ; break ; } }","title":"Teclado en Cocos2d-x"},{"location":"mandos.html#pantalla-tactil","text":"Como hemos comentado, es el mecanismo m\u00e1s habitual de entrada en los videojuegos para m\u00f3viles. En muchos tipos de videojuegos esta es la forma de control m\u00e1s natural. Por ejemplo, tenemos puzzles en los que tenemos que interactuar con diferentes elementos del escenario tocando sobre ellos. Tambi\u00e9n en el g\u00e9nero tower defense resulta natural posicionar nuestras diferentes unidades tocando sobre la pantalla, o de forma m\u00e1s amplia en el g\u00e9nero de la estrategia interactuar con nuestros recursos y unidades pulsando sobre ellos. La pantalla t\u00e1ctil tiene ciertas similitudes con el control mediante rat\u00f3n, pudiendo trasladar muchos juegos que originalmente se controlaban mediante rat\u00f3n a dispositivos t\u00e1ctiles. Sin embargo, debemos tener en cuenta algunas diferencias importantes. Los juegos en los que el rat\u00f3n se utiliza para el control de la c\u00e1mara y para apuntar desliz\u00e1ndolo (como es el caso fundamentalmente de los First Person Shooters ), encontraremos una p\u00e9rdida al pasarlos a la pantalla t\u00e1ctil, y no ser\u00e1 trivial implementarlo de forma correcta. Sin embargo, aquellos en los que se utilice para seleccionar elementos mediante el puntero ganar\u00e1n con la pantalla t\u00e1ctil, ya que ser\u00e1 m\u00e1s r\u00e1pido pulsar sobre estos elementos con el dedo que tener que deslizar el puntero del rat\u00f3n. Adem\u00e1s, tenemos que tener en cuenta una ventaja muy importante de la pantalla t\u00e1ctil sobre el rat\u00f3n: es multit\u00e1ctil. Esto quiere decir que podemos tener al mismo tiempo varios contactos en pantalla, cosa que con el rat\u00f3n no es posible. Esto nos da un gran abanico de posibilidades a la hora de implementar el control en nuestros videojuegos.","title":"Pantalla t\u00e1ctil"},{"location":"mandos.html#pantalla-tactil-en-cocos2d-x","text":"Vamos a ver la forma de implementar este mecanismo de control en Cocos2d-x. Para la detecci\u00f3n de eventos de la pantalla t\u00e1ctil crearemos un listener de tipo EventListenerTouch : Encontramos dos variantes: EventListenerTouchOneByOne : Procesa los eventos de la pantalla t\u00e1ctil de uno en uno. Cada vez que se reciba un evento ser\u00e1 sobre un \u00fanico contacto ( Touch ). Es m\u00e1s sencillo de implementar, y resultar\u00e1 adecuado para aquellos juegos en los que no necesitemos detectar m\u00e1s de un contacto al mismo tiempo. EventListenerTouchAllAtOnce : En este caso podremos recibir en cada evento informaci\u00f3n de varios contactos (recibiremos una lista de objetos Touch ). Ser\u00e1 m\u00e1s complicado de gestionar, pero nos permitir\u00e1 implementar juegos que hagan uso de la pantalla multit\u00e1ctil. Una vez seleccionado el listener que m\u00e1s nos interese para nuestro videojuego, lo inicializaremos de la siguiente forma: 1 auto listener = EventListenerTouchOneByOne :: create ();","title":"Pantalla t\u00e1ctil en Cocos2d-x"},{"location":"mandos.html#eventos-de-la-pantalla-tactil-en-cocos2d-x","text":"Hablaremos de un gesto t\u00e1ctil para referirnos a la secuencia que consiste en tocar sobre la pantalla, deslizar el dedo, y levantarlo de la pantalla. Durante el gesto se producir\u00e1n tres tipos de eventos: onTouchBegan : Evento de comienzo de un gesto. En este evento podemos decidir si queremos procesar el resto del gesto o no. En caso de no estar interesados en este gesto ya no recibiremos ning\u00fan evento m\u00e1s del mismo (ni de movimiento ni de finalizaci\u00f3n). onTouchMoved : Evento de continuaci\u00f3n del gesto. Mientras desplacemos el contacto por la pantalla recibiremos eventos de movimiento con sus nuevas coordenadas. onTouchEnded : Evento de finalizaci\u00f3n del gesto. Al levantar el dedo de la pantalla el gesto finalizar\u00e1. Podemos indicar callbacks para estos eventos mediante funciones lambda , o utilizandos la macro CC_CALLBACK_2 . Comenzamos con el evento de comienzo del gesto. La funci\u00f3n callback deber\u00e1 devolver un booleano indicando si estamos interesados en el gesto o no. Por ejemplo, podemos considerar que nos interesa el gesto si hemos pulsado sobre un determinado sprite , y que no nos interesa en caso contrario. 1 2 3 4 5 6 7 listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ){ if ( estaSobreSprite ( touch )) { return true ; } else { return false ; } }; De forma similar definiremos los eventos de movimiento y finalizaci\u00f3n, aunque en estos casos no deberemos devolver ning\u00fan valor: 1 2 3 4 5 6 7 listener -> onTouchMoved = [ = ]( Touch * touch , Event * event ){ ... }; listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ){ ... };","title":"Eventos de la pantalla t\u00e1ctil en Cocos2d-x"},{"location":"mandos.html#prioridad-de-los-eventos","text":"Una vez definidos los eventos, a\u00f1adimos el listener a la escena: 1 m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , m_sprite ); En este caso m_node ser\u00eda el nodo principal que contiene nuestra escena, y m_sprite el nodo que queremos que act\u00fae como objetivo ( target ) de nuestro listener . Podemos a\u00f1adir el listener con dos sistemas de prioridad distintos: Prioridad de grafo de la escena : La prioridad en la que se ejecutan los diferentes listeners viene determinada por el orden de los nodos en el grafo de la escena. El nodo que pasamos como target al a\u00f1adir el listener ser\u00e1 el que determine dicha prioridad. Se ejecutar\u00e1n antes los eventos definidos sobre nodos que queden delante de otros en la pantalla (es decir, primero aquellos que tengan mayor Z). Prioridad fija : En este caso la prioridad se especifica mediante un valor fijo al a\u00f1adir el listener .","title":"Prioridad de los eventos"},{"location":"mandos.html#consumo-de-eventos","text":"Al crear un listener podemos indicar que consuma los eventos: 1 listener -> setSwallowTouches ( true ); Si hacemos esto, en caso de que nuestro listener devuelva true en onTouchBegan consumir\u00e1 el evento y \u00e9ste no pasar\u00e1 a otros listeners de menor prioridad. En caso contrario, el evento se propagar\u00e1 al siguiente listener","title":"Consumo de eventos"},{"location":"mandos.html#nodo-objetivo-del-listener","text":"Hemos visto que al utilizar prioridad basada en el grafo de la escena cada listener tiene un nodo objetivo. Podemos aprovechar esto para utilizar dicho nodo como nodo sobre el que estamos interesados en pulsar: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point locationInNode = target -> convertToNodeSpace ( touch -> getLocation ()); Size s = target -> getContentSize (); Rect rect = Rect ( 0 , 0 , s . width , s . height ); if ( rect . containsPoint ( locationInNode )) { return true ; } else { return false ; } }; Con Event::getCurrentTarget podemos obtener el nodo que act\u00faa de target . Podemos convertir las coordenadas globales del touch a coordenadas locales del nodo target , y en caso de estar dentro del \u00e1rea que ocupa dicho nodo entonces devolvemos true para seguir procesando eventos de este gesto. De esta forma podemos hacer por ejemplo que al pulsar sobre nuestro sprite podamos arrastrarlo por la pantalla, mientras que si pulsamos fuera este listener no har\u00e1 nada.","title":"Nodo objetivo del listener"},{"location":"mandos.html#pantalla-multitactil","text":"Cocos2d-x soporta pantalla multit\u00e1ctil, pero por defecto se encuentra deshabilitada en iOS. Para habilitar el soporte para recibir varios contactos simult\u00e1neos en esta plataforma, deberemos abrir el fichero AppController.mm y localizar la siguiente l\u00ednea: 1 [ eaglView setMultipleTouchEnabled : NO ]; La modificaremos de forma que si que est\u00e9 habilitado el soporte para m\u00faltiples contactos: 1 [ eaglView setMultipleTouchEnabled : YES ]; En Android no ser\u00e1 necesario que hagamos nada, el soporte para pantalla multit\u00e1ctil est\u00e1 habilitado por defecto.","title":"Pantalla multit\u00e1ctil"},{"location":"mandos.html#acelerometro","text":"Encontramos tambi\u00e9n algunos juegos en los que el mecanismo de control m\u00e1s natural es el uso del aceler\u00f3metro. Por ejemplo juegos que cambian la gravedad en la escena seg\u00fan la inclinaci\u00f3n del m\u00f3vil, como es el caso de los juegos en los que manejamos una bola a trav\u00e9s de un laberinto, o juegos de conducci\u00f3n en los que la inclinaci\u00f3n del m\u00f3vil hace de volante. En Cocos2d-x implementaremos soporte para el aceler\u00f3metro mediante un listener de tipo EventListenerAcceleration . Para que este listener funcione, en primer lugar deberemos activar el uso del aceler\u00f3metro: 1 Device :: setAccelerometerEnabled ( true ); Una vez hecho esto, creamos el listener especificando directamente un callback mediante una funci\u00f3n lambda : 1 2 3 auto listener = EventListenerAcceleration :: create ([ = ]( Acceleration * acc , Event * event ) { ... } Tambi\u00e9n podemos utilizar la macro CC_CALLBACK_2 : 1 auto listener = EventListenerAcceleration :: create ( CC_CALLBACK_2 ( Game :: onAcceleration , this )); 1 2 3 4 void Game :: onAcceleration ( Acceleration * acc , Event * event ) { ... } Por \u00faltimo, a\u00f1adiremos el listener al gestor de eventos de la escena: 1 m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , m_node ); Es importante tener en cuenta que en los juegos que se manejen mediante aceler\u00f3metro, al no ser necesario tocar la pantalla, no debemos permitir que esta se apague de forma autom\u00e1tica por inactividad. Esto no se puede hacer directamente con Cocos2d-x, sino que tendremos que especificarlo de forma nativa para cada plataforma.","title":"Aceler\u00f3metro"},{"location":"mandos.html#mandos","text":"Los juegos dise\u00f1ados para videoconsolas o m\u00e1quinas recreativas se manejan normalmente mediante joystick o pad . Al portar uno de estos juegos a m\u00f3vil podemos optar por: Adaptar el control de videojuego a pantalla t\u00e1ctil. Esto implica grandes cambios en el dise\u00f1o del juego y en el gameplay y no siempre es posible hacerlo. A\u00f1adir un pad virtual en pantalla. Permite mantener el mismo mecanismo de control que el juego original, pero resulta m\u00e1s complicado de manejar que con un mando real. A\u00f1adir soporte para mandos f\u00edsicos. Nos permitir\u00e1 trasladar la misma experiencia de juego que la versi\u00f3n de videoconsola/recreativa pero necesita que el usuario cuente con este dispositivo. Se pierde una de las ventajas de los juegos m\u00f3viles, que es el llevarlos siempre con nosotros. Vamos ahora a centrarnos en este tipo de juegos y en la forma de dise\u00f1ar un control adecuado para ellos. Veremos tanto la forma de incorporar un pad virtual como la forma de a\u00f1adir soporte para diferentes tipos de mandos f\u00edsicos. Dentro de estos mandos encontramos tanto mandos soportados por las APIs oficiales de iOS y Android, como mandos con APIs de terceros, como por ejemplo iCade.","title":"Mandos"},{"location":"mandos.html#buenas-practicas-para-juegos-basados-en-control-pad","text":"Si queremos implementar un juego cuyo manejo est\u00e9 basado en control pad , ser\u00e1 recomendable seguir las siguientes pr\u00e1cticas: Permitir el manejo del juego mediante pad virtual en pantalla si no se dispone de mando real. A\u00f1adir compatibilidad con mandos reales. Se recomienda a\u00f1adir soporte para las APIs oficiales y para aquellos mandos m\u00e1s utilizados, como iCade. En caso de tener conectado un mando real, ocultar el pad virtual para que no moleste en pantalla. Respetaremos la funci\u00f3n est\u00e1ndar de cada bot\u00f3n. El bot\u00f3n de pausa del mando debe permitir pausar el juego en cualquier momento. Determinados botones se suelen utilizar para realizar las mismas acciones en todos los juegos (saltos, ataque, acci\u00f3n, etc). Deberemos intentar seguir estas convenciones. La pantalla del m\u00f3vil no debe apagarse mientras utilizamos el juego con el mando externo.","title":"Buenas pr\u00e1cticas para juegos basados en control pad"},{"location":"mandos.html#mandos-virtuales","text":"Cuando la mecanica de nuestro juego exige que se controles mediante un mando tradicional, y no contamos con ning\u00fan mando hardware que podamos utilizar, la \u00fanica soluci\u00f3n ser\u00e1 introducir en nuestro juego un mando virtual en pantalla. Vamos a ver diferentes tipos de mandos que podemos implementar en pantalla, emulando controles tanto digitales como anal\u00f3gicos.","title":"Mandos virtuales"},{"location":"mandos.html#controles-virtuales","text":"Antes de implementar un mecanismo de control concreto, es conveniente generar una estructura de clases que haga de fachada y nos permita implementar el control del videojuego de forma gen\u00e9rica, sin hacer referencia expresa al teclado, mandos f\u00edsicos, o mandos virtuales. En esta secci\u00f3n proponemos un sistema de control virtual basado en herencia. Implementaremos una clase VirtualControls que nos dar\u00e1 la informaci\u00f3n necesaria para leer los controles que necesite nuestro videojuego. Por ejemplo, si necesitamos un joystick anal\u00f3gico con dos ejes (horizontal y vertical) y tres botones digitales, nuestra clase nos dar\u00e1 informaci\u00f3n sobre estos controles virtuales, sin determinar qu\u00e9 mecanismo concreto se utiliza para implementarlos. Esto ser\u00e1 responsabilidad de las subclases de VirtualControls , que ser\u00e1n las que implementen el mapeo entre un mecanismo de control concreto y los controles virtuales definidos en VirtualControls . De esta forma, simplemente cambiando la subclase de VirtualControls que instanciamos podremos cambiar la forma de controlar el videojuego. Vamos a ver un ejemplo de implementaci\u00f3n de sistema gen\u00e9rico de control. En primer lugar definiremos los botones y ejes virtuales que necesitamos reconocer en el videojuego: 1 2 3 4 5 6 7 8 9 10 11 12 13 #define kNUM_BUTTONS 3 #define kNUM_AXIS 2 enum Button { BUTTON_ACTION = 0 , BUTTON_LEFT = 1 , BUTTON_RIGHT = 2 }; enum Axis { AXIS_HORIZONTAL = 0 , AXIS_VERTICAL = 1 }; En este caso hemos definido tres botones (acci\u00f3n, izquierda y derecha), y dos ejes (horizontal y vertical), aunque podr\u00edamos adaptar esto a las necesidades de cada juego. Indicamos mediante constantes el n\u00famero de botones y ejes, e identificamos cada uno mediante elementos mediante enumeraciones. Los botones tendr\u00e1n como estado un booleano (pulsado o no pulsado), mientras que los ejes tendr\u00e1n como valor un valor de tipo float entre -1 y 1 (palanca totalmente inclinada en un sentido o en el contrario), y valdr\u00e1 0 si est\u00e1 en reposo. Mostramos a continuaci\u00f3n la estructura completa que podr\u00eda tener la clase que implemente el control virtual : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class VirtualControls : public Ref { public : bool init (); virtual void preloadResources (){}; virtual Node * getNode () { return NULL ;}; bool isButtonPressed ( Button button ); float getAxis ( Axis axis ); std :: function < void ( Button ) > onButtonPressed ; std :: function < void ( Button ) > onButtonReleased ; // Keyboard controls void onKeyPressed ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ); void onKeyReleased ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ); void addKeyboardListeners ( cocos2d :: Node * node ); CREATE_FUNC ( VirtualControls ); protected : bool buttonState [ kNUM_BUTTONS ]; float axisState [ kNUM_AXIS ]; }; Como vemos, la clase controla el estado de los botones (pulsados o sin pulsar) y el de los ejes, que oscilar\u00e1 entre -1 (totalmente a la izquierda) y 1 (totalmente a la derecha). Deberemos poder leer el estado de estos controles virtuales en cualquier momento. Para ello hemos incorporado las propiedades buttonState y axisState , en las que almacenamos este estado, y proporcionamos los m\u00e9todos isButtonPressed y getAxis para consultarlos. Definimos tambi\u00e9n los eventos onButtonPressed y onButtonReleased para los cuales podremos definir callbacks . De esta forma podremos tener constancia de que un bot\u00f3n ha sido pulsado o soltado, sin tener que comprobar continuamente su estado. Adem\u00e1s, incluimos la posibilidad de devolver un nodo (m\u00e9todo getNode ) que nos permita pintar controles virtuales en pantalla (de momento estar\u00e1 vac\u00edo), y tambi\u00e9n un m\u00e9todo para cargar los recursos necesarios para pintar estos controles ( preloadResources ). Estos m\u00e9todos se definir\u00e1n en las subclases de VirtualControls . Vamos a ver a continuaci\u00f3n c\u00f3mo implementar cada m\u00e9todo de esta clase. En primer lugar, el m\u00e9todo para su inicializaci\u00f3n ( init ) simplemente establecer\u00e1 el estado de los botones a \"no pulsado\" ( false ) y los ejes en reposo ( 0 ): 1 2 3 4 5 6 7 8 9 10 11 bool VirtualControls :: init (){ for ( int i = 0 ; i < kNUM_BUTTONS ; i ++ ) { buttonState [ i ] = false ; } for ( int i = 0 ; i < kNUM_AXIS ; i ++ ) { axisState [ i ] = 0.0f ; } return true ; } Tambi\u00e9n ser\u00e1 necesario definir los m\u00e9todos para poder leer el estado de los controles (botones y ejes): 1 2 3 4 5 6 7 bool VirtualControls :: isButtonPressed ( Button button ) { return buttonState [ button ]; } float VirtualControls :: getAxis ( Axis axis ) { return clampf ( axisState [ axis ], - 1.0 , 1.0 ); } De momento s\u00f3lo hemos definido en esta clase los controles que se utilizar\u00e1n en el juego y lo m\u00e9todos para consultarlos, pero de momento no se ha establecido la forma de darles valor a estos controles. Esto es algo que deber\u00e1 implementar cada subclase concreta. Sin embargo, para depuraci\u00f3n puede ser conveniente poder activar al control por teclado. Vamos a hacer que la clase base implemente controles de teclado para depuraci\u00f3n. En primer lugar actualizamos la definici\u00f3n de la clase VirtualControls . A\u00f1adimos a ella los callbacks necesarios para recibir los controles de teclado, y un m\u00e9todo para activar el control por teclado en nuestro juego ( addKeyboardListeners ): 1 2 3 4 5 6 7 8 9 10 11 12 class VirtualControls : public Ref { public : ... // Keyboard controls void onKeyPressed ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ); void onKeyReleased ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ); void addKeyboardListeners ( cocos2d :: Node * node ); ... }; A continuaci\u00f3n, en la implementaci\u00f3n de la clase introducimos el c\u00f3digo de los callbacks de los eventos de teclado: las teclas Cursor Izquierda y Cursor Derecha modificar\u00e1n el valor del eje horizontal (al mismo tiempo que el estado de los botones BUTTON_LEFT y BUTTON_RIGHT ), y la tecla espacio modificar\u00e1 el estado del bot\u00f3n BUTTON_ACTION : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 void VirtualControls :: onKeyPressed ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ){ if ( onButtonPressed ) { if ( keyCode == EventKeyboard :: KeyCode :: KEY_LEFT_ARROW ) { onButtonPressed ( Button :: BUTTON_LEFT ); axisState [ Axis :: AXIS_HORIZONTAL ] -= 1.0 ; } else if ( keyCode == EventKeyboard :: KeyCode :: KEY_RIGHT_ARROW ) { onButtonPressed ( Button :: BUTTON_RIGHT ); axisState [ Axis :: AXIS_HORIZONTAL ] += 1.0 ; } else if ( keyCode == EventKeyboard :: KeyCode :: KEY_SPACE ) { onButtonPressed ( Button :: BUTTON_ACTION ); } } } void VirtualControls :: onKeyReleased ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ){ if ( onButtonReleased ) { if ( keyCode == EventKeyboard :: KeyCode :: KEY_LEFT_ARROW ) { onButtonReleased ( Button :: BUTTON_LEFT ); axisState [ Axis :: AXIS_HORIZONTAL ] += 1.0 ; } else if ( keyCode == EventKeyboard :: KeyCode :: KEY_RIGHT_ARROW ) { onButtonReleased ( Button :: BUTTON_RIGHT ); axisState [ Axis :: AXIS_HORIZONTAL ] -= 1.0 ; } else if ( keyCode == EventKeyboard :: KeyCode :: KEY_SPACE ) { onButtonReleased ( Button :: BUTTON_ACTION ); } } } De esta forma mapeamos la lectura del teclado sobre nuestro sistema de control virtual. Debemos a\u00f1adir tambi\u00e9n un m\u00e9todo que cree el listener necesario para escuchar los eventos de teclado, y programarlo para que avise a los callbacks definidos anteriormente. Esto lo podemos hacer de la siguiente forma: 1 2 3 4 5 6 7 8 9 10 11 void VirtualControls :: addKeyboardListeners ( cocos2d :: Node * node ) { //Creo listeners del teclado auto listener = cocos2d :: EventListenerKeyboard :: create (); listener -> onKeyPressed = CC_CALLBACK_2 ( VirtualControls :: onKeyPressed , this ); Director :: getInstance () -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , node ); listener = cocos2d :: EventListenerKeyboard :: create (); listener -> onKeyReleased = CC_CALLBACK_2 ( VirtualControls :: onKeyReleased , this ); Director :: getInstance () -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , node ); Mostramos a continuaci\u00f3n el c\u00f3digo completo de la clase VirtualControls : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 // VirtualControls.h #define kNUM_BUTTONS 1 #define kNUM_AXIS 2 enum Button { BUTTON_ACTION = 0 , BUTTON_LEFT = 1 , BUTTON_RIGHT = 2 }; enum Axis { AXIS_HORIZONTAL = 0 , AXIS_VERTICAL = 1 }; class VirtualControls : public Ref { public : bool init (); virtual void preloadResources (){}; virtual Node * getNode (){ return NULL ;}; bool isButtonPressed ( Button button ); float getAxis ( Axis axis ); std :: function < void ( Button ) > onButtonPressed ; std :: function < void ( Button ) > onButtonReleased ; // Keyboard controls void onKeyPressed ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ); void onKeyReleased ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ); void addKeyboardListeners ( cocos2d :: Node * node ); CREATE_FUNC ( VirtualControls ); protected : bool buttonState [ kNUM_BUTTONS ]; float axisState [ kNUM_AXIS ]; }; // VirtualControls.cpp bool VirtualControls :: init (){ for ( int i = 0 ; i < kNUM_BUTTONS ; i ++ ) { buttonState [ i ] = false ; } for ( int i = 0 ; i < kNUM_AXIS ; i ++ ) { axisState [ i ] = 0.0f ; } return true ; } bool VirtualControls :: isButtonPressed ( Button button ) { return buttonState [ button ]; } float VirtualControls :: getAxis ( Axis axis ) { return clampf ( axisState [ axis ], - 1.0 , 1.0 ); } // Keyboard input support void VirtualControls :: addKeyboardListeners ( cocos2d :: Node * node ) { //Creo listeners del teclado auto listener = cocos2d :: EventListenerKeyboard :: create (); listener -> onKeyPressed = CC_CALLBACK_2 ( VirtualControls :: onKeyPressed , this ); Director :: getInstance () -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , node ); listener = cocos2d :: EventListenerKeyboard :: create (); listener -> onKeyReleased = CC_CALLBACK_2 ( VirtualControls :: onKeyReleased , this ); Director :: getInstance () -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , node ); } void VirtualControls :: onKeyPressed ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ){ if ( onButtonPressed ) { if ( keyCode == EventKeyboard :: KeyCode :: KEY_LEFT_ARROW ) { onButtonPressed ( Button :: BUTTON_LEFT ); axisState [ Axis :: AXIS_HORIZONTAL ] -= 1.0 ; } else if ( keyCode == EventKeyboard :: KeyCode :: KEY_RIGHT_ARROW ) { onButtonPressed ( Button :: BUTTON_RIGHT ); axisState [ Axis :: AXIS_HORIZONTAL ] += 1.0 ; } else if ( keyCode == EventKeyboard :: KeyCode :: KEY_SPACE ) { onButtonPressed ( Button :: BUTTON_ACTION ); } } } void VirtualControls :: onKeyReleased ( EventKeyboard :: KeyCode keyCode , cocos2d :: Event * event ){ if ( onButtonReleased ) { if ( keyCode == EventKeyboard :: KeyCode :: KEY_LEFT_ARROW ) { onButtonReleased ( Button :: BUTTON_LEFT ); axisState [ Axis :: AXIS_HORIZONTAL ] += 1.0 ; } else if ( keyCode == EventKeyboard :: KeyCode :: KEY_RIGHT_ARROW ) { onButtonReleased ( Button :: BUTTON_RIGHT ); axisState [ Axis :: AXIS_HORIZONTAL ] -= 1.0 ; } else if ( keyCode == EventKeyboard :: KeyCode :: KEY_SPACE ) { onButtonReleased ( Button :: BUTTON_ACTION ); } } } A continuaci\u00f3n veremos c\u00f3mo crear subclases de VirtualControls que nos permitan implementar formar alternativas de control, con un mando dibujado sobre pantalla. Adem\u00e1s de incorporar un mando virtual en pantalla, podremos aprovechar esta estructura de clases para implementar otros mecanismos de control alternativos como aceler\u00f3metro o mandos f\u00edsicos.","title":"Controles virtuales"},{"location":"mandos.html#pad-virtual","text":"El pad virtual consiste en dibujar la cruceta de control digital sobre la pantalla y mediante los eventos de la pantalla t\u00e1ctil detectar cu\u00e1ndo se pulsa sobre \u00e9l. Esta es la forma m\u00e1s sencilla de implementar un control virtual, y ser\u00e1 suficiente en el caso de juegos que s\u00f3lo requieran controles digitales. Aprovecharemos la clase VirtualControls introducida en el apartado anterior, y crearemos una subclase que lea la entrada a partir de un pad virtual en pantalla, y mapee dicha entrada sobre los eventos de control virtuales gen\u00e9ricos definidos en la VirtualControls (ejes horizontal y vertical y estado de los botones). 1 2 3 4 5 6 7 8 9 10 11 12 13 class VirtualPad : public VirtualControls { public : bool init (); void preloadResources (); Node * getNode (); CREATE_FUNC ( VirtualPad ); private : ... }; Crearemos los diferentes botones del pad virtual como sprites , los posicionaremos en pantalla, y programaremos los eventos necesarios para detectar cu\u00e1ndo pulsamos sobre ellos. Vamos a ver un ejemplo sencillo con tres botones, un pad direccional con botones para movernos a la izquierda y derecha, y un bot\u00f3n de acci\u00f3n: 1 2 3 4 5 private : cocos2d :: Sprite * m_buttonAction ; cocos2d :: Sprite * m_buttonLeft ; cocos2d :: Sprite * m_buttonRight ; ... Adem\u00e1s, a\u00f1adimos un listener para leer los eventos de la pantalla t\u00e1ctil que se produzcan sobre los controles anteriores: 1 2 3 private : ... cocos2d :: EventListenerTouchOneByOne * m_listener ; Vamos a pasar ahora a ver la implementaci\u00f3n de la clase VirtualPad . En primer lugar, podemos proporcionar un m\u00e9todo para cargar los recursos necesarios para dibujar el mando en pantalla. Podemos cargarlos desde un sprite sheet : 1 2 3 4 5 6 7 8 9 10 void VirtualPad :: preloadResources (){ //Cache de sprites auto spriteFrameCache = SpriteFrameCache :: getInstance (); //Si no estaba el spritesheet en la cach\u00e9 lo cargo if ( ! spriteFrameCache -> getSpriteFrameByName ( \"boton-direccion.png\" )) { spriteFrameCache -> addSpriteFramesWithFile ( \"mando.plist\" ); } } A continuaci\u00f3n vamos a ver c\u00f3mo crear la interfaz del pad virtual en pantalla, posicionando de forma correcta los gr\u00e1ficos que hemos cargado y a\u00f1adiendo los correspondiente listeners de pantalla t\u00e1ctil sobre ellos. Algo que debemos tener en cuenta al posicionar los controles es que \u00e9stos siempre deben quedar en la parte visible de la pantalla. Por ejemplo, al inicializar nuestro pad virtual podemos posicionar los botones de la siguiente forma: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Size visibleSize = Director :: getInstance () -> getVisibleSize (); Vec2 visibleOrigin = Director :: getInstance () -> getVisibleOrigin (); m_buttonLeft = Sprite :: createWithSpriteFrameName ( \"boton-direccion.png\" ); m_buttonLeft -> setAnchorPoint ( Vec2 ( 0 , 0 )); m_buttonLeft -> setPosition ( visibleOrigin . x + kPAD_MARGIN , visibleOrigin . y + kPAD_MARGIN ); m_buttonLeft -> setOpacity ( 127 ); m_buttonLeft -> setTag ( Button :: BUTTON_LEFT ); m_buttonRight = Sprite :: createWithSpriteFrameName ( \"boton-direccion.png\" ); m_buttonRight -> setAnchorPoint ( Vec2 ( 1 , 0 )); m_buttonRight -> setScaleX ( - 1 ); m_buttonRight -> setOpacity ( 127 ); m_buttonRight -> setPosition ( visibleOrigin . x + kPAD_MARGIN + m_buttonLeft -> getContentSize (). width + kPAD_MARGIN , visibleOrigin . y + kPAD_MARGIN ); m_buttonRight -> setTag ( Button :: BUTTON_RIGHT ); m_buttonAction = Sprite :: createWithSpriteFrameName ( \"boton-accion.png\" ); m_buttonAction -> setAnchorPoint ( Vec2 ( 1 , 0 )); m_buttonAction -> setPosition ( visibleOrigin . x + visibleSize . width - kPAD_MARGIN , visibleOrigin . y + kPAD_MARGIN ); m_buttonAction -> setOpacity ( 127 ); m_buttonAction -> setTag ( Button :: BUTTON_ACTION ); En este ejemplo vemos adem\u00e1s que hacemos los botones semitransparentes . Esta es una pr\u00e1ctica habitual, que har\u00e1 que los botones virtuales afecten menos al apartado visual de nuestro videojuego. Tambi\u00e9n podemos observar que hemos aprovechado la propiedad tag de los botones para identificarlos mediante los elementos de la enumeraci\u00f3n Button . Veremos que esto ser\u00e1 de especial inter\u00e9s cuando procesemos los eventos, para saber a qu\u00e9 bot\u00f3n virtual corresponde cada bot\u00f3n en pantalla. Una vez hemos creado los sprites de los botones los a\u00f1adiremos a la pantalla: 1 2 3 4 5 m_node = Node :: create (); m_node -> addChild ( m_buttonLeft , 0 ); m_node -> addChild ( m_buttonRight , 0 ); m_node -> addChild ( m_buttonAction , 0 ); m_node -> setLocalZOrder ( 100 ); Tras esto, debemos definir un listener de eventos t\u00e1ctiles para detectar cu\u00e1ndo pulsamos sobre ellos: 1 2 m_listener = EventListenerTouchOneByOne :: create (); m_listener -> setSwallowTouches ( true ); Aprovecharemos las funciones onButttonPressed y onButtonReleased definidas en la superclase VirtualControls para avisar al callback que tuviesen asignado (si hubiese alguno) de que un bot\u00f3n ha sido pulsado o liberado, y actualizaremos tambi\u00e9n el estado de los botones ( buttonState ). Empezamos detectando cuando comienza un contacto en pantalla. Si se ha pulsado sobre unos de los botones, lo marcaremos como pulsado y llamamos a los callbacks correspondientes (si no son NULL ): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 m_listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point locationInNode = target -> convertToNodeSpace ( touch -> getLocation ()); Size s = target -> getContentSize (); Rect rect = Rect ( 0 , 0 , s . width , s . height ); if ( rect . containsPoint ( locationInNode )) { buttonState [ target -> getTag ()] = true ; // Solo llama al callback si no es NULL if ( onButtonPressed ) { onButtonPressed (( PadButton ) target -> getTag ()); } target -> setOpacity ( 255 ); return true ; } return false ; }; En este caso target se refiere al bot\u00f3n sobre el que se ha definido el listener . Comprobamos si hemos pulsado sobre el \u00e1rea del bot\u00f3n ( target ) y en tal caso anotamos que dicho bot\u00f3n est\u00e1 pulsado y avisamos al callback correspondiente, en caso de que se haya asignado uno. De forma similar podemos programar el evento de finalizaci\u00f3n del contacto, y en ese caso marcamos el bot\u00f3n como no pulsado y llamamos al callback correspondiente: 1 2 3 4 5 6 7 8 9 10 m_listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); target -> setOpacity ( 127 ); buttonState [ target -> getTag ()] = false ; // Solo llama al callback si no es NULL if ( onButtonReleased ) { onButtonReleased (( PadButton ) target -> getTag ()); } }; Obtenemos el bot\u00f3n ( target ) sobre el que se ha definido el listener y anotamos que el bot\u00f3n ya no est\u00e1 pulsado, adem\u00e1s de llamar al callback correspondiente en caso de estar asignado. Por \u00faltimo, a\u00f1adiremos el listener sobre cada uno de los botones. Podemos observar que hay una instancia del listener para cada bot\u00f3n, con lo que en cada uno de ellos el target ser\u00e1 un \u00fanico bot\u00f3n concreto: 1 2 3 m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( m_listener , m_buttonLeft ); m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( m_listener -> clone (), m_buttonRight ); m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( m_listener -> clone (), m_buttonAction ); Mostramos a continuaci\u00f3n el c\u00f3digo completo de esta implementaci\u00f3n sencilla de un pad virtual: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 // VirtualPad.h #define kPAD_MARGIN 20 class VirtualPad : public VirtualControls { public : bool init (); void preloadResources (); Node * getNode (); CREATE_FUNC ( VirtualPad ); private : cocos2d :: Sprite * m_buttonAction ; cocos2d :: Sprite * m_buttonLeft ; cocos2d :: Sprite * m_buttonRight ; cocos2d :: EventListenerTouchOneByOne * m_listener ; }; // VirtualPad.cpp bool VirtualPad :: init (){ VirtualControls :: init (); return true ; } void VirtualPad :: preloadResources (){ //Cache de sprites auto spriteFrameCache = SpriteFrameCache :: getInstance (); //Si no estaba el spritesheet en la cach\u00e9 lo cargo if ( ! spriteFrameCache -> getSpriteFrameByName ( \"boton-direccion.png\" )) { spriteFrameCache -> addSpriteFramesWithFile ( \"mando.plist\" ); } } Node * VirtualPad :: getNode (){ if ( m_node == NULL ) { Size visibleSize = Director :: getInstance () -> getVisibleSize (); Vec2 visibleOrigin = Director :: getInstance () -> getVisibleOrigin (); m_buttonLeft = Sprite :: createWithSpriteFrameName ( \"boton-direccion.png\" ); m_buttonLeft -> setAnchorPoint ( Vec2 ( 0 , 0 )); m_buttonLeft -> setPosition ( visibleOrigin . x + kPAD_MARGIN , visibleOrigin . y + kPAD_MARGIN ); m_buttonLeft -> setOpacity ( 127 ); m_buttonLeft -> setTag ( Button :: BUTTON_LEFT ); m_buttonRight = Sprite :: createWithSpriteFrameName ( \"boton-direccion.png\" ); m_buttonRight -> setAnchorPoint ( Vec2 ( 1 , 0 )); m_buttonRight -> setScaleX ( - 1 ); m_buttonRight -> setOpacity ( 127 ); m_buttonRight -> setPosition ( visibleOrigin . x + kPAD_MARGIN + m_buttonLeft -> getContentSize (). width + kPAD_MARGIN , visibleOrigin . y + kPAD_MARGIN ); m_buttonRight -> setTag ( Button :: BUTTON_RIGHT ); m_buttonAction = Sprite :: createWithSpriteFrameName ( \"boton-accion.png\" ); m_buttonAction -> setAnchorPoint ( Vec2 ( 1 , 0 )); m_buttonAction -> setPosition ( visibleOrigin . x + visibleSize . width - kPAD_MARGIN , visibleOrigin . y + kPAD_MARGIN ); m_buttonAction -> setOpacity ( 127 ); m_buttonAction -> setTag ( Button :: BUTTON_ACTION ); m_node = Node :: create (); m_node -> addChild ( m_buttonLeft , 0 ); m_node -> addChild ( m_buttonRight , 0 ); m_node -> addChild ( m_buttonAction , 0 ); m_node -> setLocalZOrder ( 100 ); m_listener = EventListenerTouchOneByOne :: create (); m_listener -> setSwallowTouches ( true ); m_listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point locationInNode = target -> convertToNodeSpace ( touch -> getLocation ()); Size s = target -> getContentSize (); Rect rect = Rect ( 0 , 0 , s . width , s . height ); if ( rect . containsPoint ( locationInNode )) { buttonState [ target -> getTag ()] = true ; if ( onButtonPressed ) { onButtonPressed (( Button ) target -> getTag ()); } target -> setOpacity ( 255 ); return true ; } return false ; }; m_listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); target -> setOpacity ( 127 ); buttonState [ target -> getTag ()] = false ; if ( onButtonReleased ) { onButtonReleased (( Button ) target -> getTag ()); } }; m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( m_listener , m_buttonLeft ); m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( m_listener -> clone (), m_buttonRight ); m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( m_listener -> clone (), m_buttonAction ); } return m_node ; }","title":"Pad virtual"},{"location":"mandos.html#stick-virtual","text":"El stick virtual emula el stick anal\u00f3gico de un mando. Podremos pulsar sobre \u00e9l y arrastrar para as\u00ed graduar cu\u00e1nto queremos moverlo en una determinada direcci\u00f3n. En el caso del pad por ejemplo la direcci\u00f3n izquierda puede estar pulsada o no estarlo. En el stick podemos moverlo m\u00e1s o menos a la izquierda. Podremos leer el estado del stick anal\u00f3gico a partir del valor de sus ejes vertical y horizontal, que tomar\u00e1n valores reales entre -1 y 1 . Para crear el aspecto visual de nuestro stick anal\u00f3gico utilizaremos dos sprites , uno para la base, que no se mover\u00e1 nunca, y otro para la \"palanca\", que se desplazar\u00e1 conforme la arrastremos: 1 2 3 private : cocos2d :: Sprite * m_stickLeft ; cocos2d :: Sprite * m_stickLeftBase ; Adem\u00e1s, para facilitar la gesti\u00f3n del stick almacenaremos su posici\u00f3n central y el radio en el que puede moverse: 1 2 3 4 5 private : ... cocos2d :: Size m_radioStick ; cocos2d :: Point m_centerStick ; Una vez definidas estas propiedades de la clase de nuestro stick vamos a pasar a implementar el c\u00f3digo. Inicializaremos los sprites que componen el stick de la siguiente forma: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Size visibleSize = Director :: getInstance () -> getVisibleSize (); Vec2 visibleOrigin = Director :: getInstance () -> getVisibleOrigin (); m_stickLeftBase = Sprite :: createWithSpriteFrameName ( \"base-stick.png\" ); m_stickLeftBase -> setAnchorPoint ( Vec2 ( 0 , 0 )); m_stickLeftBase -> setPosition ( visibleOrigin . x + kSTICK_MARGIN , visibleOrigin . y + kSTICK_MARGIN ); m_stickLeftBase -> setOpacity ( 127 ); m_stickLeft = Sprite :: createWithSpriteFrameName ( \"bola-stick.png\" ); m_stickLeft -> setAnchorPoint ( Vec2 ( 0.5 , 0.5 )); m_stickLeft -> setOpacity ( 127 ); m_radioStick = m_stickLeftBase -> getContentSize () * 0.5 - m_stickLeft -> getContentSize () * 0.5 ; m_centerStick = m_stickLeftBase -> getPosition () + m_stickLeftBase -> getContentSize () * 0.5 ; m_stickLeft -> setPosition ( m_centerStick ); Como podemos ver, posicionamos en primer lugar la base del stick en la esquina inferior-izquierda de la pantalla, haci\u00e9ndola semiopaca. Tras esto, creamos la palanca y la posicionamos justo en el centro de la base. Definimos m_centerStick como la posici\u00f3n central de la base de la palanca, y m_radioStick como el radio en el que la palanca podr\u00e1 moverse. Este radio se obtiene a partir de la media anchura y altura de la base, rest\u00e1ndole la media anchura y altura de la palanca, para que as\u00ed esta \u00faltima quede siempre dentro de la base al desplazarla. Una vez creado y configurado el stick , lo a\u00f1adimos a la pantalla: 1 2 3 4 m_node = Node :: create (); m_node -> addChild ( m_stickLeftBase , 0 ); m_node -> addChild ( m_stickLeft , 1 ); m_node -> setLocalZOrder ( 100 ); A continuaci\u00f3n, definiremos un listener de eventos t\u00e1ctiles para controlar el stick : 1 2 EventListenerTouchOneByOne * listener = EventListenerTouchOneByOne :: create (); listener -> setSwallowTouches ( true ); En el evento del comienzo del contacto comprobaremos si estamos tocando dentro de la palanca, y en tal caso devolveremos true para seguir procesando el gesto. En caso contrario, devolvemos false para ignorar los siguientes eventos de movimiento de dicho contacto. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point locationInNode = target -> convertToNodeSpace ( touch -> getLocation ()); Size s = target -> getContentSize (); Rect rect = Rect ( 0 , 0 , s . width , s . height ); if ( rect . containsPoint ( locationInNode )) { target -> setOpacity ( 255 ); return true ; } return false ; }; El evento m\u00e1s importante ser\u00e1 el de movimiento del contacto: 1 2 3 4 5 6 7 8 9 10 11 12 13 listener -> onTouchMoved = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point offset = touch -> getLocation () - touch -> getStartLocation (); Point max ( m_radioStick ); Point min ( Point :: ZERO - m_radioStick ); offset . clamp ( min , max ); axisState [ Axis :: AXIS_VERTICAL ] = offset . y / max . y ; axisState [ Axis :: AXIS_HORIZONTAL ] = offset . x / max . x ; target -> setPosition ( m_centerStick + offset ); }; En este caso calculamos el desplazamiento ( offset ) de la posici\u00f3n a la que hemos movido el dedo respecto a la posici\u00f3n del contacto que inici\u00f3 el gesto ( getStartLocation() ). En funci\u00f3n de dicho desplazamiento calculamos el valor de cada uno de los ejes, no permitiendo que se salga nunca del radio permitido (esto lo hacemos con la funci\u00f3n clamp , para hacer que offset nunca pueda ser mayor que la posici\u00f3n m\u00e1xima ni menor que la m\u00ednima). Por \u00faltimo, en el evento de finalizaci\u00f3n del gesto volveremos a poner ambos ejes en la posici\u00f3n central (0,0): 1 2 3 4 5 6 7 8 listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); target -> setOpacity ( 127 ); target -> setPosition ( m_centerStick ); axisState [ Axis :: AXIS_VERTICAL ] = 0 ; axisState [ Axis :: AXIS_HORIZONTAL ] = 0 ; }; A\u00f1adiremos el listener al gestor de eventos: 1 m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , m_stickLeft ); Para terminar incluimos el c\u00f3digo completo de la clase que implementa el stick anal\u00f3gico y un bot\u00f3n digital: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 // VirtualStick.h #define kSTICK_MARGIN 20 class VirtualStick : public VirtualControls { public : bool init (); void preloadResources (); Node * getNode (); CREATE_FUNC ( VirtualStick ); private : cocos2d :: Sprite * m_buttonAction ; cocos2d :: Sprite * m_stickLeft ; cocos2d :: Sprite * m_stickLeftBase ; cocos2d :: Size m_radioStick ; cocos2d :: Point m_centerStick ; }; // VirtualStick.cpp bool VirtualStick :: init (){ VirtualControls :: init (); return true ; } void VirtualStick :: preloadResources (){ //Cache de sprites auto spriteFrameCache = SpriteFrameCache :: getInstance (); //Si no estaba el spritesheet en la cach\u00e9 lo cargo if ( ! spriteFrameCache -> getSpriteFrameByName ( \"boton-direccion.png\" )) { spriteFrameCache -> addSpriteFramesWithFile ( \"mando.plist\" ); } } Node * VirtualStick :: getNode (){ if ( m_node == NULL ) { Size visibleSize = Director :: getInstance () -> getVisibleSize (); Vec2 visibleOrigin = Director :: getInstance () -> getVisibleOrigin (); m_stickLeftBase = Sprite :: createWithSpriteFrameName ( \"base-stick.png\" ); m_stickLeftBase -> setAnchorPoint ( Vec2 ( 0 , 0 )); m_stickLeftBase -> setPosition ( visibleOrigin . x + kSTICK_MARGIN , visibleOrigin . y + kSTICK_MARGIN ); m_stickLeftBase -> setOpacity ( 127 ); m_stickLeft = Sprite :: createWithSpriteFrameName ( \"bola-stick.png\" ); m_stickLeft -> setAnchorPoint ( Vec2 ( 0.5 , 0.5 )); m_stickLeft -> setOpacity ( 127 ); m_radioStick = m_stickLeftBase -> getContentSize () * 0.5 - m_stickLeft -> getContentSize () * 0.5 ; m_centerStick = m_stickLeftBase -> getPosition () + m_stickLeftBase -> getContentSize () * 0.5 ; m_stickLeft -> setPosition ( m_centerStick ); m_buttonAction = Sprite :: createWithSpriteFrameName ( \"boton-accion.png\" ); m_buttonAction -> setAnchorPoint ( Vec2 ( 1 , 0 )); m_buttonAction -> setPosition ( visibleOrigin . x + visibleSize . width - kSTICK_MARGIN , visibleOrigin . y + kSTICK_MARGIN ); m_buttonAction -> setOpacity ( 127 ); m_buttonAction -> setTag ( Button :: BUTTON_ACTION ); m_node = Node :: create (); m_node -> addChild ( m_stickLeftBase , 0 ); m_node -> addChild ( m_stickLeft , 1 ); m_node -> addChild ( m_buttonAction , 0 ); m_node -> setLocalZOrder ( 100 ); EventListenerTouchOneByOne * listener = EventListenerTouchOneByOne :: create (); listener -> setSwallowTouches ( true ); listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point locationInNode = target -> convertToNodeSpace ( touch -> getLocation ()); Size s = target -> getContentSize (); Rect rect = Rect ( 0 , 0 , s . width , s . height ); if ( rect . containsPoint ( locationInNode )) { buttonState [ target -> getTag ()] = true ; if ( onButtonPressed ) { onButtonPressed (( Button ) target -> getTag ()); } target -> setOpacity ( 255 ); return true ; } return false ; }; listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); target -> setOpacity ( 127 ); buttonState [ target -> getTag ()] = false ; if ( onButtonReleased ) { onButtonReleased (( Button ) target -> getTag ()); } }; m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , m_buttonAction ); // Listener stick listener = EventListenerTouchOneByOne :: create (); listener -> setSwallowTouches ( true ); listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point locationInNode = target -> convertToNodeSpace ( touch -> getLocation ()); Size s = target -> getContentSize (); Rect rect = Rect ( 0 , 0 , s . width , s . height ); if ( rect . containsPoint ( locationInNode )) { target -> setOpacity ( 255 ); return true ; } return false ; }; listener -> onTouchMoved = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point offset = touch -> getLocation () - touch -> getStartLocation (); Point max ( m_radioStick ); Point min ( Point :: ZERO - m_radioStick ); offset . clamp ( min , max ); axisState [ Axis :: AXIS_VERTICAL ] = offset . y / max . y ; axisState [ Axis :: AXIS_HORIZONTAL ] = offset . x / max . x ; target -> setPosition ( m_centerStick + offset ); }; listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); target -> setOpacity ( 127 ); target -> setPosition ( m_centerStick ); axisState [ Axis :: AXIS_VERTICAL ] = 0 ; axisState [ Axis :: AXIS_HORIZONTAL ] = 0 ; }; m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , m_stickLeft ); } return m_node ; }","title":"Stick virtual"},{"location":"mandos.html#stick-virtual-con-posicionamiento-automatico","text":"El stick virtual tiene el problema de no tener feedback f\u00edsico, por lo que si tenemos la atenci\u00f3n centrada en la escena del juego es posible que no sepamos si estamos tocando en el centro del mando o no, al intentar hacer un moviemiento. Para evitar esto podemos hacer que al tocar sobre la pantalla el stick se sit\u00fae autom\u00e1ticamente centrado en la posici\u00f3n donde hemos tocado. As\u00ed sabremos que siempre tocamos en el centro, y s\u00f3lo tendremos que arrastrar. Una posible estrategia para implementar este tipo de sticks es dividir el tama\u00f1o de la pantalla en dos: el lado izquierdo dedicado al stick anal\u00f3gico, y el lado derecho a los botones de acci\u00f3n. Al pulsar en cualquier lugar del lado izquierdo crearemos un stick anal\u00f3gico en dicha posici\u00f3n, y al arrastrar moveremos sus ejes. Al pulsar en el lado derecho realizaremos una acci\u00f3n (por ejemplo saltar). Deberemos crear una variante adecuada para nuestro tipo de juego. Crearemos los sprites necesarios para el stick anal\u00f3gico autoposicionado de forma similar al caso anterior, pero con la diferencia de que en este caso los haremos invisibles y no les daremos ninguna posici\u00f3n inicial: 1 2 3 4 5 6 7 8 9 10 11 12 Size visibleSize = Director :: getInstance () -> getVisibleSize (); Vec2 visibleOrigin = Director :: getInstance () -> getVisibleOrigin (); m_stickLeftBase = Sprite :: createWithSpriteFrameName ( \"base-stick.png\" ); m_stickLeftBase -> setAnchorPoint ( Vec2 ( 0.5 , 0.5 )); m_stickLeftBase -> setVisible ( false ); m_stickLeft = Sprite :: createWithSpriteFrameName ( \"bola-stick.png\" ); m_stickLeft -> setAnchorPoint ( Vec2 ( 0.5 , 0.5 )); m_stickLeft -> setVisible ( false ); m_radioStick = m_stickLeftBase -> getContentSize () * 0.5 - m_stickLeft -> getContentSize () * 0.5 ; Los a\u00f1adimos a la pantalla: 1 2 3 4 m_node = Node :: create (); m_node -> addChild ( m_stickLeftBase , 0 ); m_node -> addChild ( m_stickLeft , 1 ); m_node -> setLocalZOrder ( 100 ); Y creamos un listener para los eventos de la pantalla t\u00e1ctil: 1 2 EventListenerTouchOneByOne * listener = EventListenerTouchOneByOne :: create (); listener -> setSwallowTouches ( true ); Donde si que introduciremos notables diferencias es en los eventos del listener . En primer lugar, onTouchBegan comprobar\u00e1 si tocamos en la mitad izquierda de la pantalla, y en tal caso har\u00e1 aparecer el stick en la posici\u00f3n donde hemos tocado y devolver\u00e1 true para seguir procesando el gesto. En caso contrario devuelve false para ignorar los siguientes eventos de movimento de dicho gesto (en tal caso se deja que lo procese el listener encargado de los botones de acci\u00f3n a la derecha): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); m_centerStick = target -> convertToNodeSpace ( touch -> getLocation ()); Size winSize = Director :: getInstance () -> getWinSize (); if ( m_centerStick . x < winSize . width / 2 ) { m_stickLeftBase -> setPosition ( m_centerStick ); m_stickLeftBase -> setVisible ( true ); m_stickLeft -> setPosition ( m_centerStick ); m_stickLeft -> setVisible ( true ); return true ; } else { return false ; } }; Destacamos que en este caso utilizamos tambi\u00e9n la propiedad m_centerStick , pero no le damos una posici\u00f3n fija en la actualizaci\u00f3n, sino que la modificamos cada vez que comenzamos un nuevo gesto t\u00e1ctil en onTouchBegan . En segundo lugar, onTouchMoved se comporar\u00e1 igual que en el caso del stick con posici\u00f3n fija: 1 2 3 4 5 6 7 8 9 10 11 12 listener -> onTouchMoved = [ = ]( Touch * touch , Event * event ) { Point offset = touch -> getLocation () - touch -> getStartLocation (); Point max ( m_radioStick ); Point min ( Point :: ZERO - m_radioStick ); offset . clamp ( min , max ); axisState [ Axis :: AXIS_VERTICAL ] = offset . y / max . y ; axisState [ Axis :: AXIS_HORIZONTAL ] = offset . x / max . x ; m_stickLeft -> setPosition ( m_centerStick + offset ); }; Por \u00faltimo, onTouchEnded tiene como diferencia que en este caso volveremos a ocultar el stick : 1 2 3 4 5 6 7 listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ) { m_stickLeftBase -> setVisible ( false ); m_stickLeft -> setVisible ( false ); axisState [ Axis :: AXIS_VERTICAL ] = 0 ; axisState [ Axis :: AXIS_HORIZONTAL ] = 0 ; }; A continuaci\u00f3n incluimos el c\u00f3digo completo de las clases que incorporan el stick anal\u00f3gico con posicionamiento autom\u00e1tico, combinado con un bot\u00f3n de acci\u00f3n en la parte derecha: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 // VirtualStickAuto.h #define kAUTOSTICK_MARGIN 20 class VirtualStickAuto : public VirtualControls { public : bool init (); void preloadResources (); Node * getNode (); CREATE_FUNC ( VirtualStickAuto ); private : cocos2d :: Sprite * m_buttonAction ; cocos2d :: Sprite * m_stickLeft ; cocos2d :: Sprite * m_stickLeftBase ; cocos2d :: Size m_radioStick ; cocos2d :: Point m_centerStick ; }; // VirtualStickAuto.cpp bool VirtualStickAuto :: init (){ VirtualControls :: init (); return true ; } void VirtualStickAuto :: preloadResources (){ //Cache de sprites auto spriteFrameCache = SpriteFrameCache :: getInstance (); //Si no estaba el spritesheet en la cach\u00e9 lo cargo if ( ! spriteFrameCache -> getSpriteFrameByName ( \"boton-direccion.png\" )) { spriteFrameCache -> addSpriteFramesWithFile ( \"mando.plist\" ); } } Node * VirtualStickAuto :: getNode (){ if ( m_node == NULL ) { Size visibleSize = Director :: getInstance () -> getVisibleSize (); Vec2 visibleOrigin = Director :: getInstance () -> getVisibleOrigin (); m_stickLeftBase = Sprite :: createWithSpriteFrameName ( \"base-stick.png\" ); m_stickLeftBase -> setAnchorPoint ( Vec2 ( 0.5 , 0.5 )); m_stickLeftBase -> setVisible ( false ); m_stickLeft = Sprite :: createWithSpriteFrameName ( \"bola-stick.png\" ); m_stickLeft -> setAnchorPoint ( Vec2 ( 0.5 , 0.5 )); m_stickLeft -> setVisible ( false ); m_radioStick = m_stickLeftBase -> getContentSize () * 0.5 - m_stickLeft -> getContentSize () * 0.5 ; m_buttonAction = Sprite :: createWithSpriteFrameName ( \"boton-accion.png\" ); m_buttonAction -> setAnchorPoint ( Vec2 ( 1 , 0 )); m_buttonAction -> setOpacity ( 127 ); m_buttonAction -> setPosition ( visibleOrigin . x + visibleSize . width - kAUTOSTICK_MARGIN , visibleOrigin . y + kAUTOSTICK_MARGIN ); m_buttonAction -> setTag ( Button :: BUTTON_ACTION ); m_node = Node :: create (); m_node -> addChild ( m_stickLeftBase , 0 ); m_node -> addChild ( m_stickLeft , 1 ); m_node -> addChild ( m_buttonAction , 0 ); m_node -> setLocalZOrder ( 100 ); EventListenerTouchOneByOne * listener = EventListenerTouchOneByOne :: create (); listener -> setSwallowTouches ( true ); listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); Point locationInNode = target -> convertToNodeSpace ( touch -> getLocation ()); Size s = target -> getContentSize (); Rect rect = Rect ( 0 , 0 , s . width , s . height ); if ( rect . containsPoint ( locationInNode )) { buttonState [ target -> getTag ()] = true ; if ( onButtonPressed ) { onButtonPressed (( Button ) target -> getTag ()); } target -> setOpacity ( 255 ); return true ; } return false ; }; listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); target -> setOpacity ( 127 ); buttonState [ target -> getTag ()] = false ; if ( onButtonReleased ) { onButtonReleased (( Button ) target -> getTag ()); } }; m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , m_buttonAction ); // Listener stick listener = EventListenerTouchOneByOne :: create (); listener -> setSwallowTouches ( true ); listener -> onTouchBegan = [ = ]( Touch * touch , Event * event ) { auto target = static_cast < Sprite *> ( event -> getCurrentTarget ()); m_centerStick = target -> convertToNodeSpace ( touch -> getLocation ()); Size winSize = Director :: getInstance () -> getWinSize (); if ( m_centerStick . x < winSize . width / 2 ) { m_stickLeftBase -> setPosition ( m_centerStick ); m_stickLeftBase -> setVisible ( true ); m_stickLeft -> setPosition ( m_centerStick ); m_stickLeft -> setVisible ( true ); return true ; } else { return false ; } }; listener -> onTouchMoved = [ = ]( Touch * touch , Event * event ) { Point offset = touch -> getLocation () - touch -> getStartLocation (); Point max ( m_radioStick ); Point min ( Point :: ZERO - m_radioStick ); offset . clamp ( min , max ); axisState [ Axis :: AXIS_VERTICAL ] = offset . y / max . y ; axisState [ Axis :: AXIS_HORIZONTAL ] = offset . x / max . x ; m_stickLeft -> setPosition ( m_centerStick + offset ); }; listener -> onTouchEnded = [ = ]( Touch * touch , Event * event ) { m_stickLeftBase -> setVisible ( false ); m_stickLeft -> setVisible ( false ); axisState [ Axis :: AXIS_VERTICAL ] = 0 ; axisState [ Axis :: AXIS_HORIZONTAL ] = 0 ; }; m_node -> getEventDispatcher () -> addEventListenerWithSceneGraphPriority ( listener , m_node ); } return m_node ; } Es importante remarcar que con esta implementaci\u00f3n de controles virtuales podremos reemplazar un tipo de control por otro sin afectar al c\u00f3digo de nuestro juego, que siempre utilizar\u00e1 VirtualControls . Simplemente cambiando la subclase concreta que instanciamos podremos alternar entre diferentes formas de control.","title":"Stick virtual con posicionamiento autom\u00e1tico"},{"location":"mandos.html#mandos-fisicos","text":"Vamos a ver en esta secci\u00f3n diferentes tipos de mandos hardware que podremos integrar en nuestros videojuegos.","title":"Mandos f\u00edsicos"},{"location":"mandos.html#tipos-de-mandos-fisicos","text":"","title":"Tipos de mandos f\u00edsicos"},{"location":"mandos.html#controladores-fisicos-en-cocos2d-x","text":"Cocos2d-x soporta tanto los mandos oficiales de Android como los oficiales de iOS, ofreci\u00e9ndonos una API \u00fanica para utilizarlos en cualquiera de estas plataformas. Vamos a centrarnos en la API com\u00fan de Cocos2d-x y en las cuestiones espec\u00edficas para utilizarla en Android e iOS.","title":"Controladores f\u00edsicos en Cocos2d-x"},{"location":"motor_de_fisicas.html","text":"Motores de f\u00edsicas \u00b6 Un tipo de juegos que ha tenido una gran proliferaci\u00f3n en el mercado de aplicaciones para m\u00f3viles son aquellos juegos basados en f\u00edsicas. Estos juegos son aquellos en los que el motor realiza una simulaci\u00f3n f\u00edsica de los objetos en pantalla, siguiendo las leyes de la cinem\u00e1tica y la din\u00e1mica. Es decir, los objetos de la pantalla est\u00e1n sujetos a gravedad, cada uno de ellos tiene una masa, y cuando se produce una colisi\u00f3n entre ellos se produce una fuerza de reacci\u00f3n que depender\u00e1 de su velocidad y su masa. El motor de f\u00edsicas se encarga de realizar toda esta simulaci\u00f3n, y nosotros s\u00f3lo deberemos encargarnos de proporcionar las propiedades de los objetos del mundo. Uno de los juegos que m\u00e1s se ha popularizado, cuya mec\u00e1nica est\u00e1 basada casi al completo en f\u00edsicas es Angry Birds (desarrollado por Rovio ). Componentes del motor de f\u00edsicas \u00b6 Los componentes b\u00e1sicos que nos aporta un motor de f\u00edsicas son los siguientes: Body : Representa un cuerpo r\u00edgido. Estos son los tipos de objetos que tendremos en el mundo f\u00edsico simulado. Cada cuerpo tendr\u00e1 una posici\u00f3n y velocidad. Los cuerpos se ver\u00e1n afectados por la gravedad del mundo, y por la interacci\u00f3n con los otros cuerpos. Cada cuerpo tendr\u00e1 una serie de propiedades f\u00edsicas, como su masa, su centro de gravedad, su coeficiente de fricci\u00f3n o su forma ( shape ). Shape : Una de las principales caracter\u00edsticas que deberemos tener en cuenta de los cuerpos f\u00edsicos es su forma . Es importante destacar que el aspecto gr\u00e1fico de los nodos se define de forma independiente de la forma que tendr\u00e1 en el mundo f\u00edsico, pero deberemos intentar que sean lo m\u00e1s parecidos posibles. Joint : Nos permite definir uniones entre diferentes cuerpos. Por ejemplo, podemos hacer que un cuerpo est\u00e9 conectado a otro mediante un resorte, o que pueda moverse s\u00f3lo en un determinado eje. World : Representa el mundo f\u00edsico en el que tendr\u00e1 lugar la simulaci\u00f3n. A \u00e9l se a\u00f1adir\u00e1n todos los cuerpos y se encargar\u00e1 de realizar la simulaci\u00f3n f\u00edsica sobre ellos, aplicando las correspondientes fuerzas y actualizando su velocidad y posici\u00f3n en el mundo. Una de las principales propiedades del mundo es la gravedad. Cuerpos f\u00edsicos \u00b6 Vamos en primer lugar a estudiar los diferentes tipos de cuerpos y sus porpiedades. Tipos de cuerpos \u00b6 En los motores de f\u00edsicas encontraremos tres tipos diferentes de cuerpos: Din\u00e1micos : Est\u00e1n sometidos a las leyes f\u00edsicas, y tienen una masa concreta y finita. Estos cuerpos se ven afectados por la gravedad y por la interacci\u00f3n con los dem\u00e1s cuerpos. Est\u00e1ticos : Son cuerpos que permanecen siempre en la misma posici\u00f3n. Equivalen a cuerpos con masa infinita. Por ejemplo, podemos hacer que el escenario sea est\u00e1tico. Es importante no mover aquellos cuerpos que hayan sido marcados como est\u00e1ticos, ya que el motor podr\u00eda no responder de forma correcta (\u00e9ste realiza diferentes optimizaciones que asumen que no se van a mover). Cinem\u00e1ticos : Al igual que los cuerpos est\u00e1ticos tienen masa infinita y no se ven afectados por otros cuerpos ni por la gravedad. Sin embargo, en esta caso no tienen una posici\u00f3n fija, sino que podemos moverlos por el mundo, y podemos darles una velocidad fija. Nos son \u00fatiles por ejemplo para proyectiles. Forma de los cuerpos \u00b6 Dependiendo de si tenemos un motor 2D o 3D, las formas de los cuerpos del motor f\u00edsico ser\u00e1n distintas. Seg\u00fan la forma de los cuerpos, ser\u00e1 para el motor m\u00e1s o menos complejo calcular las colisiones entre ellos. A continuaci\u00f3n mostramos, ordenadas de menor a mayor complejidad , las formas que encontramos habitualmente en un motor de f\u00edsicas 2D: C\u00edrculos . Es la forma m\u00e1s sencilla. Se crea simplemente indicando su centro y su radio, y el c\u00e1lculo de colisiones con ellos es muy eficiente. Pol\u00edgonos . Nos permite crear formas arbitrarias convexas. Es importante destacar que los pol\u00edgonos siempre deber\u00e1n ser convexos y cerrados . El c\u00e1lculo de colisiones con formas c\u00f3ncavas es demasiado complejo para el motor de f\u00edsicas. Un tipo de pol\u00edgono muy habitual ser\u00e1 la forma de caja , muchas veces el motor nos dar\u00e1 atajos para crear dicha forma. Formas compuestas . Si ninguno de los tipos anteriores de formas se adapta a nuestras necesidades, como por ejemplo en el caso de necesitar una forma c\u00f3ncava, podemos definir la forma del cuerpo como una composici\u00f3n de form\u00e1s b\u00e1sicas. Esto ser\u00e1 \u00fatil para cuerpos din\u00e1micos con formas complejas. Aristas . Las aristas ( edges ) son segmentos de l\u00ednea que normalmente se utilizan para construir la geometr\u00eda del escenario est\u00e1tico, que podr\u00e1 tener una forma arbitraria. Este tipo de cuerpo y el siguiente, por poder presentar concavidades , s\u00f3lo podr\u00e1 ser utilizado para cuerpos est\u00e1ticos . El c\u00e1lculo de colisiones entre dos cuerpos c\u00f3ncavos es demasiado complejo, por lo que no debe haber cuerpos din\u00e1micos con esas formas (el motor necesita comprobar las colisiones entre pares de cuerpos din\u00e1micos, pero nunca entre dos cuerpos est\u00e1ticos, al no poder moverse). Cadenas . Las cadenas nos permiten unir varias aristas para as\u00ed definir la geometr\u00eda est\u00e1tica del escenario y evitar que se puedan producir \"baches\" en las juntas entre diferentes aristas. En el caso 3D tenemos: Esferas . Es la forma m\u00e1s sencilla en este caso. Dado el centro y el radio de la esfera, para saber si colisiona con otra simplemente tendremos que calculas si la distancia entre sus centros es menor que la suma de sus radios. Cajas . En el caso 3D, en el segundo lugar de complejidad encontramos las cajas. Dependiendo del motor, podr\u00edamos encontrar tras este tipo otras clases de formas geom\u00e9tricas predefinidas, como cilindros y conos. Maya convexa . Si en el motor gr\u00e1fico tenemos una maya 3D, podemos utilizar como forma f\u00edsica asociada un recubrimiento convexo ( convex hull ) de dicha maya. Es decir, cogemos la misma forma pero eliminando las concavidades. Formas compuestas . En algunos casos no podemos eliminar las concavidades de un cuerpo f\u00edsico, pensemos por ejemplo en la forma de una silla, con sus patas, respaldo y asiento. En estos casos, si necesitamos que dicho cuerpo se comporte como din\u00e1mico, podemos crear su forma como una composici\u00f3n de formas c\u00f3ncavas de los tipos anteriores (por ejemplo, una caja por cada pata, otra para el asiento, y otra para el respaldo). Maya c\u00f3ncava . El uso de mayas c\u00f3ncavas, al igual que ocurr\u00eda en el caso 2D con los edges y cadenas, queda reservado exclusivamente a los cuerpos est\u00e1ticos. Puede utilizarse, por ejemplo, para definir la geometr\u00eda f\u00edsica del escenario est\u00e1tico del juego. Propiedades de los cuerpos \u00b6 Los cuerpos y tienen una serie de propiedades que nos permiten definir su comportamiento en la simulaci\u00f3n f\u00edsica. Hemos hablado sobre la forma de los cuerpos. Vamos a ver ahora otras propiedades f\u00edsicas que podemos configurar: Masa . La masa determinar\u00e1 cu\u00e1nta fuerza deberemos aplicar al objeto para producir una aceleraci\u00f3n. Cuanto mayor sera la masa, m\u00e1s nos costar\u00e1 modificar su velocidad al aplicar una fuerza. Cabe destacar el caso extremos de los cuerpos est\u00e1ticos o cinem\u00e1ticos, que tienen masa infinita. Es decir, las fuerzas no tienen efecto sobre ellos. Centro de masas . Podemos establecer qu\u00e9 punto ser\u00e1 el centro de masas del objeto. Por defecto ser\u00e1 su centro, pero podemos modificarlo. Cuando apliquemos una fuerza en el centro de masas, se producir\u00e1 una aceleraci\u00f3n lineal. Sin embargo, si se aplica una fuerza en otro punto, la aceleraci\u00f3n tendr\u00e1 tanto una componente lineal como angular (el objeto se mover\u00e1 y girar\u00e1). Momento de inercia . Es el equivalente a la masa, pero en el caso de aplicar una fuerza angular. Nos da una indicaci\u00f3n sobre cu\u00e1nto nos cuesta girar un objeto. Los objetos que tienen su masa concentrada alrededor del centro de masas ser\u00e1n m\u00e1s f\u00e1ciles de girar que aquellos en los que est\u00e1 distribuida a mayor distancia del centro. Resistencia al aire . Para cada cuerpo podemos indicar una constante de resistencia al aire ( damping ), tanto lineal como angular. La resistencia al aire es la fuerza que har\u00e1 que la velocidad del objeto disminuya, aunque no est\u00e9 en contacto con ning\u00fan otro cuerpo. Cu\u00e1nta mayor sea la velocidad, m\u00e1s fuerza ejercer\u00e1 la resistencia al aire para pararlo. Es recomendable indicar una resistencia al aire para que los cuerpos no se muevan (o roten) de forma indefinida. Fricci\u00f3n . La fricci\u00f3n es la fuerza que hace que un objeto se pare al deslizarse sobre otro, debido a rugosidades de la superficie. A diferencia de la resistencia al aire, esta fuerza s\u00f3lo se ejercer\u00e1 cuando dos cuerpos est\u00e9n en contacto. Restituci\u00f3n . La restituci\u00f3n nos indica la forma en la que responder\u00e1 un objeto al colisionar con otro, permitiendo que los objetos permanezcan juntos o reboten. Una restituci\u00f3n 0 indica que el objeto no rebotar\u00e1 el colisionar, mientras que el valor 1 indica que al colisionar rebota y en el rebote se restituye toda la velocidad que ten\u00eda en el momento previo a la colisi\u00f3n. Simulaci\u00f3n f\u00edsica \u00b6 Una vez vistas las propiedades de los cuerpos del mundo f\u00edsico, vamos a ver como realiza el motor la simulaci\u00f3n. Es importante destacar que la simulaci\u00f3n se realiza de forma discreta. Es decir, en cada iteraci\u00f3n del ciclo del juego, se simula la aplicaci\u00f3n de las leyes de la cinem\u00e1tica y de la din\u00e1mica a todos los cuerpos del mundo, considerando el tiempo transcurrido desde la iteraci\u00f3n anterior ( delta time ), para la actualizaci\u00f3n de la posici\u00f3n y velocidad de los objetos. Recomendaci\u00f3n : En el caso de la simulaci\u00f3n f\u00edsica conviene utilizar un delta time fijo, para as\u00ed obtener resultados predecibles en la simulaci\u00f3n (por ejemplo 60 fps ), independientemente del frame rate del render gr\u00e1fico , que podr\u00eda ser variable. Normalmente los motores se encargan de gestionar esto por nosotros. Sobre los cuerpos del mundo f\u00edsico actuar\u00e1n una serie de fuerzas: Gravedad . La fuerza de gravedad es una propiedad del mundo f\u00edsico que podremos alterar, y que por defecto se aplicar\u00e1 sobre todos los cuerpos del mundo, aunque podremos excluir determinados cuerpos de forma manual. Resistencia al aire . Dependiendo de la propiedad damping de cada objeto, se aplicar\u00e1 sobre ellos una fuerza de resistencia al aire, proporcional a su velocidad y a su factor de damping , pero en la direcci\u00f3n contraria a su movimient. Fuerzas de reacci\u00f3n . Cuando se produzca una colisi\u00f3n entre objetos, se producir\u00e1 una fuerza de reacci\u00f3n entre ellos, que depender\u00e1 de su propiedad de restituci\u00f3n . Seg\u00fan dicha propiedad, esta fuerza har\u00e1 simplemente que queden paren de moverse, o que reboten. Fuerzas aplicadas en el c\u00f3digo . Podemos aplicar fuerzas sobre los diferentes cuerpos del mundo, por ejemplo para empujar una caja o lanzar una roca. El motor de simulaci\u00f3n f\u00edsica, a partir de las fuerzas aplicadas a los cuerpos y las propiedades de los mismos, calcular\u00e1 la aceleraci\u00f3n producida en cada caso. Con ello, aplicando las ecuaciones de la cinem\u00e1tica y de la din\u00e1mica actualizar\u00e1 la velocidad y la posici\u00f3n de los mismos. Tras realizar la actualizaci\u00f3n, comprobar\u00e1 si se producen colisiones entre los cuerpos. En tal caso, deber\u00e1 resolver la colisi\u00f3n, aplicando la fuerza de reacci\u00f3n correspondiente. Vamos a ver con mayor detalle la forma en la que se aplican fuerzas e impulsos sobre los cuerpos del mundo. Fuerza y masa \u00b6 Siguiendo la segunda ley de Newton, la fuerza que se debe aplicar sobre un objeto para producir una determinada aceleraci\u00f3n se calcula de la siguiente forma: \\mathbf{f} = m\\mathbf{a} \\mathbf{f} = m\\mathbf{a} Sin embargo, en nuestro motor de f\u00edsicas lo que realmente nos interesa es conocer la aceleraci\u00f3n producida tras aplicar una fuerza, calculada como: \\mathbf{a} = \\frac{1}{m}\\mathbf{f} \\mathbf{a} = \\frac{1}{m}\\mathbf{f} Podemos ver que aqu\u00ed multiplicamos la fuerza por la inversa de la masa . Dado que este c\u00e1lculo es frecuente, para evitar tener que calcular la inversa en cada momento, normalmente los motores almacenan la masa inversa de los cuerpos, en lugar de almacenar la masa. Almacenar la masa inversa tiene una ventaja importante. Para hacer que un cuerpo sea est\u00e1tico (que no se vea afectado por las fuerzas que sobre \u00e9l se ejerzan) lo que haremos es dar a ese cuerpo masa infinita. Este valor infinito podr\u00eda crear dificultades en el c\u00f3digo, y la necesidad de tratar casos especiales. Si trabajamos \u00fanicamente con masa inversa, bastar\u00e1 con darle un valor 0 a la masa inversa para hacer el cuerpo est\u00e1tico. Adem\u00e1s de la masa, el motor nos permitir\u00e1 especificar el centro de masas y el momento de inercia de los cuerpos. El momento de inercia nos permitir\u00e1 indicar qu\u00e9 par de fuerzas ( torque ) deberemos ejercer para producir una determinada aceleraci\u00f3n angular, de la misma forma que la masa nos indica qu\u00e9 fuerza debemos ejercer para producir una determinada aceleraci\u00f3n lineal. Torque y momento de inercia \u00b6 El torque \\tau \\tau es a la aceleraci\u00f3n angular \\alpha \\alpha lo que la fuerza es a la aceleraci\u00f3n lineal. En este caso, en lugar de tener en cuenta \u00fanicamente la masa del objeto, deberemos tener en cuenta su momento de inercia I I , en el que no s\u00f3lo tenemos la masa, sino c\u00f3mo est\u00e1 repartida a lo largo del cuerpo, lo cual influir\u00e1 en c\u00f3mo las fuerzas afectar\u00e1n a la rotaci\u00f3n. \\tau = I \\alpha \\tau = I \\alpha Por ejemplo, si tenemos un objeto con forma de bast\u00f3n, habr\u00e1 que hacer menos fuerza para que gire alrededor de su eje principal que alrededor de otro eje. Por lo tanto, el momento de inercia no tendr\u00e1 siempre el mismo valor para un determinado objeto, sino que depender\u00e1 del eje de rotaci\u00f3n. El momento de inercia codifica c\u00f3mo est\u00e1 repartida la masa del objeto alrededor de su centro. Para simplificar, supongamos que nuestro cuerpo r\u00edgido est\u00e1 compuesto de n n part\u00edculas cada una de ellas con una determinada masa m_i m_i , y situada en una posici\u00f3n (x_i, y_i) (x_i, y_i) respecto al centro de masas del cuerpo. El momento de inercia se calcular\u00eda de la siguiente forma (medido en kg\u00b7m kg\u00b7m ): I = \\sum^{n}_{i=1} m_i \\sqrt{x_i^2 + y_i^2} I = \\sum^{n}_{i=1} m_i \\sqrt{x_i^2 + y_i^2} Es decir, este coeficiente no tiene en cuenta s\u00f3lo la masa, sino tambi\u00e9n lo alejada que est\u00e1 la masa respecto del centro del centro. De esta forma, har\u00e1 falta hacer m\u00e1s fuerza para girar un cuerpo cuando la distribuci\u00f3n de masa est\u00e9 alejada del centro. Los motores de f\u00edsicas por defecto calcular\u00e1n de forma autom\u00e1tica tanto el centro de masas como el momento de inercia a partir de la densidad (o masa) y de la forma que hemos asignado al cuerpo, y no necesitaremos establecer estos datos de forma manual a no ser que busquemos un comportamiento distinto. Acumulador de fuerzas \u00b6 Normalmente sobre un cuerpo actuar\u00e1n varias fuerzas. Siguiendo el principio de D'Alembert , un conjunto de fuerzas F=\\{f_1, f_2, ... f_{|F|}\\} F=\\{f_1, f_2, ... f_{|F|}\\} actuando sobre un objeto pueden ser sustituidas por una \u00fanica fuerza calculada como la suma de las fuerzas de F F : f = \\sum^{|F|}_{i=1} f_i f = \\sum^{|F|}_{i=1} f_i Para ello, cada objeto contar\u00e1 con un acumulador de fuerzas f f donde se ir\u00e1n sumando todas las fuerzas que act\u00faan sobre \u00e9l (gravedad, resistencia al aire, interacci\u00f3n con otros objetos, etc). Cuando llegue el momento de realizar la actualizaci\u00f3n de posici\u00f3n y velocidad, la aceleraci\u00f3n del objeto se calcular\u00e1 a partir de la fuerza que indique dicho acumulador f f . Deberemos llevar cuidado con la discretizaci\u00f3n del tiempo. Si una gran fuerza se aplica durante un periodo de tiempo muy breve (por ejemplo para disparar una bala), si la aceleraci\u00f3n producida se extiende a todo el delta time el incremento de velocidad producido puede ser desmesurado. Por este motivo, estas fuerzas que se aplican en un instante puntual de tiempo se tratar\u00e1n como impulsos . Aplicaci\u00f3n de fuerzas \u00b6 El caso m\u00e1s com\u00fan de fuerza aplicada a los objetos es la gravedad . Si queremos hacer una simulaci\u00f3n realista deber\u00edamos aplicar una fuerza que produzca una aceleraci\u00f3n de a_{gravedad}=-9.8 \\frac{m}{s^2} a_{gravedad}=-9.8 \\frac{m}{s^2} sobre nuestros objetos en el eje y y (normalmente se redondea en a_{gravedad}=10 a_{gravedad}=10 . Considerando el vector \\mathbf{a}_{gravedad} = (0, a_{gravedad}) \\mathbf{a}_{gravedad} = (0, a_{gravedad}) tenemos: \\mathbf{f}_{gravedad} = \\mathbf{a}_{gravedad}m \\mathbf{f}_{gravedad} = \\mathbf{a}_{gravedad}m Tambi\u00e9n se puede tratar como una fuerza la \"resistencia al aire\" ( damping ) que produce que los objetos vayan frenando y no se muevan indefinidamente. Un modelo simplificado para esta fuerza que se suele utilizar en videojuegos es el siguiente: \\mathbf{f}_{resistencia} = -\\mathbf{\\hat{v}}(k_{damping} |\\mathbf{v}| \\mathbf{f}_{resistencia} = -\\mathbf{\\hat{v}}(k_{damping} |\\mathbf{v}| Donde k_{damping} k_{damping} es la constante de damping especificada para el cuerpo, y \\mathbf{\\hat{v}} \\mathbf{\\hat{v}} el vector de velocidad normalizado (vector unitario con la direcci\u00f3n de la velocidad). Podemos ver que la fuerza act\u00faa en el sentido opuesto a la velocidad del objeto (lo frena), y con una magnitud proporcional a la velocidad. A parte de las fuerzas de gravedad, resistencia al aire, y las fuerzas ejercidas entre cuerpos en contacto, tambi\u00e9n podemos aplicar una fuerza manualmente sobre un determinado cuerpo. A la hora de aplicar una fuerza debemos indicar: Vector de fuerza a aplicar Punto del cuerpo (opcional) donde aplicarla. En caso de no especificarlo, por defecto se considerar\u00e1 que ser\u00e1 su centro de masas. Las unidades en las que especificaremos la fuerza son Newtons ( N = \\frac{kg\u00b7m}{s^2} N = \\frac{kg\u00b7m}{s^2} ). Si el punto del objeto al que aplicamos la fuerza no es su centro de masas, la fuerza producir\u00e1 adem\u00e1s que el objeto rote (a no ser que en sus propiedades hayamos indicado que no puede rotar). Aplicaci\u00f3n de un par de fuerzas ( torque ) \u00b6 Podemos tambi\u00e9n aplicar un par de fuerzas ( torque ) para producir una rotaci\u00f3n del objeto alrededor de su centro de masas sin producir una traslaci\u00f3n. El torque se indica en N\u00b7m N\u00b7m . Impulsos \u00b6 Los impulsos producen un cambio instant\u00e1neo en la velocidad de un objeto. Podemos ver los impulsos respecto a la velocidad como vemos a las fuerzas respecto a la aceleraci\u00f3n. Si aplicar una fuerza a un cuerpo produce una aceleraci\u00f3n, aplicar un impulso produce un cambio de velocidad. Una diferencia importante es que no puede haber aceleraci\u00f3n si no se aplica ninguna fuerza, mientras que si que puede haber velocidad si no se aplican impulsos, un impulso lo que provoca es un cambio en la velocidad. El impulso g g necesario para producir un cambio de velocidad \\Delta v \\Delta v ser\u00e1 proporcional a la masa del objeto: \\begin{equation} g = m\\Delta v \\end{equation} \\begin{equation} g = m\\Delta v \\end{equation} Al igual que en el caso de las fuerzas, el c\u00e1lculo que nos interesar\u00e1 realizar es la obtenci\u00f3n del cambio de velocidad a partir del impulso: \\begin{equation} \\Delta v = \\frac{1}{m}g \\end{equation} \\begin{equation} \\Delta v = \\frac{1}{m}g \\end{equation} Considerando \\Delta v = v' - v \\Delta v = v' - v , donde v v es la velocidad previa a la aplicaci\u00f3n del impulso, y v' v' es la velocidad resultante, tenemos: \\begin{equation} v' = v + \\frac{1}{m}g \\end{equation} \\begin{equation} v' = v + \\frac{1}{m}g \\end{equation} Al igual que en el caso de las fuerzas, al aplicar un impulso tambi\u00e9n podremos indicar el punto del cuerpo en el que lo aplicamos. Las unidades en este caso son N\u00b7m\u00b7s N\u00b7m\u00b7s (es decir, kg\\frac{m^2}{s} kg\\frac{m^2}{s} ). Velocidad \u00b6 Adem\u00e1s de aplicar fuerzas e impulsos sobre los cuerpos, tambi\u00e9n podemos consultar o modificar su velocidad directamente. En el caso de la velocidad trabajaremos con \\frac{m}{s} \\frac{m}{s} . Esto puede ser \u00fatil en cuerpos de tipo cinem\u00e1tico , en los que las fuerzas no tienen efecto (al tener masa infinita), pero que si que pueden mantener una velocidad constante, como por ejemplo un proyectil. De la misma forma, tambi\u00e9n podemos consultar y modificar la velocidad angular. En estos casos las unidades son \\frac{radianes}{s} \\frac{radianes}{s} . Posici\u00f3n \u00b6 Dado un cuerpo, cuyo centro de masas est\u00e1 posicionado en \\mathbf{p}_0 \\mathbf{p}_0 y con rotaci\u00f3n \\Theta \\Theta (matriz de rotaci\u00f3n), puede interesarnos determinar la posici\u00f3n de cualquier otro punto del objeto en el mundo. Supongamos que queremos conocer la posici\u00f3n de un punto cuyas coordenadas locales (respecto al centro de masas) son \\mathbf{p}_{local} \\mathbf{p}_{local} . La posici\u00f3n global de dicho punto vendr\u00e1 determinada por: \\mathbf{p}_{global} = \\Theta \\mathbf{p}_{local} + \\mathbf{p}_0 \\mathbf{p}_{global} = \\Theta \\mathbf{p}_{local} + \\mathbf{p}_0 Para simplificar este c\u00e1lculo, normalmente los motores nos permitir\u00e1n convertir las coordenadas locales de un cuerpo, a coordenadas globales del mundo. Detecci\u00f3n de colisiones \u00b6 Hemos comentado que dentro de la simulaci\u00f3n f\u00edsica existen interacciones entre los diferentes objetos del mundo. Encontramos diferentes formas de consultar las colisiones de los objetos del mundo con otros objetos y otros elementos. Colisi\u00f3n con un punto del mundo \u00b6 Un test sencillo consiste en comprobar si la forma de un cuerpo ocupa un determinado punto del mundo. Esto es \u00fatil por ejemplo cuando tocamos sobre la pantalla t\u00e1ctil, para comprobar si en el punto sobre el que hemos pulsado hay un determinado objeto. En el caso de motores 3D, se puede comprobar si hay alg\u00fan cuerpo dentro de una determinada \u00e1rea del mundo (\u00fatil por ejemplo para saber los cuerpos que han sido afectados por una explosi\u00f3n). Trazado de rayos \u00b6 Otro test disponible es el trazado de rayos. Consiste en lanzar un rayo desde una determinada posici\u00f3n del mundo en una determinada direcci\u00f3n y comprobar cu\u00e1l es el primer objeto del mundo f\u00edsico con el que impacta. Podremos lanzar un rayo para comprobar si impacta contra un objeto determinado, o bien para obtener una lista de objetos con los que impacta. Esto es utilizado de forma habitual en casos como los siguientes: Disparos . Al ser la bala un objeto extremadamente r\u00e1pido, no es conveniente simular su movimiento con el motor de f\u00edsicas, ya que podr\u00eda producirse el efecto conocido como tunneling , atravesando objetos al dar un gran salto en su posici\u00f3n de una iteraci\u00f3n a la siguiente. En este caso es mejor simplemente considerar la bala como algo instant\u00e1neo, y encontrar en el mismo momento en que se dispara el objeto con el que impactar\u00eda lanzando un rayo. Visibilidad . Si queremos saber si un personaje ve a otro, podremos lanzar un rayo del primero al segundo, y ver si el rayo impacta antes con otro objeto. En tal caso, quiere decir que hay algo que se lo tapa, y por lo tanto no lo ver\u00e1. Seleccionar objetos en 3D . Cuando pulsamos sobre la pantalla en un juego 3D, no es trivial saber sobre qu\u00e9 objetos estamos tocando, ya que tenemos unas coordenadas 2D del touch en pantalla, pero los objetos del mundo est\u00e1n en un espacio 3D. Podemos para ello lanzar un rayo desde el punto de vista de la c\u00e1mara hacia la posici\u00f3n en la que estamos tocando en un plano perpendicular a la c\u00e1mara, y ver con qu\u00e9 objetos impacta. Para lanzar un rayo, normalmente indicaremos: Punto desde el que lanzamos el rayo. Direcci\u00f3n ( vector ) en la que lo lanzamos. Distancia m\u00e1xima de alcance. Como salida tenemos la siguiente informaci\u00f3n del punto de impacto: Cuerpo : Objeto del mundo sobre el que ha impactado el rayo. Fracci\u00f3n : Tomando como referencia el vector desde el punto inicial al final del rayo, nos indica en qu\u00e9 fracci\u00f3n de dicho vector se encuentra el punto de impacto. Normal : Nos indica la direcci\u00f3n normal de la superficie sobre la que ha impactado el rayo. De esta forma podremos saber si hemos impactado de lado o de frente, y as\u00ed aplicar distinto nivel de da\u00f1o en cada caso, o aplicar una fuerza al objeto en la direcci\u00f3n en la que haya recibido el impacto. Colisiones entre cuerpos \u00b6 Podemos recibir notificaciones cada vez que se produzca un contacto entre objetos del mundo, para as\u00ed por ejemplo aumentar el da\u00f1o recibido. Para esto, normalmente deberemos implementar un listener al que nos llegar\u00e1n avisos de los contactos entre cuerpos. Cada vez que se produzca un contacto, de \u00e9ste sabremos: Cuerpos involucrados . En cada contacto participar\u00e1n dos cuerpos (A y B), cuyo orden es arbitrario Velocidad del impacto . La velocidad relativa a la que han impactado los cuerpos nos permitir\u00e1 aplicar un diferente nivel de da\u00f1o seg\u00fan la fuerza del impacto. Normal del impacto . Tambi\u00e9n podremos saber en qu\u00e9 direcci\u00f3n se ha producido el impacto. Un choque frontal producir\u00e1 mas da\u00f1o que uno con un determinado \u00e1ngulo. A partir de esta informaci\u00f3n, el motor resolver\u00e1 el contacto aplicando la fuerza de reacci\u00f3n oportuna, aunque en ocasiones nos permitir\u00e1 personalizar la forma en la que se resuelven los contactos. Como hemos comentado anteriormente, el c\u00e1lculo de las colisiones y puntos de contacto entre dos cuerpos puede llegar a ser muy complejo, dependiendo de su forma. Por ello, el motor debe optimizar en la medida de los posible la forma de realizar estos c\u00e1lculos, y no realizar m\u00e1s comprobaciones de las necesarias. En primer lugar, s\u00f3lo realizar\u00e1 comprobaciones de colisi\u00f3n en las que uno de los cuerpos sea din\u00e1mico. Dado que los cuerpos est\u00e1ticos y cinem\u00e1ticos no pueden recibir fuerzas de reacci\u00f3n, no tiene sentido calcular colisiones entre ellos si no interviene un cuerpo din\u00e1mico. En la siguiente tabla se indican las comprobaciones que se realizan: Est\u00e1tico Cinem\u00e1tico Din\u00e1mico Est\u00e1tico No No Si Cinem\u00e1tico No No Si Din\u00e1mico Si Si Si Adem\u00e1s, tambi\u00e9n podremos personalizar entre qu\u00e9 grupos de cuerpos se realizan las comprobaciones mediante el uso del layering , como veremos m\u00e1s adelante, para filtrar a\u00fan m\u00e1s las comprobaciones a realizar. Sensores \u00b6 En el punto anterior hemos visto c\u00f3mo detectar colisiones entre cuerpos que producen una respuesta (fuerza de reacci\u00f3n). En algunos casos nos interesa que en el motor de f\u00edsicas se detecten contactos con un cuerpo, pero que no produzcan una respuesta en la simulaci\u00f3n f\u00edsica. Por ejemplo, podr\u00edamos tener una zona en la que al entrar alg\u00fan cuerpo queramos que se abra alguna puerta. Esto podemos conseguirlo mediante sensores. Al ser un sensor, otros objetos atravesar\u00e1n dicho cuerpo, pero recibiremos notificaciones cuando esto ocurra. En el caso de los sensores las comprobaciones cambian ligeramente respecto a las colisiones . En el caso de las colisiones no ten\u00eda sentido hacer la comprobaci\u00f3n entre dos cuerpos cinem\u00e1ticos, ya que no se les va a aplicar fuerza de reacci\u00f3n para resolver la colisi\u00f3n, pero si que nos puede interesar saber si est\u00e1n en contacto. Por lo tanto, en caso de los sensores normalmente se amplian las comprobaciones a realizar: Est\u00e1tico Cinem\u00e1tico Din\u00e1mico Est\u00e1tico No Si Si Cinem\u00e1tico Si Si Si Din\u00e1mico Si Si Si Layering \u00b6 El layering es una caracter\u00edstica de los motores de f\u00edsica que nos pemitir\u00e1 indicar qu\u00e9 comprobaciones de colisi\u00f3n debe hacer el motor. Para ello, se definen diferentes capas o categor\u00edas de objetos. Por ejemplo \"Personaje\" , \"Enemigos\" y \"Balas\" . Podemos asignar a cada cuerpo del motor, una de estas categor\u00edas. Con esto, podemos proporcionar una matriz que nos indique qu\u00e9 categor\u00edas se comprueban con cu\u00e1les otras. Por ejemplo, en el caso anterior podr\u00edamos tener algo como: Personaje Enemigos Balas Personaje No Si Si Enemigos Si No Si Balas Si Si No En este caso, nos interesa saber si un enemigo toca a nuestro personaje (nos mata), o si una bala toca al personaje o a un enemigo (lo matar\u00eda), pero no nos interesa saber si un enemigo toca a otro, ni si una bala toca a otra. Modificando esta matriz podr\u00edamos conseguir de forma sencilla por ejemplo que una bala mate a los enemigos pero no a nuestro personaje. En algunos motores el layering se implemente como una matriz a nivel global, mientras que en otros se trata de una m\u00e1scara binaria para cada cuerpo, en la que indicamos con qu\u00e9 categor\u00edas podr\u00eda colisionar.","title":"F\u00edsicas"},{"location":"motor_de_fisicas.html#motores-de-fisicas","text":"Un tipo de juegos que ha tenido una gran proliferaci\u00f3n en el mercado de aplicaciones para m\u00f3viles son aquellos juegos basados en f\u00edsicas. Estos juegos son aquellos en los que el motor realiza una simulaci\u00f3n f\u00edsica de los objetos en pantalla, siguiendo las leyes de la cinem\u00e1tica y la din\u00e1mica. Es decir, los objetos de la pantalla est\u00e1n sujetos a gravedad, cada uno de ellos tiene una masa, y cuando se produce una colisi\u00f3n entre ellos se produce una fuerza de reacci\u00f3n que depender\u00e1 de su velocidad y su masa. El motor de f\u00edsicas se encarga de realizar toda esta simulaci\u00f3n, y nosotros s\u00f3lo deberemos encargarnos de proporcionar las propiedades de los objetos del mundo. Uno de los juegos que m\u00e1s se ha popularizado, cuya mec\u00e1nica est\u00e1 basada casi al completo en f\u00edsicas es Angry Birds (desarrollado por Rovio ).","title":"Motores de f\u00edsicas"},{"location":"motor_de_fisicas.html#componentes-del-motor-de-fisicas","text":"Los componentes b\u00e1sicos que nos aporta un motor de f\u00edsicas son los siguientes: Body : Representa un cuerpo r\u00edgido. Estos son los tipos de objetos que tendremos en el mundo f\u00edsico simulado. Cada cuerpo tendr\u00e1 una posici\u00f3n y velocidad. Los cuerpos se ver\u00e1n afectados por la gravedad del mundo, y por la interacci\u00f3n con los otros cuerpos. Cada cuerpo tendr\u00e1 una serie de propiedades f\u00edsicas, como su masa, su centro de gravedad, su coeficiente de fricci\u00f3n o su forma ( shape ). Shape : Una de las principales caracter\u00edsticas que deberemos tener en cuenta de los cuerpos f\u00edsicos es su forma . Es importante destacar que el aspecto gr\u00e1fico de los nodos se define de forma independiente de la forma que tendr\u00e1 en el mundo f\u00edsico, pero deberemos intentar que sean lo m\u00e1s parecidos posibles. Joint : Nos permite definir uniones entre diferentes cuerpos. Por ejemplo, podemos hacer que un cuerpo est\u00e9 conectado a otro mediante un resorte, o que pueda moverse s\u00f3lo en un determinado eje. World : Representa el mundo f\u00edsico en el que tendr\u00e1 lugar la simulaci\u00f3n. A \u00e9l se a\u00f1adir\u00e1n todos los cuerpos y se encargar\u00e1 de realizar la simulaci\u00f3n f\u00edsica sobre ellos, aplicando las correspondientes fuerzas y actualizando su velocidad y posici\u00f3n en el mundo. Una de las principales propiedades del mundo es la gravedad.","title":"Componentes del motor de f\u00edsicas"},{"location":"motor_de_fisicas.html#cuerpos-fisicos","text":"Vamos en primer lugar a estudiar los diferentes tipos de cuerpos y sus porpiedades.","title":"Cuerpos f\u00edsicos"},{"location":"motor_de_fisicas.html#tipos-de-cuerpos","text":"En los motores de f\u00edsicas encontraremos tres tipos diferentes de cuerpos: Din\u00e1micos : Est\u00e1n sometidos a las leyes f\u00edsicas, y tienen una masa concreta y finita. Estos cuerpos se ven afectados por la gravedad y por la interacci\u00f3n con los dem\u00e1s cuerpos. Est\u00e1ticos : Son cuerpos que permanecen siempre en la misma posici\u00f3n. Equivalen a cuerpos con masa infinita. Por ejemplo, podemos hacer que el escenario sea est\u00e1tico. Es importante no mover aquellos cuerpos que hayan sido marcados como est\u00e1ticos, ya que el motor podr\u00eda no responder de forma correcta (\u00e9ste realiza diferentes optimizaciones que asumen que no se van a mover). Cinem\u00e1ticos : Al igual que los cuerpos est\u00e1ticos tienen masa infinita y no se ven afectados por otros cuerpos ni por la gravedad. Sin embargo, en esta caso no tienen una posici\u00f3n fija, sino que podemos moverlos por el mundo, y podemos darles una velocidad fija. Nos son \u00fatiles por ejemplo para proyectiles.","title":"Tipos de cuerpos"},{"location":"motor_de_fisicas.html#forma-de-los-cuerpos","text":"Dependiendo de si tenemos un motor 2D o 3D, las formas de los cuerpos del motor f\u00edsico ser\u00e1n distintas. Seg\u00fan la forma de los cuerpos, ser\u00e1 para el motor m\u00e1s o menos complejo calcular las colisiones entre ellos. A continuaci\u00f3n mostramos, ordenadas de menor a mayor complejidad , las formas que encontramos habitualmente en un motor de f\u00edsicas 2D: C\u00edrculos . Es la forma m\u00e1s sencilla. Se crea simplemente indicando su centro y su radio, y el c\u00e1lculo de colisiones con ellos es muy eficiente. Pol\u00edgonos . Nos permite crear formas arbitrarias convexas. Es importante destacar que los pol\u00edgonos siempre deber\u00e1n ser convexos y cerrados . El c\u00e1lculo de colisiones con formas c\u00f3ncavas es demasiado complejo para el motor de f\u00edsicas. Un tipo de pol\u00edgono muy habitual ser\u00e1 la forma de caja , muchas veces el motor nos dar\u00e1 atajos para crear dicha forma. Formas compuestas . Si ninguno de los tipos anteriores de formas se adapta a nuestras necesidades, como por ejemplo en el caso de necesitar una forma c\u00f3ncava, podemos definir la forma del cuerpo como una composici\u00f3n de form\u00e1s b\u00e1sicas. Esto ser\u00e1 \u00fatil para cuerpos din\u00e1micos con formas complejas. Aristas . Las aristas ( edges ) son segmentos de l\u00ednea que normalmente se utilizan para construir la geometr\u00eda del escenario est\u00e1tico, que podr\u00e1 tener una forma arbitraria. Este tipo de cuerpo y el siguiente, por poder presentar concavidades , s\u00f3lo podr\u00e1 ser utilizado para cuerpos est\u00e1ticos . El c\u00e1lculo de colisiones entre dos cuerpos c\u00f3ncavos es demasiado complejo, por lo que no debe haber cuerpos din\u00e1micos con esas formas (el motor necesita comprobar las colisiones entre pares de cuerpos din\u00e1micos, pero nunca entre dos cuerpos est\u00e1ticos, al no poder moverse). Cadenas . Las cadenas nos permiten unir varias aristas para as\u00ed definir la geometr\u00eda est\u00e1tica del escenario y evitar que se puedan producir \"baches\" en las juntas entre diferentes aristas. En el caso 3D tenemos: Esferas . Es la forma m\u00e1s sencilla en este caso. Dado el centro y el radio de la esfera, para saber si colisiona con otra simplemente tendremos que calculas si la distancia entre sus centros es menor que la suma de sus radios. Cajas . En el caso 3D, en el segundo lugar de complejidad encontramos las cajas. Dependiendo del motor, podr\u00edamos encontrar tras este tipo otras clases de formas geom\u00e9tricas predefinidas, como cilindros y conos. Maya convexa . Si en el motor gr\u00e1fico tenemos una maya 3D, podemos utilizar como forma f\u00edsica asociada un recubrimiento convexo ( convex hull ) de dicha maya. Es decir, cogemos la misma forma pero eliminando las concavidades. Formas compuestas . En algunos casos no podemos eliminar las concavidades de un cuerpo f\u00edsico, pensemos por ejemplo en la forma de una silla, con sus patas, respaldo y asiento. En estos casos, si necesitamos que dicho cuerpo se comporte como din\u00e1mico, podemos crear su forma como una composici\u00f3n de formas c\u00f3ncavas de los tipos anteriores (por ejemplo, una caja por cada pata, otra para el asiento, y otra para el respaldo). Maya c\u00f3ncava . El uso de mayas c\u00f3ncavas, al igual que ocurr\u00eda en el caso 2D con los edges y cadenas, queda reservado exclusivamente a los cuerpos est\u00e1ticos. Puede utilizarse, por ejemplo, para definir la geometr\u00eda f\u00edsica del escenario est\u00e1tico del juego.","title":"Forma de los cuerpos"},{"location":"motor_de_fisicas.html#propiedades-de-los-cuerpos","text":"Los cuerpos y tienen una serie de propiedades que nos permiten definir su comportamiento en la simulaci\u00f3n f\u00edsica. Hemos hablado sobre la forma de los cuerpos. Vamos a ver ahora otras propiedades f\u00edsicas que podemos configurar: Masa . La masa determinar\u00e1 cu\u00e1nta fuerza deberemos aplicar al objeto para producir una aceleraci\u00f3n. Cuanto mayor sera la masa, m\u00e1s nos costar\u00e1 modificar su velocidad al aplicar una fuerza. Cabe destacar el caso extremos de los cuerpos est\u00e1ticos o cinem\u00e1ticos, que tienen masa infinita. Es decir, las fuerzas no tienen efecto sobre ellos. Centro de masas . Podemos establecer qu\u00e9 punto ser\u00e1 el centro de masas del objeto. Por defecto ser\u00e1 su centro, pero podemos modificarlo. Cuando apliquemos una fuerza en el centro de masas, se producir\u00e1 una aceleraci\u00f3n lineal. Sin embargo, si se aplica una fuerza en otro punto, la aceleraci\u00f3n tendr\u00e1 tanto una componente lineal como angular (el objeto se mover\u00e1 y girar\u00e1). Momento de inercia . Es el equivalente a la masa, pero en el caso de aplicar una fuerza angular. Nos da una indicaci\u00f3n sobre cu\u00e1nto nos cuesta girar un objeto. Los objetos que tienen su masa concentrada alrededor del centro de masas ser\u00e1n m\u00e1s f\u00e1ciles de girar que aquellos en los que est\u00e1 distribuida a mayor distancia del centro. Resistencia al aire . Para cada cuerpo podemos indicar una constante de resistencia al aire ( damping ), tanto lineal como angular. La resistencia al aire es la fuerza que har\u00e1 que la velocidad del objeto disminuya, aunque no est\u00e9 en contacto con ning\u00fan otro cuerpo. Cu\u00e1nta mayor sea la velocidad, m\u00e1s fuerza ejercer\u00e1 la resistencia al aire para pararlo. Es recomendable indicar una resistencia al aire para que los cuerpos no se muevan (o roten) de forma indefinida. Fricci\u00f3n . La fricci\u00f3n es la fuerza que hace que un objeto se pare al deslizarse sobre otro, debido a rugosidades de la superficie. A diferencia de la resistencia al aire, esta fuerza s\u00f3lo se ejercer\u00e1 cuando dos cuerpos est\u00e9n en contacto. Restituci\u00f3n . La restituci\u00f3n nos indica la forma en la que responder\u00e1 un objeto al colisionar con otro, permitiendo que los objetos permanezcan juntos o reboten. Una restituci\u00f3n 0 indica que el objeto no rebotar\u00e1 el colisionar, mientras que el valor 1 indica que al colisionar rebota y en el rebote se restituye toda la velocidad que ten\u00eda en el momento previo a la colisi\u00f3n.","title":"Propiedades de los cuerpos"},{"location":"motor_de_fisicas.html#simulacion-fisica","text":"Una vez vistas las propiedades de los cuerpos del mundo f\u00edsico, vamos a ver como realiza el motor la simulaci\u00f3n. Es importante destacar que la simulaci\u00f3n se realiza de forma discreta. Es decir, en cada iteraci\u00f3n del ciclo del juego, se simula la aplicaci\u00f3n de las leyes de la cinem\u00e1tica y de la din\u00e1mica a todos los cuerpos del mundo, considerando el tiempo transcurrido desde la iteraci\u00f3n anterior ( delta time ), para la actualizaci\u00f3n de la posici\u00f3n y velocidad de los objetos. Recomendaci\u00f3n : En el caso de la simulaci\u00f3n f\u00edsica conviene utilizar un delta time fijo, para as\u00ed obtener resultados predecibles en la simulaci\u00f3n (por ejemplo 60 fps ), independientemente del frame rate del render gr\u00e1fico , que podr\u00eda ser variable. Normalmente los motores se encargan de gestionar esto por nosotros. Sobre los cuerpos del mundo f\u00edsico actuar\u00e1n una serie de fuerzas: Gravedad . La fuerza de gravedad es una propiedad del mundo f\u00edsico que podremos alterar, y que por defecto se aplicar\u00e1 sobre todos los cuerpos del mundo, aunque podremos excluir determinados cuerpos de forma manual. Resistencia al aire . Dependiendo de la propiedad damping de cada objeto, se aplicar\u00e1 sobre ellos una fuerza de resistencia al aire, proporcional a su velocidad y a su factor de damping , pero en la direcci\u00f3n contraria a su movimient. Fuerzas de reacci\u00f3n . Cuando se produzca una colisi\u00f3n entre objetos, se producir\u00e1 una fuerza de reacci\u00f3n entre ellos, que depender\u00e1 de su propiedad de restituci\u00f3n . Seg\u00fan dicha propiedad, esta fuerza har\u00e1 simplemente que queden paren de moverse, o que reboten. Fuerzas aplicadas en el c\u00f3digo . Podemos aplicar fuerzas sobre los diferentes cuerpos del mundo, por ejemplo para empujar una caja o lanzar una roca. El motor de simulaci\u00f3n f\u00edsica, a partir de las fuerzas aplicadas a los cuerpos y las propiedades de los mismos, calcular\u00e1 la aceleraci\u00f3n producida en cada caso. Con ello, aplicando las ecuaciones de la cinem\u00e1tica y de la din\u00e1mica actualizar\u00e1 la velocidad y la posici\u00f3n de los mismos. Tras realizar la actualizaci\u00f3n, comprobar\u00e1 si se producen colisiones entre los cuerpos. En tal caso, deber\u00e1 resolver la colisi\u00f3n, aplicando la fuerza de reacci\u00f3n correspondiente. Vamos a ver con mayor detalle la forma en la que se aplican fuerzas e impulsos sobre los cuerpos del mundo.","title":"Simulaci\u00f3n f\u00edsica"},{"location":"motor_de_fisicas.html#fuerza-y-masa","text":"Siguiendo la segunda ley de Newton, la fuerza que se debe aplicar sobre un objeto para producir una determinada aceleraci\u00f3n se calcula de la siguiente forma: \\mathbf{f} = m\\mathbf{a} \\mathbf{f} = m\\mathbf{a} Sin embargo, en nuestro motor de f\u00edsicas lo que realmente nos interesa es conocer la aceleraci\u00f3n producida tras aplicar una fuerza, calculada como: \\mathbf{a} = \\frac{1}{m}\\mathbf{f} \\mathbf{a} = \\frac{1}{m}\\mathbf{f} Podemos ver que aqu\u00ed multiplicamos la fuerza por la inversa de la masa . Dado que este c\u00e1lculo es frecuente, para evitar tener que calcular la inversa en cada momento, normalmente los motores almacenan la masa inversa de los cuerpos, en lugar de almacenar la masa. Almacenar la masa inversa tiene una ventaja importante. Para hacer que un cuerpo sea est\u00e1tico (que no se vea afectado por las fuerzas que sobre \u00e9l se ejerzan) lo que haremos es dar a ese cuerpo masa infinita. Este valor infinito podr\u00eda crear dificultades en el c\u00f3digo, y la necesidad de tratar casos especiales. Si trabajamos \u00fanicamente con masa inversa, bastar\u00e1 con darle un valor 0 a la masa inversa para hacer el cuerpo est\u00e1tico. Adem\u00e1s de la masa, el motor nos permitir\u00e1 especificar el centro de masas y el momento de inercia de los cuerpos. El momento de inercia nos permitir\u00e1 indicar qu\u00e9 par de fuerzas ( torque ) deberemos ejercer para producir una determinada aceleraci\u00f3n angular, de la misma forma que la masa nos indica qu\u00e9 fuerza debemos ejercer para producir una determinada aceleraci\u00f3n lineal.","title":"Fuerza y masa"},{"location":"motor_de_fisicas.html#torque-y-momento-de-inercia","text":"El torque \\tau \\tau es a la aceleraci\u00f3n angular \\alpha \\alpha lo que la fuerza es a la aceleraci\u00f3n lineal. En este caso, en lugar de tener en cuenta \u00fanicamente la masa del objeto, deberemos tener en cuenta su momento de inercia I I , en el que no s\u00f3lo tenemos la masa, sino c\u00f3mo est\u00e1 repartida a lo largo del cuerpo, lo cual influir\u00e1 en c\u00f3mo las fuerzas afectar\u00e1n a la rotaci\u00f3n. \\tau = I \\alpha \\tau = I \\alpha Por ejemplo, si tenemos un objeto con forma de bast\u00f3n, habr\u00e1 que hacer menos fuerza para que gire alrededor de su eje principal que alrededor de otro eje. Por lo tanto, el momento de inercia no tendr\u00e1 siempre el mismo valor para un determinado objeto, sino que depender\u00e1 del eje de rotaci\u00f3n. El momento de inercia codifica c\u00f3mo est\u00e1 repartida la masa del objeto alrededor de su centro. Para simplificar, supongamos que nuestro cuerpo r\u00edgido est\u00e1 compuesto de n n part\u00edculas cada una de ellas con una determinada masa m_i m_i , y situada en una posici\u00f3n (x_i, y_i) (x_i, y_i) respecto al centro de masas del cuerpo. El momento de inercia se calcular\u00eda de la siguiente forma (medido en kg\u00b7m kg\u00b7m ): I = \\sum^{n}_{i=1} m_i \\sqrt{x_i^2 + y_i^2} I = \\sum^{n}_{i=1} m_i \\sqrt{x_i^2 + y_i^2} Es decir, este coeficiente no tiene en cuenta s\u00f3lo la masa, sino tambi\u00e9n lo alejada que est\u00e1 la masa respecto del centro del centro. De esta forma, har\u00e1 falta hacer m\u00e1s fuerza para girar un cuerpo cuando la distribuci\u00f3n de masa est\u00e9 alejada del centro. Los motores de f\u00edsicas por defecto calcular\u00e1n de forma autom\u00e1tica tanto el centro de masas como el momento de inercia a partir de la densidad (o masa) y de la forma que hemos asignado al cuerpo, y no necesitaremos establecer estos datos de forma manual a no ser que busquemos un comportamiento distinto.","title":"Torque y momento de inercia"},{"location":"motor_de_fisicas.html#acumulador-de-fuerzas","text":"Normalmente sobre un cuerpo actuar\u00e1n varias fuerzas. Siguiendo el principio de D'Alembert , un conjunto de fuerzas F=\\{f_1, f_2, ... f_{|F|}\\} F=\\{f_1, f_2, ... f_{|F|}\\} actuando sobre un objeto pueden ser sustituidas por una \u00fanica fuerza calculada como la suma de las fuerzas de F F : f = \\sum^{|F|}_{i=1} f_i f = \\sum^{|F|}_{i=1} f_i Para ello, cada objeto contar\u00e1 con un acumulador de fuerzas f f donde se ir\u00e1n sumando todas las fuerzas que act\u00faan sobre \u00e9l (gravedad, resistencia al aire, interacci\u00f3n con otros objetos, etc). Cuando llegue el momento de realizar la actualizaci\u00f3n de posici\u00f3n y velocidad, la aceleraci\u00f3n del objeto se calcular\u00e1 a partir de la fuerza que indique dicho acumulador f f . Deberemos llevar cuidado con la discretizaci\u00f3n del tiempo. Si una gran fuerza se aplica durante un periodo de tiempo muy breve (por ejemplo para disparar una bala), si la aceleraci\u00f3n producida se extiende a todo el delta time el incremento de velocidad producido puede ser desmesurado. Por este motivo, estas fuerzas que se aplican en un instante puntual de tiempo se tratar\u00e1n como impulsos .","title":"Acumulador de fuerzas"},{"location":"motor_de_fisicas.html#aplicacion-de-fuerzas","text":"El caso m\u00e1s com\u00fan de fuerza aplicada a los objetos es la gravedad . Si queremos hacer una simulaci\u00f3n realista deber\u00edamos aplicar una fuerza que produzca una aceleraci\u00f3n de a_{gravedad}=-9.8 \\frac{m}{s^2} a_{gravedad}=-9.8 \\frac{m}{s^2} sobre nuestros objetos en el eje y y (normalmente se redondea en a_{gravedad}=10 a_{gravedad}=10 . Considerando el vector \\mathbf{a}_{gravedad} = (0, a_{gravedad}) \\mathbf{a}_{gravedad} = (0, a_{gravedad}) tenemos: \\mathbf{f}_{gravedad} = \\mathbf{a}_{gravedad}m \\mathbf{f}_{gravedad} = \\mathbf{a}_{gravedad}m Tambi\u00e9n se puede tratar como una fuerza la \"resistencia al aire\" ( damping ) que produce que los objetos vayan frenando y no se muevan indefinidamente. Un modelo simplificado para esta fuerza que se suele utilizar en videojuegos es el siguiente: \\mathbf{f}_{resistencia} = -\\mathbf{\\hat{v}}(k_{damping} |\\mathbf{v}| \\mathbf{f}_{resistencia} = -\\mathbf{\\hat{v}}(k_{damping} |\\mathbf{v}| Donde k_{damping} k_{damping} es la constante de damping especificada para el cuerpo, y \\mathbf{\\hat{v}} \\mathbf{\\hat{v}} el vector de velocidad normalizado (vector unitario con la direcci\u00f3n de la velocidad). Podemos ver que la fuerza act\u00faa en el sentido opuesto a la velocidad del objeto (lo frena), y con una magnitud proporcional a la velocidad. A parte de las fuerzas de gravedad, resistencia al aire, y las fuerzas ejercidas entre cuerpos en contacto, tambi\u00e9n podemos aplicar una fuerza manualmente sobre un determinado cuerpo. A la hora de aplicar una fuerza debemos indicar: Vector de fuerza a aplicar Punto del cuerpo (opcional) donde aplicarla. En caso de no especificarlo, por defecto se considerar\u00e1 que ser\u00e1 su centro de masas. Las unidades en las que especificaremos la fuerza son Newtons ( N = \\frac{kg\u00b7m}{s^2} N = \\frac{kg\u00b7m}{s^2} ). Si el punto del objeto al que aplicamos la fuerza no es su centro de masas, la fuerza producir\u00e1 adem\u00e1s que el objeto rote (a no ser que en sus propiedades hayamos indicado que no puede rotar).","title":"Aplicaci\u00f3n de fuerzas"},{"location":"motor_de_fisicas.html#aplicacion-de-un-par-de-fuerzas-torque","text":"Podemos tambi\u00e9n aplicar un par de fuerzas ( torque ) para producir una rotaci\u00f3n del objeto alrededor de su centro de masas sin producir una traslaci\u00f3n. El torque se indica en N\u00b7m N\u00b7m .","title":"Aplicaci\u00f3n de un par de fuerzas (torque)"},{"location":"motor_de_fisicas.html#impulsos","text":"Los impulsos producen un cambio instant\u00e1neo en la velocidad de un objeto. Podemos ver los impulsos respecto a la velocidad como vemos a las fuerzas respecto a la aceleraci\u00f3n. Si aplicar una fuerza a un cuerpo produce una aceleraci\u00f3n, aplicar un impulso produce un cambio de velocidad. Una diferencia importante es que no puede haber aceleraci\u00f3n si no se aplica ninguna fuerza, mientras que si que puede haber velocidad si no se aplican impulsos, un impulso lo que provoca es un cambio en la velocidad. El impulso g g necesario para producir un cambio de velocidad \\Delta v \\Delta v ser\u00e1 proporcional a la masa del objeto: \\begin{equation} g = m\\Delta v \\end{equation} \\begin{equation} g = m\\Delta v \\end{equation} Al igual que en el caso de las fuerzas, el c\u00e1lculo que nos interesar\u00e1 realizar es la obtenci\u00f3n del cambio de velocidad a partir del impulso: \\begin{equation} \\Delta v = \\frac{1}{m}g \\end{equation} \\begin{equation} \\Delta v = \\frac{1}{m}g \\end{equation} Considerando \\Delta v = v' - v \\Delta v = v' - v , donde v v es la velocidad previa a la aplicaci\u00f3n del impulso, y v' v' es la velocidad resultante, tenemos: \\begin{equation} v' = v + \\frac{1}{m}g \\end{equation} \\begin{equation} v' = v + \\frac{1}{m}g \\end{equation} Al igual que en el caso de las fuerzas, al aplicar un impulso tambi\u00e9n podremos indicar el punto del cuerpo en el que lo aplicamos. Las unidades en este caso son N\u00b7m\u00b7s N\u00b7m\u00b7s (es decir, kg\\frac{m^2}{s} kg\\frac{m^2}{s} ).","title":"Impulsos"},{"location":"motor_de_fisicas.html#velocidad","text":"Adem\u00e1s de aplicar fuerzas e impulsos sobre los cuerpos, tambi\u00e9n podemos consultar o modificar su velocidad directamente. En el caso de la velocidad trabajaremos con \\frac{m}{s} \\frac{m}{s} . Esto puede ser \u00fatil en cuerpos de tipo cinem\u00e1tico , en los que las fuerzas no tienen efecto (al tener masa infinita), pero que si que pueden mantener una velocidad constante, como por ejemplo un proyectil. De la misma forma, tambi\u00e9n podemos consultar y modificar la velocidad angular. En estos casos las unidades son \\frac{radianes}{s} \\frac{radianes}{s} .","title":"Velocidad"},{"location":"motor_de_fisicas.html#posicion","text":"Dado un cuerpo, cuyo centro de masas est\u00e1 posicionado en \\mathbf{p}_0 \\mathbf{p}_0 y con rotaci\u00f3n \\Theta \\Theta (matriz de rotaci\u00f3n), puede interesarnos determinar la posici\u00f3n de cualquier otro punto del objeto en el mundo. Supongamos que queremos conocer la posici\u00f3n de un punto cuyas coordenadas locales (respecto al centro de masas) son \\mathbf{p}_{local} \\mathbf{p}_{local} . La posici\u00f3n global de dicho punto vendr\u00e1 determinada por: \\mathbf{p}_{global} = \\Theta \\mathbf{p}_{local} + \\mathbf{p}_0 \\mathbf{p}_{global} = \\Theta \\mathbf{p}_{local} + \\mathbf{p}_0 Para simplificar este c\u00e1lculo, normalmente los motores nos permitir\u00e1n convertir las coordenadas locales de un cuerpo, a coordenadas globales del mundo.","title":"Posici\u00f3n"},{"location":"motor_de_fisicas.html#deteccion-de-colisiones","text":"Hemos comentado que dentro de la simulaci\u00f3n f\u00edsica existen interacciones entre los diferentes objetos del mundo. Encontramos diferentes formas de consultar las colisiones de los objetos del mundo con otros objetos y otros elementos.","title":"Detecci\u00f3n de colisiones"},{"location":"motor_de_fisicas.html#colision-con-un-punto-del-mundo","text":"Un test sencillo consiste en comprobar si la forma de un cuerpo ocupa un determinado punto del mundo. Esto es \u00fatil por ejemplo cuando tocamos sobre la pantalla t\u00e1ctil, para comprobar si en el punto sobre el que hemos pulsado hay un determinado objeto. En el caso de motores 3D, se puede comprobar si hay alg\u00fan cuerpo dentro de una determinada \u00e1rea del mundo (\u00fatil por ejemplo para saber los cuerpos que han sido afectados por una explosi\u00f3n).","title":"Colisi\u00f3n con un punto del mundo"},{"location":"motor_de_fisicas.html#trazado-de-rayos","text":"Otro test disponible es el trazado de rayos. Consiste en lanzar un rayo desde una determinada posici\u00f3n del mundo en una determinada direcci\u00f3n y comprobar cu\u00e1l es el primer objeto del mundo f\u00edsico con el que impacta. Podremos lanzar un rayo para comprobar si impacta contra un objeto determinado, o bien para obtener una lista de objetos con los que impacta. Esto es utilizado de forma habitual en casos como los siguientes: Disparos . Al ser la bala un objeto extremadamente r\u00e1pido, no es conveniente simular su movimiento con el motor de f\u00edsicas, ya que podr\u00eda producirse el efecto conocido como tunneling , atravesando objetos al dar un gran salto en su posici\u00f3n de una iteraci\u00f3n a la siguiente. En este caso es mejor simplemente considerar la bala como algo instant\u00e1neo, y encontrar en el mismo momento en que se dispara el objeto con el que impactar\u00eda lanzando un rayo. Visibilidad . Si queremos saber si un personaje ve a otro, podremos lanzar un rayo del primero al segundo, y ver si el rayo impacta antes con otro objeto. En tal caso, quiere decir que hay algo que se lo tapa, y por lo tanto no lo ver\u00e1. Seleccionar objetos en 3D . Cuando pulsamos sobre la pantalla en un juego 3D, no es trivial saber sobre qu\u00e9 objetos estamos tocando, ya que tenemos unas coordenadas 2D del touch en pantalla, pero los objetos del mundo est\u00e1n en un espacio 3D. Podemos para ello lanzar un rayo desde el punto de vista de la c\u00e1mara hacia la posici\u00f3n en la que estamos tocando en un plano perpendicular a la c\u00e1mara, y ver con qu\u00e9 objetos impacta. Para lanzar un rayo, normalmente indicaremos: Punto desde el que lanzamos el rayo. Direcci\u00f3n ( vector ) en la que lo lanzamos. Distancia m\u00e1xima de alcance. Como salida tenemos la siguiente informaci\u00f3n del punto de impacto: Cuerpo : Objeto del mundo sobre el que ha impactado el rayo. Fracci\u00f3n : Tomando como referencia el vector desde el punto inicial al final del rayo, nos indica en qu\u00e9 fracci\u00f3n de dicho vector se encuentra el punto de impacto. Normal : Nos indica la direcci\u00f3n normal de la superficie sobre la que ha impactado el rayo. De esta forma podremos saber si hemos impactado de lado o de frente, y as\u00ed aplicar distinto nivel de da\u00f1o en cada caso, o aplicar una fuerza al objeto en la direcci\u00f3n en la que haya recibido el impacto.","title":"Trazado de rayos"},{"location":"motor_de_fisicas.html#colisiones-entre-cuerpos","text":"Podemos recibir notificaciones cada vez que se produzca un contacto entre objetos del mundo, para as\u00ed por ejemplo aumentar el da\u00f1o recibido. Para esto, normalmente deberemos implementar un listener al que nos llegar\u00e1n avisos de los contactos entre cuerpos. Cada vez que se produzca un contacto, de \u00e9ste sabremos: Cuerpos involucrados . En cada contacto participar\u00e1n dos cuerpos (A y B), cuyo orden es arbitrario Velocidad del impacto . La velocidad relativa a la que han impactado los cuerpos nos permitir\u00e1 aplicar un diferente nivel de da\u00f1o seg\u00fan la fuerza del impacto. Normal del impacto . Tambi\u00e9n podremos saber en qu\u00e9 direcci\u00f3n se ha producido el impacto. Un choque frontal producir\u00e1 mas da\u00f1o que uno con un determinado \u00e1ngulo. A partir de esta informaci\u00f3n, el motor resolver\u00e1 el contacto aplicando la fuerza de reacci\u00f3n oportuna, aunque en ocasiones nos permitir\u00e1 personalizar la forma en la que se resuelven los contactos. Como hemos comentado anteriormente, el c\u00e1lculo de las colisiones y puntos de contacto entre dos cuerpos puede llegar a ser muy complejo, dependiendo de su forma. Por ello, el motor debe optimizar en la medida de los posible la forma de realizar estos c\u00e1lculos, y no realizar m\u00e1s comprobaciones de las necesarias. En primer lugar, s\u00f3lo realizar\u00e1 comprobaciones de colisi\u00f3n en las que uno de los cuerpos sea din\u00e1mico. Dado que los cuerpos est\u00e1ticos y cinem\u00e1ticos no pueden recibir fuerzas de reacci\u00f3n, no tiene sentido calcular colisiones entre ellos si no interviene un cuerpo din\u00e1mico. En la siguiente tabla se indican las comprobaciones que se realizan: Est\u00e1tico Cinem\u00e1tico Din\u00e1mico Est\u00e1tico No No Si Cinem\u00e1tico No No Si Din\u00e1mico Si Si Si Adem\u00e1s, tambi\u00e9n podremos personalizar entre qu\u00e9 grupos de cuerpos se realizan las comprobaciones mediante el uso del layering , como veremos m\u00e1s adelante, para filtrar a\u00fan m\u00e1s las comprobaciones a realizar.","title":"Colisiones entre cuerpos"},{"location":"motor_de_fisicas.html#sensores","text":"En el punto anterior hemos visto c\u00f3mo detectar colisiones entre cuerpos que producen una respuesta (fuerza de reacci\u00f3n). En algunos casos nos interesa que en el motor de f\u00edsicas se detecten contactos con un cuerpo, pero que no produzcan una respuesta en la simulaci\u00f3n f\u00edsica. Por ejemplo, podr\u00edamos tener una zona en la que al entrar alg\u00fan cuerpo queramos que se abra alguna puerta. Esto podemos conseguirlo mediante sensores. Al ser un sensor, otros objetos atravesar\u00e1n dicho cuerpo, pero recibiremos notificaciones cuando esto ocurra. En el caso de los sensores las comprobaciones cambian ligeramente respecto a las colisiones . En el caso de las colisiones no ten\u00eda sentido hacer la comprobaci\u00f3n entre dos cuerpos cinem\u00e1ticos, ya que no se les va a aplicar fuerza de reacci\u00f3n para resolver la colisi\u00f3n, pero si que nos puede interesar saber si est\u00e1n en contacto. Por lo tanto, en caso de los sensores normalmente se amplian las comprobaciones a realizar: Est\u00e1tico Cinem\u00e1tico Din\u00e1mico Est\u00e1tico No Si Si Cinem\u00e1tico Si Si Si Din\u00e1mico Si Si Si","title":"Sensores"},{"location":"motor_de_fisicas.html#layering","text":"El layering es una caracter\u00edstica de los motores de f\u00edsica que nos pemitir\u00e1 indicar qu\u00e9 comprobaciones de colisi\u00f3n debe hacer el motor. Para ello, se definen diferentes capas o categor\u00edas de objetos. Por ejemplo \"Personaje\" , \"Enemigos\" y \"Balas\" . Podemos asignar a cada cuerpo del motor, una de estas categor\u00edas. Con esto, podemos proporcionar una matriz que nos indique qu\u00e9 categor\u00edas se comprueban con cu\u00e1les otras. Por ejemplo, en el caso anterior podr\u00edamos tener algo como: Personaje Enemigos Balas Personaje No Si Si Enemigos Si No Si Balas Si Si No En este caso, nos interesa saber si un enemigo toca a nuestro personaje (nos mata), o si una bala toca al personaje o a un enemigo (lo matar\u00eda), pero no nos interesa saber si un enemigo toca a otro, ni si una bala toca a otra. Modificando esta matriz podr\u00edamos conseguir de forma sencilla por ejemplo que una bala mate a los enemigos pero no a nuestro personaje. En algunos motores el layering se implemente como una matriz a nivel global, mientras que en otros se trata de una m\u00e1scara binaria para cada cuerpo, en la que indicamos con qu\u00e9 categor\u00edas podr\u00eda colisionar.","title":"Layering"},{"location":"redes_sociales.html","text":"Redes sociales para videojuegos \u00b6 Existen diferentes redes sociales espec\u00edficas para videojuegos. Estas redes nos permiten ver por ejemplo a qu\u00e9 juegos est\u00e1n jugando nuestros amigos, y los logros y puntuaciones que han conseguido en ellos. Tambi\u00e9n nos permitir\u00e1n entrar en partidas multijugador con nuestros amigos o almacenar los datos de nuestra partida en la nube. Normalmente estas redes est\u00e1n ligadas a la plataforma que utilizamos para jugar ( Game Center para las plataformas de Apple: iOS, Mac, Apple TV; Xbox live para las plataformas de Microsoft: Xbox y Windows; PS Network para las plataformas de Sony: PS3, PS4, PS Vita; Steam en PC, Linux y Mac), pero tambi\u00e9n encontramos redes que podemos utilizar en diferentes plataformas ( Google Play Games , adem\u00e1s de Android, puede utilizarse en iOS o plataformas Web). Tambi\u00e9n existen plataformas sociales para videojuegos ofrecidas por terceros (por ejemplo Game Sparks , Playphone o OpenKit ), siendo la mayor\u00eda de ellos servicios de pago. Vamos a ver c\u00f3mo dise\u00f1ar e implementar logros y marcadores con las principales redes sociales para juegos disponibles en las plataformas m\u00f3viles. Dise\u00f1o de logros y marcadores \u00b6 Logros \u00b6 Los logros son recompensas que podremos obtener cumpliendo determinados retos dentro del juego. Cada logro tiene asociado un reto sobre algo que podemos realizar dentro del juego (por ejemplo, \"Destruye 100 naves enemigas\"). Una vez consigamos realizar el objetivo de este reto seremos recompensados con el logro. Normalmente veremos los logros conseguidos como medallas, y podremos ver tambi\u00e9n los logros obtenidos por otros jugadores y compararlos con los que hemos obtenido nosotros. Bien dise\u00f1ados, los logros podr\u00e1n hacer que los jugadores tengan m\u00e1s incentivos para jugar a nuestro juego. Datos de un logro Para cada logro deberemos proporcionar la siguiente informaci\u00f3n: T\u00edtulo : Texto que se mostrar\u00e1 cuando el usuario consiga el logro. Normalmente se indicar\u00e1 el reto asociado o algo relacionado con \u00e9l. Por ejemplo, podr\u00edamos indicar de forma literal a qu\u00e9 corresponde el logro (por ejemplo \"Consigue 1.000.000 de puntos\"), o algo relacionado (por ejemplo \"Millonario\"). Puntos : Cada logro tiene asociado un n\u00famero de puntos. Cuanto m\u00e1s complejo sera conseguir un logro, m\u00e1s puntos le deber\u00edamos asignar. El n\u00famero total de puntos que podr\u00e1n sumar todos los logros de nuestro juego ser\u00e1 como m\u00e1ximo de 1.000 puntos , por lo que debemos repartir los puntos con cuidado. Deberemos evitar asignar todos los puntos en la primera versi\u00f3n del juego. A partir del an\u00e1lisis de la forma de jugar de los usuarios seguramente se determine la conveniencia de a\u00f1adir nuevos logros que se adapten a su din\u00e1mica de juego. Oculto : Podemos marcar los logros como ocultos para que el usuario no pueda verlos hasta que los haya conseguido (por ejemplo para evitar spoilers o crear \"huevos de pascua\" ). Si el logro no es oculto, podremos ver si t\u00edtulo en la lista de logros del juego, aunque todav\u00eda no lo hayamos obtenido, con lo que tendremos una indicaci\u00f3n de qu\u00e9 tendr\u00edamos que hacer para conseguirlo. Tipos de logros Antes de ver una serie de consejos para el dise\u00f1o de logros, vamos a realizar una clasificaci\u00f3n de tipos de logros que podemos incluir: Logros de progreso : Logros que se conceden conforme progresamos en el juegos. Por ejemplo, \"Completa el nivel 1\" . Estos logros se obtendr\u00e1n siempre que avancemos en el juego. No suponen un reto extra, pero son un buen incentivo para completar el juego. Retos extra : Suponen retos adicionales al mero avance en el juego. Por ejemplo, \"Completa un nivel sin recibir ning\u00fan da\u00f1o\" . Estos logros aumentan la rejugabilidad y alargan la vida del juego. Logros ocultos : Los logros ocultos pueden ser de cualquiera de los tipos anteriores, pero el reto para obtener el logro no es visible hasta que no se haya obtenido. Esto es especialmente \u00faltil en el caso de logros de progreso, para evitar spoilers . Consejos para el dise\u00f1o de logros El dise\u00f1o de logros ser\u00e1 una tarea que normalmente realizaremos en las fases finales del desarrollo del videojuego. Ser\u00e1 importante tener muy bien definidas cu\u00e1les son las mec\u00e1nicas y modos del juego y los contenidos que vamos a ofrecer. A continuaci\u00f3n mostramos una serie de consejos para el dise\u00f1o de logros: La lista de logros debe ser una buena representaci\u00f3n del juego . Es decir, deber\u00edamos tener logros que se consigan con cada modo de juego (por ejemplo, modo \"Historia\" y modo \"Contrarreloj\"), y con cada mec\u00e1nica del juego (por ejemplo, matar enemigos, coger monedas, etc). Deben existir logros para jugadores con diferentes grados de experiencia , desde logros que cualquier jugador pueda conseguir, hasta logros dirigidos a los jugadores m\u00e1s experimentados. Algunos juegos ofrecen como incentivo dar \"logros f\u00e1ciles\", con lo cual pueden conseguir usuarios que desean ganar puntos de logros y as\u00ed competir con sus amigos, pero esto no favorece la experiencia de juego. Utilizar logros ocultos para eventos inesperados , y conseguir as\u00ed sorprender al jugador. Podemos hacer que estos logros aperezcan cuando se realizar algo que no est\u00e1 contemplado en la historia del juego, o cuando el jugador falla en algo. Por ejemplo, dar un logro cuando hemos muerto N veces, o cuando hemos recorrido un escenario en direcci\u00f3n contraria. No ofrecer todos los logros en la primera versi\u00f3n del juego . Es conveniente observar el comportamiento de los jugadores una vez el juego ha sido lanzado, y as\u00ed poder a\u00f1adir nuevos logros que se adapten a lo que los jugadores buscan en el juego. Adem\u00e1s, podremos a\u00f1adir logros para nuevos contenidos que podamos incorporar. Marcadores \u00b6 Los marcadores anotar\u00e1n la puntuaci\u00f3n m\u00e1xima que hemos conseguido en el juego. Adem\u00e1s, no s\u00f3lo nos permitir\u00e1n ver la puntuaci\u00f3n que hemos obtenido, sino que podremos compararla con la de nuestros amigos y con la de otros jugadores de todo el mundo. Esta es una cuesti\u00f3n importante, ya que en un marcador mundial es muy dif\u00edcil conseguir estar en puestos destacados, lo cual puede desanimar a la mayor\u00eda de jugadores. Sin embargo, si tenemos la opci\u00f3n de ver en el marcador s\u00f3lo a nuestros amigos, es m\u00e1s probable que podamos \"pelear\" por los primeros puestos, y esto mejorar\u00e1 la retenci\u00f3n de los usuarios, bien para conseguir llegar a ocupar las primeras posiciones, o para conservarlas. Podremos tener varios marcadores en nuestro juego, con distintos tipos de datos (por ejemplo, puntuaciones m\u00e1ximas , monedas recolectadas , mejores tiempos , etc). Seg\u00fan el tipo de marcador, podremos indicar si la ordenaci\u00f3n debe ser ascendente o descendente . Por ejemplo, para la puntuaci\u00f3n deber\u00eda ser descendente (la m\u00e1xima encabezar\u00e1 la lista), pero para mejores tiempos deber\u00edamos utilizar un marcador ascendente (el que menor tiempo haya hecho encabezar\u00e1 la lista). Al igual que en el caso de los logros, la incorporaci\u00f3n de los marcadores se suele hacer en las fases finales del desarrollo. Son algo independiente del juego, durante el transcurso de la partida no tendr\u00e1n ning\u00fan efecto. Normalmente los veremos siempre en una pantalla independiente, ya fuera de la pantalla del juego, donde se mostrar\u00e1 la lista de las mejores puntuaciones. Configuraci\u00f3n de logros y marcadores \u00b6 Antes de poder utilizar logros y marcadores en nuestros juegos, deberemos configurarlos en la plataforma que vayamos a utilizar (Game Center, Google Play Games, etc). Normalmente, cada plataforma nos proporcionar\u00e1 una interfaz web con la que introducir los datos de los logros y marcadores que vayamos a utilizar en nuestro juego. Vamos a ver c\u00f3mo hacer esto en las principales plataformas para m\u00f3viles. Game Center \u00b6 Comenzaremos viendo c\u00f3mo dar de alta logros y marcadores en Game Center, la plataforma de videojuegos de Apple. En primer lugar, deberemos crear un App ID para nuestra aplicaci\u00f3n en la que est\u00e9 activo el servicio Game Center. Para ello entramos en la aplicaci\u00f3n Certificates, Identifiers & Profiles , que encontraremos dentro de las aplicaciones disponibles para los desarrolladores del Apple Developer Program . Una vez creado el App ID, entraremos en iTunes Connect y crearemos la ficha de la aplicaci\u00f3n para nuestro juego, utilizando el App ID definido en el paso anterior. Dentro de los datos de nuestra aplicaci\u00f3n, veremos una pesta\u00f1a Prestaciones , que contiene una secci\u00f3n Game Center donde podremos configurar logros y marcadores. En la secci\u00f3n Game Center veremos una lista de logros y de marcadores existentes, y podremos crear nuevos logros y marcadores tal como veremos a continuaci\u00f3n. Configuraci\u00f3n de marcadores En la lista de marcadores veremos todos los marcadores creados hasta el momento (inicialmente estar\u00e1 vac\u00eda), y tendremos un bot\u00f3n + que nos permitir\u00e1 a\u00f1adir nuevos marcadores a la aplicaci\u00f3n. Al pulsar sobre el bot\u00f3n para a\u00f1adir un marcador nos preguntar\u00e1 si queremos una Clasificaci\u00f3n individual o combinada . Comenzaremos creando una individual (s\u00f3lo podemos crear combinadas si ya contamos con clasificaciones individuales que podamos combinar). Para la clasificaci\u00f3n deberemos dar: Un nombre descriptivo (s\u00f3lo para identificarlo en la interfaz de la aplicaci\u00f3n de gesti\u00f3n) Un identificador (con el que haremos referencia al marcador desde el c\u00f3digo del juego) Un tipo de datos y formato con el que mostrar las puntuaciones Orden ascendente o descendente Valores m\u00e1ximo y m\u00ednimo que puede alcanzar la puntuaci\u00f3n. Adem\u00e1s, en la parte inferior vemos que podemos localizar en varios idiomas el nombre y el formato de la puntuaci\u00f3n. Esto es lo que el usuario del juego ver\u00e1 cuando se muestre la tabla de puntuaciones. Configuraci\u00f3n de logros De forma similar al caso de los marcadores, veremos tambi\u00e9n un listado de logros existentes con la posibilidad de a\u00f1adir nuevos logros mediante el bot\u00f3n + . Al a\u00f1adir un nuevo logro, se nos presentar\u00e1 una interfaz donde introducir sus datos. Los datos que debemos proporcionar de los logros son: Nombre descriptivo (s\u00f3lo interno para la aplicaci\u00f3n de gesti\u00f3n) Identificador (con el que haremos referencia a \u00e9l desde el c\u00f3digo) Valor del logro (en total pueden sumar como m\u00e1ximo 1000 puntos) Indicar si el logro es oculto o no Indicar si el logro se puede conseguir m\u00e1s de una vez (hay logros que se pueden conseguir gradualmente, hasta alcanzar su 100%) En la parte inferior podemos localizar los textos de los logros a diferentes idiomas. Estos ser\u00e1n los textos que el usuario final ver\u00e1 cuando consigamos un logro o cuando se muestre el listado de logros del juego. Google Play Games \u00b6 La plataforma Google Play Games (GPG) cuenta tambi\u00e9n con una interfaz similar para dar de alta logros y marcadores. Esta herramienta se encuentra integrada en la consola de desarrolladores de Android, en la secci\u00f3n Servicios de juegos En dicha secci\u00f3n daremos de alta los juegos que queramos que puedan utilizar el servicio de GPG. Hay que remarcar que esto es algo totalmente independiente al alta de la aplicaci\u00f3n Android (en Tus aplicaciones ). En Servicios de juegos simplemente creamos la ficha para nuestro juego en GPG, a la que se podr\u00e1 acceder desde Android, iOS, u otras plataformas. Podr\u00edamos incluso crear aqu\u00ed juegos que no estuvieran disponibles en Android. En caso de querer crear la ficha del juego en GPG para un juego Android, ser\u00e1 recomendable subir antes un APK, aunque se trate de una versi\u00f3n alpha . Si contamos con dicho APK, muchos de los datos necesarios para crear nuestra ficha los podr\u00e1 obtener de forma autom\u00e1tica a partir de dicho fichero, simplificando notablemente el proceso. Configuraci\u00f3n de logros Una vez creado nuestro juego en los servicios de GPG, podremos acceder a su ficha y configurar logros y marcadores. Entrando en la secci\u00f3n de Logros veremos el listado de logros existentes, y un bot\u00f3n A\u00f1adir nuevo logro . En la lista podemos observar que cada logro tiene un ID que deberemos utilizar para hacer referencia a \u00e9l desde el c\u00f3digo de nuestro juego. A diferencia de Game Center, estos IDs no los introducimos nosotros, sino que son autogenerados. Esto nos obligar\u00e1 a tener que definir en nuestro juego dos listas de identificadores de logros diferentes, una para cada plataforma. Si pulsamos sobre A\u00f1adir nuevo logro , o editamos uno de los existentes, veremos la pantalla para introducir datos del logro. Para cada logro nos pide: Nombre (el que se le mostrar\u00e1 al usuario) Descripci\u00f3n Icono Indicar si es incremental (si podemos irlo consiguiendo a incrementos parciales) Puntos (con un m\u00e1ximo total de 1000 puntos, al igual que Game Center). Estos datos pueden estar localizados a diferentes idiomas. Configuraci\u00f3n de marcadores Dentro de la ficha de nuestro juego en GPG, tambi\u00e9n encontramos una secci\u00f3n Marcadores donde podemos configurar los marcadores del juego. Veremos un listado de los marcadores existentes, cada uno de ellos con su ID autogenerado asociado, al igual que en el caso de los logros. Tambi\u00e9n tendremos un bot\u00f3n A\u00f1adir nuevo marcador . Pulsando sobre el bot\u00f3n A\u00f1adir nuevo marcador o yendo a editar un marcador existente, veremos la pantalla para introducir los datos del marcador. De cada marcador nos pide: Nombre (el que se le mostrar\u00e1 al usuario) Tipo de datos y formato de las puntuaciones Icono L\u00edmites inferior y superior de las puntuaciones Al igual que en el caso anterior, podremos localizar la informaci\u00f3n de este formulario a diferentes idiomas. Implementaci\u00f3n de logros y marcadores \u00b6 Para implementar el soporte de logros y marcadores con Game Center contamos con el framework GameKit nativo de la plataforma iOS. Por otro lado, para a\u00f1adir soporte para Google Play Games en Android necesitaremos incluir en nuestro proyecto los Google Play Services, mientras que para iOS contamos con un SDK espec\u00edfico que podemos a\u00f1adir al proyecto. Sin embargo, no contamos con soporte \"de serie\" de logros y marcadores en Cocos2d-x. Para utilizar estas caracter\u00edsticas con dicho motor, deberemos recurrir a las APIs nativas, o bien utilizar alg\u00fan plugin de terceros que haga esto por nosotros. Un plugin que podemos utilizar para esta tarea es GameSharing . \u00c9ste nos proporciona una API C++ \u00fanica que por debajo, dependiendo de la plataforma, utilizar\u00e1 Game Center (con GameKit ) o Google Play Games (con los Google Play Services ). Como veremos a continuaci\u00f3n, las diferentes APIs para gesti\u00f3n de logros y marcadores son muy parecidas. Las interfaces multiplataforma que podemos encontrar en motores como Unity o en el plugin GameSharing de Cocos2d-x se utilizan pr\u00e1cticamente de la misma forma que la API nativa GameKit de iOS. Logros y marcadores con GameKit \u00b6 Vamos a comenzar viendo c\u00f3mo integrar Game Center mediante el framework nativo GameKit de iOS. Para utilizarlo simplemente tendremos que a\u00f1adir dicho framework a nuestro proyecto de Xcode. Una vez a\u00f1adido, podremos utilizar su API. Todas sus clases tienen el prefijo GK . Inicializaci\u00f3n Para poder gestionar los logros y marcadores de nuestro juego en Game Center, lo primero que deberemos hacer es autenticar al usuario en dicha plataforma. Normalmente el usuario ya habr\u00e1 configurado su cuenta de Game Center en el m\u00f3vil, por lo que la autenticaci\u00f3n ser\u00e1 autom\u00e1tica, sin tener que introducir login ni password . En caso de que no hubiera configurado una cuenta de Game Center previamente, podremos invitarle a que lo haga en este momento. Para autenticar el usuario simplemente tendremos que obtener la instancia \u00fanica ( singleton ) del objeto GKLocalPlayer , que hace referencia al usuario local configurado en el m\u00f3vil, y asignar un bloque de c\u00f3digo a su propiedad authenticateHandler . Con esto, la autenticaci\u00f3n se har\u00e1 de forma autom\u00e1tica nada m\u00e1s establecer la propiedad, y volver\u00e1 a autenticar al usuario cada vez que volvamos a abrir la aplicaci\u00f3n. 1 2 3 4 5 6 7 8 9 10 11 12 GKLocalPlayer * player = [ GKLocalPlayer localPlayer ]; player . authenticateHandler = ^ ( UIViewController * viewController , NSError * error ){ if ( viewController != nil ) { // No hay usuario de GameCenter, presenta interfaz de autenticaci\u00f3n [ self presentViewController : viewController animated : YES completion : ^ {}]; } else if ( player . authenticated ) { // Autenticaci\u00f3n correcta } else { // Error en la autenticaci\u00f3n } }; Podemos observar que pueden ocurrir tres cosas: Que se proporcione un viewController . Quiere decir que no hay usuario configurado en el dispositivo, y el viewController proporcionado nos sirve para invitar al usuario a que lo configure. Deberemos presentarlo como controlador modal. Que el usuario se autentique de forma correcta (se puede comprobar con la propiedad player.authenticated . Que no se pueda autenticar al usuario. En este caso, debemos asegurarnos de que el uso de Game Center quede deshabilitado (no deberemos intenter publicar logros ni marcadores). Podremos consultar la propiedad player.authenticated en cualquier momento para saber si podemos utilizar las funciones de Game Center en el juego. Mostrar panel de logros y marcadores Una vez tenemos al usuario autenticado en Game Center, podemos mostrar una pantalla est\u00e1ndar de la plataforma donde se muestra la ficha de Game Center para nuestro juego. En dicha pantalla podremos ver los marcadores y los logros conseguidos por el usuario hasta el momento: 1 2 3 4 GKGameCenterViewController * gkController = [[ GKGameCenterViewController alloc ] init ]; gkController . gameCenterDelegate = self ; [ self presentViewController : gkController animated : YES completion : ^ {}]; Si nuestro juego tiene varios marcadores, tambi\u00e9n podemos hacer que se muestre un marcador concreto estableciendo las siguientes propiedades del controlador anterior: 1 2 gkController . leaderboardIdentifier = ID_MARCADOR ; gkController . leaderboardTimeScope = GKLeaderboardTimeScopeAllTime ; Gesti\u00f3n de puntuaciones Cuando termine una partida, y nuestro jugador haya conseguido un nuevo r\u00e9cord, podemos subir dicha puntuaci\u00f3n a su marcador global de Game Center. Deberemos crear un objeto GKScore con el identificador del marcador en el que publicar la puntuaci\u00f3n, y asignar a su propiedad value el valor de la puntuaci\u00f3n que queremos publicar: 1 2 3 4 5 6 7 8 9 10 11 12 GKScore * scoreReporter = [[ GKScore alloc ] initWithLeaderboardIdentifier : ID_MARCADOR ]; scoreReporter . value = score ; scoreReporter . context = 0 ; [ GKScore reportScores : @[ scoreReporter ] withCompletionHandler : ^ ( NSError * error ) { if ( error != nil ) { // Error al enviar puntuacion // POSIBLE SOLUCION: Guardarlo en lista de pendientes de envio } else { // Puntuaci\u00f3n enviada } }]; Hay que destacar que la publicaci\u00f3n podr\u00eda fallar, por ejemplo si la red est\u00e1 inaccesible en este momento. Una posible forma de solucionarlo es almacenar en nuestra aplicaci\u00f3n una lista de puntuaciones pendientes de subir, para as\u00ed poder volver a intentarlo la pr\u00f3xima vez que entremos en el juego. Gesti\u00f3n de logros La publicaci\u00f3n de logros conseguidos se har\u00e1 de forma similar a la de las puntuaciones de los marcadores. En este caso, para desbloquear un logro debemos proporcionar su identificador. Adem\u00e1s, dado que podemos tener logros incrementales, debemos indicar el porcentaje de logro que queremos desbloquear ( percentComplete ). Si queremos desbloquear el logro completo, le daremos a esta propiedad el valor 100 . Tambi\u00e9n podemos utilizar la propiedad showsCompletionBanner para que autom\u00e1ticamente muestre el banner de desbloqueo de logro por defecto del sistema. Poniendo esta propiedad a false podr\u00edamos mostrar nuestro propio tipo de banners , si queremos personalizarlos. 1 2 3 4 5 6 7 8 9 10 11 12 13 GKAchievement * achievement = [[ GKAchievement alloc ] initWithIdentifier : ID_LOGRO ]; if ( achievement ){ achievement . percentComplete = 100 ; achievement . showsCompletionBanner = true ; [ GKAchievement reportAchievements : @[ achievement ] withCompletionHandler : ^ ( NSError * error ) { if ( error != nil ) { // Error al publicar logro // POSIBLE SOLUCION: Guardarlo en lista de pendientes de envio } else { // Logro desbloqueado } }]; } Al igual que en el caso de las puntuaciones, si obtenemos un error al desbloquear un logro, podemos guardarlo para intentarlo m\u00e1s adelante. Esto s\u00f3lo debe hacerse como \u00faltima instancia, ya que los logros deben ser desbloqueados de forma inmediata tras realizar la acci\u00f3n que los produce. Es recomendable tambi\u00e9n s\u00f3lo desbloquear logros cuando haya un progreso real del usuario en el juego, y evitar pedir desbloquear el mismo logro varias veces para evitar tr\u00e1fico innecesario a trav\u00e9s de la red. Para conseguir esto, podemos guardar una cach\u00e9 con los logros obtenidos, y as\u00ed s\u00f3lo intentar desbloquearlos cuando no est\u00e9n en dicha cach\u00e9. Para crearla podemos leer todos los logros obtenidos justo tras realizar la autenticaci\u00f3n del usuario, mediante el m\u00e9todo loadAchievementsWithCompletionHandler de la clase GKAchievement . Logros y marcadores con GameSharing \u00b6 En caso de tener un proyecto multiplataforma Cocos2d-x podemos realizar llamadas a las APIs nativas de Game Center y Google Play Games para gestionar sus logros y marcadores, pero convendr\u00e1 que hagamos esto de forma que el c\u00f3digo del juego siga siendo multiplataforma. Podemos utilizar para ello un plugin como GameSharing que se encarga de \"esconder\" las llamadas a las APIs nativas tras una fachada C++. Dicha fachada se encuentra en la clase GameSharing , que no es necesario que instanciemos, ya que todos sus m\u00e9todos son est\u00e1ticos. Incluiremos dicha clase ( GameSharing.cpp y GameSharing.h ) en el directorio Classes del proyecto. Configuraci\u00f3n de GameSharing Antes de poder utilizar dicha clase deberemos realizar una serie de tareas de configuraci\u00f3n del proyecto. En el caso de iOS deberemos: A\u00f1adir el framework GameKit al proyecto Xcode. A\u00f1adir las clases Objective-C nativas de la librer\u00eda al proyecto Xcode (se encargan de hacer las llamadas nativas a GameCenter, y son utilizadas por la clase C++ GameSharing . Adem\u00e1s, deberemos a\u00f1adir la siguiente inicializaci\u00f3n en la clase AppDelegate : 1 2 3 4 5 6 7 8 - ( BOOL ) application: ( UIApplication * ) application didFinishLaunchingWithOptions: ( NSDictionary * ) launchOptions { ... // Init GameSharing GameSharing :: initGameSharing_iOS (( __bridge void * ) _viewController ); return YES ; } Configurar la lista de logros y marcadores en un fichero ios_ids.plist dentro de los recursos del proyecto. Dicho fichero constar\u00e1 de un diccionario con dos claves: Leaderboards y Achievements . Cada una de ellas contendr\u00e1 un array con los identificadores de los marcadores y logros disponibles. En el caso de Android deberemos realizar una serie de acciones similares: Incluir en el proyecto Android (directorio libs ) las librer\u00edas de Google Play Services y android-support-v4 . Incluir las clases Java nativas de la GameSharing en el proyecto nativo y tambi\u00e9n una serie de recursos necesarios en el directorio res . Deberemos editar algunos de estos elementos para adaptarlos a nuestra aplicaci\u00f3n, siguiendo las instrucciones indicadas en la documentaci\u00f3n de la librer\u00eda GameSharing . A\u00f1adimos a los ficheros de recursos dos recursos de tipo string : leaderboards y achievements , donde indicaremos los identificadores de marcadores y logros separados por ; . Hemos de destacar que en ambos casos hemos especificado una lista de marcadores y logros en ficheros de configuraci\u00f3n externos. En el c\u00f3digo siempre haremos referencia a estos elementos mediante el \u00edndice de la posici\u00f3n que ocupan en estas listas. Por ello es importante que en ambas listas se incluyan los logros y marcadores en el mismo orden, para as\u00ed poder utilizar el mismo c\u00f3digo para Android e iOS. Uso de la API Una vez realizada la configuraci\u00f3n necesaria, podremos utilizar la API de GameSharing en nuestro c\u00f3digo de Cocos2d-x. En el caso de la versi\u00f3n iOS, deberemos inicializar la librer\u00eda para autenticar al usuario local (esto no es necesario en Android): 1 GameSharing :: initGameSharing (); Podremos mostrar la pantalla est\u00e1ndar del sistema con los logros o marcadores del juego: 1 2 GameSharing :: ShowAchievementsUI (); GameSharing :: ShowLeaderboards ( indice ); Tambi\u00e9n podemos desbloquear un logro dado su \u00edndice en el array (siguiendo el orden en el que se especificaron en el fichero de configuraci\u00f3n): 1 GameSharing :: UnlockAchivement ( indice ); De la misma forma, podemos publicar la puntuaci\u00f3n en uno de los marcadores (dado su \u00edndice en el array ): 1 GameSharing :: SubmitScore ( score , indice ); Referencias \u00b6 Art\u00edculo sobre dise\u00f1o de marcadores: Leaderboards - The original social feature Articulos sobre dise\u00f1o de logros: Achievement Design 101 The Cake Is Not a Lie: How to Design Effective Achievements Art\u00edculo sobre juegos sociales: The social network game boom","title":"Logros y marcadores"},{"location":"redes_sociales.html#redes-sociales-para-videojuegos","text":"Existen diferentes redes sociales espec\u00edficas para videojuegos. Estas redes nos permiten ver por ejemplo a qu\u00e9 juegos est\u00e1n jugando nuestros amigos, y los logros y puntuaciones que han conseguido en ellos. Tambi\u00e9n nos permitir\u00e1n entrar en partidas multijugador con nuestros amigos o almacenar los datos de nuestra partida en la nube. Normalmente estas redes est\u00e1n ligadas a la plataforma que utilizamos para jugar ( Game Center para las plataformas de Apple: iOS, Mac, Apple TV; Xbox live para las plataformas de Microsoft: Xbox y Windows; PS Network para las plataformas de Sony: PS3, PS4, PS Vita; Steam en PC, Linux y Mac), pero tambi\u00e9n encontramos redes que podemos utilizar en diferentes plataformas ( Google Play Games , adem\u00e1s de Android, puede utilizarse en iOS o plataformas Web). Tambi\u00e9n existen plataformas sociales para videojuegos ofrecidas por terceros (por ejemplo Game Sparks , Playphone o OpenKit ), siendo la mayor\u00eda de ellos servicios de pago. Vamos a ver c\u00f3mo dise\u00f1ar e implementar logros y marcadores con las principales redes sociales para juegos disponibles en las plataformas m\u00f3viles.","title":"Redes sociales para videojuegos"},{"location":"redes_sociales.html#diseno-de-logros-y-marcadores","text":"","title":"Dise\u00f1o de logros y marcadores"},{"location":"redes_sociales.html#logros","text":"Los logros son recompensas que podremos obtener cumpliendo determinados retos dentro del juego. Cada logro tiene asociado un reto sobre algo que podemos realizar dentro del juego (por ejemplo, \"Destruye 100 naves enemigas\"). Una vez consigamos realizar el objetivo de este reto seremos recompensados con el logro. Normalmente veremos los logros conseguidos como medallas, y podremos ver tambi\u00e9n los logros obtenidos por otros jugadores y compararlos con los que hemos obtenido nosotros. Bien dise\u00f1ados, los logros podr\u00e1n hacer que los jugadores tengan m\u00e1s incentivos para jugar a nuestro juego.","title":"Logros"},{"location":"redes_sociales.html#marcadores","text":"Los marcadores anotar\u00e1n la puntuaci\u00f3n m\u00e1xima que hemos conseguido en el juego. Adem\u00e1s, no s\u00f3lo nos permitir\u00e1n ver la puntuaci\u00f3n que hemos obtenido, sino que podremos compararla con la de nuestros amigos y con la de otros jugadores de todo el mundo. Esta es una cuesti\u00f3n importante, ya que en un marcador mundial es muy dif\u00edcil conseguir estar en puestos destacados, lo cual puede desanimar a la mayor\u00eda de jugadores. Sin embargo, si tenemos la opci\u00f3n de ver en el marcador s\u00f3lo a nuestros amigos, es m\u00e1s probable que podamos \"pelear\" por los primeros puestos, y esto mejorar\u00e1 la retenci\u00f3n de los usuarios, bien para conseguir llegar a ocupar las primeras posiciones, o para conservarlas. Podremos tener varios marcadores en nuestro juego, con distintos tipos de datos (por ejemplo, puntuaciones m\u00e1ximas , monedas recolectadas , mejores tiempos , etc). Seg\u00fan el tipo de marcador, podremos indicar si la ordenaci\u00f3n debe ser ascendente o descendente . Por ejemplo, para la puntuaci\u00f3n deber\u00eda ser descendente (la m\u00e1xima encabezar\u00e1 la lista), pero para mejores tiempos deber\u00edamos utilizar un marcador ascendente (el que menor tiempo haya hecho encabezar\u00e1 la lista). Al igual que en el caso de los logros, la incorporaci\u00f3n de los marcadores se suele hacer en las fases finales del desarrollo. Son algo independiente del juego, durante el transcurso de la partida no tendr\u00e1n ning\u00fan efecto. Normalmente los veremos siempre en una pantalla independiente, ya fuera de la pantalla del juego, donde se mostrar\u00e1 la lista de las mejores puntuaciones.","title":"Marcadores"},{"location":"redes_sociales.html#configuracion-de-logros-y-marcadores","text":"Antes de poder utilizar logros y marcadores en nuestros juegos, deberemos configurarlos en la plataforma que vayamos a utilizar (Game Center, Google Play Games, etc). Normalmente, cada plataforma nos proporcionar\u00e1 una interfaz web con la que introducir los datos de los logros y marcadores que vayamos a utilizar en nuestro juego. Vamos a ver c\u00f3mo hacer esto en las principales plataformas para m\u00f3viles.","title":"Configuraci\u00f3n de logros y marcadores"},{"location":"redes_sociales.html#game-center","text":"Comenzaremos viendo c\u00f3mo dar de alta logros y marcadores en Game Center, la plataforma de videojuegos de Apple. En primer lugar, deberemos crear un App ID para nuestra aplicaci\u00f3n en la que est\u00e9 activo el servicio Game Center. Para ello entramos en la aplicaci\u00f3n Certificates, Identifiers & Profiles , que encontraremos dentro de las aplicaciones disponibles para los desarrolladores del Apple Developer Program . Una vez creado el App ID, entraremos en iTunes Connect y crearemos la ficha de la aplicaci\u00f3n para nuestro juego, utilizando el App ID definido en el paso anterior. Dentro de los datos de nuestra aplicaci\u00f3n, veremos una pesta\u00f1a Prestaciones , que contiene una secci\u00f3n Game Center donde podremos configurar logros y marcadores. En la secci\u00f3n Game Center veremos una lista de logros y de marcadores existentes, y podremos crear nuevos logros y marcadores tal como veremos a continuaci\u00f3n.","title":"Game Center"},{"location":"redes_sociales.html#google-play-games","text":"La plataforma Google Play Games (GPG) cuenta tambi\u00e9n con una interfaz similar para dar de alta logros y marcadores. Esta herramienta se encuentra integrada en la consola de desarrolladores de Android, en la secci\u00f3n Servicios de juegos En dicha secci\u00f3n daremos de alta los juegos que queramos que puedan utilizar el servicio de GPG. Hay que remarcar que esto es algo totalmente independiente al alta de la aplicaci\u00f3n Android (en Tus aplicaciones ). En Servicios de juegos simplemente creamos la ficha para nuestro juego en GPG, a la que se podr\u00e1 acceder desde Android, iOS, u otras plataformas. Podr\u00edamos incluso crear aqu\u00ed juegos que no estuvieran disponibles en Android. En caso de querer crear la ficha del juego en GPG para un juego Android, ser\u00e1 recomendable subir antes un APK, aunque se trate de una versi\u00f3n alpha . Si contamos con dicho APK, muchos de los datos necesarios para crear nuestra ficha los podr\u00e1 obtener de forma autom\u00e1tica a partir de dicho fichero, simplificando notablemente el proceso.","title":"Google Play Games"},{"location":"redes_sociales.html#implementacion-de-logros-y-marcadores","text":"Para implementar el soporte de logros y marcadores con Game Center contamos con el framework GameKit nativo de la plataforma iOS. Por otro lado, para a\u00f1adir soporte para Google Play Games en Android necesitaremos incluir en nuestro proyecto los Google Play Services, mientras que para iOS contamos con un SDK espec\u00edfico que podemos a\u00f1adir al proyecto. Sin embargo, no contamos con soporte \"de serie\" de logros y marcadores en Cocos2d-x. Para utilizar estas caracter\u00edsticas con dicho motor, deberemos recurrir a las APIs nativas, o bien utilizar alg\u00fan plugin de terceros que haga esto por nosotros. Un plugin que podemos utilizar para esta tarea es GameSharing . \u00c9ste nos proporciona una API C++ \u00fanica que por debajo, dependiendo de la plataforma, utilizar\u00e1 Game Center (con GameKit ) o Google Play Games (con los Google Play Services ). Como veremos a continuaci\u00f3n, las diferentes APIs para gesti\u00f3n de logros y marcadores son muy parecidas. Las interfaces multiplataforma que podemos encontrar en motores como Unity o en el plugin GameSharing de Cocos2d-x se utilizan pr\u00e1cticamente de la misma forma que la API nativa GameKit de iOS.","title":"Implementaci\u00f3n de logros y marcadores"},{"location":"redes_sociales.html#logros-y-marcadores-con-gamekit","text":"Vamos a comenzar viendo c\u00f3mo integrar Game Center mediante el framework nativo GameKit de iOS. Para utilizarlo simplemente tendremos que a\u00f1adir dicho framework a nuestro proyecto de Xcode. Una vez a\u00f1adido, podremos utilizar su API. Todas sus clases tienen el prefijo GK .","title":"Logros y marcadores con GameKit"},{"location":"redes_sociales.html#logros-y-marcadores-con-gamesharing","text":"En caso de tener un proyecto multiplataforma Cocos2d-x podemos realizar llamadas a las APIs nativas de Game Center y Google Play Games para gestionar sus logros y marcadores, pero convendr\u00e1 que hagamos esto de forma que el c\u00f3digo del juego siga siendo multiplataforma. Podemos utilizar para ello un plugin como GameSharing que se encarga de \"esconder\" las llamadas a las APIs nativas tras una fachada C++. Dicha fachada se encuentra en la clase GameSharing , que no es necesario que instanciemos, ya que todos sus m\u00e9todos son est\u00e1ticos. Incluiremos dicha clase ( GameSharing.cpp y GameSharing.h ) en el directorio Classes del proyecto.","title":"Logros y marcadores con GameSharing"},{"location":"redes_sociales.html#referencias","text":"Art\u00edculo sobre dise\u00f1o de marcadores: Leaderboards - The original social feature Articulos sobre dise\u00f1o de logros: Achievement Design 101 The Cake Is Not a Lie: How to Design Effective Achievements Art\u00edculo sobre juegos sociales: The social network game boom","title":"Referencias"},{"location":"scenekit.html","text":"SceneKit \u00b6 ::: warning En construcci\u00f3n :::","title":"SceneKit"},{"location":"scenekit.html#scenekit","text":"::: warning En construcci\u00f3n :::","title":"SceneKit"},{"location":"spritekit.html","text":"SpriteKit \u00b6 Cuando desde Xcode creamos un proyecto de tipo Game nativo, nos preguntar\u00e1 cu\u00e1l de las anteriores librer\u00edas queremos utilizar como base. Vamos a centrarnos en las tecnolog\u00edas de alto nivel: SpriteKit y SceneKit . Con ellas dispondremos adem\u00e1s herramientas visuales en el entorno para crear las escenas del videojuego. Conviene destacar tambi\u00e9n que estas tecnolog\u00edas presentan abundantes similitudes con Cocos2d-x y Unity respectivamente. Desarrollo de juegos con SpriteKit \u00b6 SpriteKit es un framework nativo de la plataforma iOS destinado al desarrollo de aplicaciones que muestren cualquier tipo de gr\u00e1ficos 2D animados, como es el caso de los videojuegos. Todas las clases de este framework tienen el prefijo SK , y se encuentra disponible a partir de iOS 7. Su API es muy parecida a la del motor de videojuegos Cocos2d-x, por lo que la transici\u00f3n entre estas tecnolog\u00edas ser\u00e1 muy sencilla. La escena de SpriteKit \u00b6 Al igual que en dicho motor, utiliza una organizaci\u00f3n jer\u00e1rquica de los elementos escena , es decir, todos los elementos de la escena son nodos que se organizan en forma de de \u00e1rbol. Tendremos una escena para cada estado (pantalla) del juego (men\u00fa principal, opciones, partida, etc). Para crear una escena normalmente crearemos una clase que herede de SKScene , por ejemplo: 1 2 3 4 5 import SpriteKit class GameScene : SKScene { // ... } Para poder mostrar esa escena necesitaremos previamente contar con una vista de tipo SKView . Por ejemplo, podemos introducir una vista de este tipo dentro de nuestro controlador en el storyboard . Al cargar nuestro controlador podemos obtener dicha vista y cargar en ella la escena principal: 1 2 3 4 5 6 7 8 9 10 11 override func viewDidLoad () { super . viewDidLoad () if let view = self . view as ! SKView ? { // Carga la escena del fichero 'GameScene.sks' if let scene = SKScene ( fileNamed : \"GameScene\" ) { // Presenta la escena en la vista view . presentScene ( scene ) } } } Hemos de destacar que el constructor de la escena toma como par\u00e1metro el nombre de un fichero. El fichero que deberemos pasarle es un fichero de escena, con extensi\u00f3n .sks ( Scene Kit Scene ) que puede contener los elementos de la escena ( sprites , etiquetas de texto, c\u00e1mara, luces, etc). Podemos crear este fichero desde Xcode, con File > New > File ... > iOS > Resource > SpriteKit Scene : Podemos dejar esta escena vac\u00eda y crear su contenido de forma programada. Vamos a hacerlo as\u00ed de momento. La clase escena tiene un m\u00e9todo -(void)didMoveToView:(SKView *)view que se invocar\u00e1 cuando la escena se pase a ejecutar en la vista del juego. Podemos aprovechar este m\u00e9todo para crear de forma programada el contenido de la escena. Este contenido se definir\u00e1 como un \u00e1rbol de nodos (objetos de tipo SKNode o de alguna de sus subclases). Nodos de la escena \u00b6 La escena de SpriteKit se define como un \u00e1rbol de nodos, todos ellos de tipo SKNode o alguna de sus subclases. Destacamos los siguiente tipos de nodos: SKNode : Clase de la que heredan todos los nodos. Podemos instanciarla directamente y a\u00f1adir el nodo a la escena. Este tipo de nodos no mostrar\u00e1n nada en la escena, pero son \u00fatiles para agrupar otros nodos en el \u00e1rbol de la escena y poder moverlos de forma conjunta. SKLabelNode : Subclase de SKNode que mostrar\u00e1 una etiqueta de texto en la escena. SKSpriteNode : Subclase de SKNode que mostrar\u00e1 un sprite en la escena. Los nodos gen\u00e9ricos se instancian mediante el constructor vac\u00edo de SKNode : 1 let nodo = SKNode (); Podremos cambiar la posici\u00f3n (x,y) de todos los nodos en la escena, as\u00ed como su orden z, que determinar\u00e1 qu\u00e9 nodos se muestran por delante de otros: 1 2 nodo . position = CGPointMake ( 100 , 100 ); nodo . zPosition = 5 ; Tambi\u00e9n podremos cambiar su rotaci\u00f3n y su escala (x,y): 1 2 3 miNodo . zRotation = 90 ; miNodo . xScale = - 1 ; miNodo . yScale = 1 ; Es de especial inter\u00e9s la posibilidad de hacer un escalado de -1, para as\u00ed crear un efecto \"espejo\". Adem\u00e1s de estas propiedades, otra caracter\u00edstica importante de los nodos es su m\u00e9todo addChild: , que nos permite a\u00f1adir otro nodo como hijo: 1 2 SKNode * miGrupo = [ SKNode node ]; [ miGrupo addChild : miNodo ]; El agrupamiento jer\u00e1rquico de nodos es importante porque nos permitir\u00e1 por ejemplo mover de forma conjunta todo un grupo de nodos cambiando \u00fanicamente la posici\u00f3n del nodo padre. Encontraremos tambi\u00e9n m\u00e9todos y propiedades para conocer qui\u00e9n es el padre de un nodo, eliminar un hijo de un nodo, o moverlo a otro nodo padre, entre otras funciones. Etiqueta de texto Un tipo de nodo fundamental es la etiqueta de texto ( SKLabelNode ) que nos permitir\u00e1 mostrar texto en la escena. Este tipo de nodo se puede crear a partir de la fuente a utilizar: 1 let etiq = SKLabelNode (); A parte de las propiedades generales de los nodos, la propiedad m\u00e1s importante de este tipo de nodo es text , que nos permite especificar el texto a mostrar por la etiqueta: 1 etiq . text = \"Super Mobile Game\" ; Este tipo de nodos nos permitir\u00e1 cambiar adem\u00e1s el tipo de fuente, su color, o la alineaci\u00f3n del texto. Sprites El tipo de nodo m\u00e1s importante en un videojuego es el sprite , que representa aquellas entidades que aparecen en la escena (personajes, objetos, etc), y que se muestran como una imagen o una animaci\u00f3n. Podemos crear un sprite a partir del nombre de la imagen que queremos que muestre: 1 SKSpriteNode * miSprite = [ SKSpriteNode spriteNodeWithImageNamed : @\"mario\" ]; Dado que el sprite muestra una imagen en la escena, una propiedad importante ser\u00e1 size , que nos indicar\u00e1 el tama\u00f1o del sprite en puntos. Esto ser\u00e1 importante porque se tendr\u00e1 en cuenta tambi\u00e9n para el c\u00e1lculo de colisiones con otros sprites de la escena. Adem\u00e1s, tambien tiene una propiedad anchorPoint , cuyo valor por defecto es (0.5, 0.5) , y que siempre tomar\u00e1 valores entre (0.0, 0.0) y (1.0, 1.0) . Esta propiedad nos indicar\u00e1 c\u00f3mo posicionar el sprite en la escena cuando modifiquemos su propiedad position . Se trata de las coordenadas locales dentro de la imagen del sprite que se situar\u00e1n en la posici\u00f3n indicada por position , siendo: (0.0, 0.0) es la esquina inferior izquierda del sprite . (0.5, 0.5) es el centro del sprite . (1.0, 1.0) es la esquina superior derecha del sprite . Acciones \u00b6 Los nodos de la escena nos permiten ejecutar acciones, que modifican las propiedades del nodos (como su posici\u00f3n o rotaci\u00f3n) a lo largo del tiempo. Estas acciones se definen como objetos de la clase SKAction . Dentro de SKAction encontramos n\u00famerosos m\u00e9todos factor\u00eda para crear diferentes tipos de acciones. Por ejemplo, tenemos acciones para mover un nodo a una posici\u00f3n o rotarlo a un cierto \u00e1ngulo: 1 2 3 4 SKAction * accionMoverFinal = [ SKAction moveTo : CGPointMake ( 200 , 200 ) duration : 2.0 ]; SKAction * accionRotarFinal = [ SKAction rotateToAngle : 3.14f duration : 1.0 ]; SKAction * accionMoverInicio = [ SKAction moveTo : CGPointMake ( 100 , 100 ) duration : 2.0 ]; SKAction * accionRotarInicio = [ SKAction rotateToAngle : 0.0f duration : 1.0 ]; En estas acciones se indica la posici\u00f3n o \u00e1ngulo destino a la que se mover\u00e1 el nodo, y el tiempo que tardar\u00e1 en hacerlo (en segundo). Existen tambi\u00e9n otros muchos tipos de acciones para modificar otras propiedades como la escala, la textura, el color o el control de audio. Tambi\u00e9n encontramos acciones que nos permiten combinar otras acciones, o repetirlas: 1 2 SKAction * accionSecuencia = [ SKAction sequence : @{ accionMoverFinal , accionRotarFinal , accionMoverInicio , accionRotarInicio } ]; SKAction * accionRepite = [ SKAction repeatActionForever : accionSecuencia ]; Con esta \u00faltima acci\u00f3n podemos especificar por ejemplo el movimiento de \"patrulla\" de un enemigo, que se mover\u00e1 cont\u00ednuamente entre los puntos (100, 100) y (200, 200) . Podemos ejecutar cualquiera de las acciones anteriores sobre cualquier nodo, utilizando el m\u00e9todo runAction: de la clase SKNode : 1 [ miNodo runAction : accionRepite ]; De esta forma dicho nodo reproducir\u00e1 la conducta especificada por la acci\u00f3n. Podremos parar todas las acciones de un nodo con removeAllActions . Tambi\u00e9n podemos a\u00f1adir una acci\u00f3n con una clave ( key ) que posteriormente nos permitir\u00e1 parar \u00fanicamente dicha acci\u00f3n, o podemos ejecutar una acci\u00f3n proporcionando un bloque de c\u00f3digo que se ejecutar\u00e1 cuando la acci\u00f3n se complete.","title":"SpriteKit"},{"location":"spritekit.html#spritekit","text":"Cuando desde Xcode creamos un proyecto de tipo Game nativo, nos preguntar\u00e1 cu\u00e1l de las anteriores librer\u00edas queremos utilizar como base. Vamos a centrarnos en las tecnolog\u00edas de alto nivel: SpriteKit y SceneKit . Con ellas dispondremos adem\u00e1s herramientas visuales en el entorno para crear las escenas del videojuego. Conviene destacar tambi\u00e9n que estas tecnolog\u00edas presentan abundantes similitudes con Cocos2d-x y Unity respectivamente.","title":"SpriteKit"},{"location":"spritekit.html#desarrollo-de-juegos-con-spritekit","text":"SpriteKit es un framework nativo de la plataforma iOS destinado al desarrollo de aplicaciones que muestren cualquier tipo de gr\u00e1ficos 2D animados, como es el caso de los videojuegos. Todas las clases de este framework tienen el prefijo SK , y se encuentra disponible a partir de iOS 7. Su API es muy parecida a la del motor de videojuegos Cocos2d-x, por lo que la transici\u00f3n entre estas tecnolog\u00edas ser\u00e1 muy sencilla.","title":"Desarrollo de juegos con SpriteKit"},{"location":"spritekit.html#la-escena-de-spritekit","text":"Al igual que en dicho motor, utiliza una organizaci\u00f3n jer\u00e1rquica de los elementos escena , es decir, todos los elementos de la escena son nodos que se organizan en forma de de \u00e1rbol. Tendremos una escena para cada estado (pantalla) del juego (men\u00fa principal, opciones, partida, etc). Para crear una escena normalmente crearemos una clase que herede de SKScene , por ejemplo: 1 2 3 4 5 import SpriteKit class GameScene : SKScene { // ... } Para poder mostrar esa escena necesitaremos previamente contar con una vista de tipo SKView . Por ejemplo, podemos introducir una vista de este tipo dentro de nuestro controlador en el storyboard . Al cargar nuestro controlador podemos obtener dicha vista y cargar en ella la escena principal: 1 2 3 4 5 6 7 8 9 10 11 override func viewDidLoad () { super . viewDidLoad () if let view = self . view as ! SKView ? { // Carga la escena del fichero 'GameScene.sks' if let scene = SKScene ( fileNamed : \"GameScene\" ) { // Presenta la escena en la vista view . presentScene ( scene ) } } } Hemos de destacar que el constructor de la escena toma como par\u00e1metro el nombre de un fichero. El fichero que deberemos pasarle es un fichero de escena, con extensi\u00f3n .sks ( Scene Kit Scene ) que puede contener los elementos de la escena ( sprites , etiquetas de texto, c\u00e1mara, luces, etc). Podemos crear este fichero desde Xcode, con File > New > File ... > iOS > Resource > SpriteKit Scene : Podemos dejar esta escena vac\u00eda y crear su contenido de forma programada. Vamos a hacerlo as\u00ed de momento. La clase escena tiene un m\u00e9todo -(void)didMoveToView:(SKView *)view que se invocar\u00e1 cuando la escena se pase a ejecutar en la vista del juego. Podemos aprovechar este m\u00e9todo para crear de forma programada el contenido de la escena. Este contenido se definir\u00e1 como un \u00e1rbol de nodos (objetos de tipo SKNode o de alguna de sus subclases).","title":"La escena de SpriteKit"},{"location":"spritekit.html#nodos-de-la-escena","text":"La escena de SpriteKit se define como un \u00e1rbol de nodos, todos ellos de tipo SKNode o alguna de sus subclases. Destacamos los siguiente tipos de nodos: SKNode : Clase de la que heredan todos los nodos. Podemos instanciarla directamente y a\u00f1adir el nodo a la escena. Este tipo de nodos no mostrar\u00e1n nada en la escena, pero son \u00fatiles para agrupar otros nodos en el \u00e1rbol de la escena y poder moverlos de forma conjunta. SKLabelNode : Subclase de SKNode que mostrar\u00e1 una etiqueta de texto en la escena. SKSpriteNode : Subclase de SKNode que mostrar\u00e1 un sprite en la escena. Los nodos gen\u00e9ricos se instancian mediante el constructor vac\u00edo de SKNode : 1 let nodo = SKNode (); Podremos cambiar la posici\u00f3n (x,y) de todos los nodos en la escena, as\u00ed como su orden z, que determinar\u00e1 qu\u00e9 nodos se muestran por delante de otros: 1 2 nodo . position = CGPointMake ( 100 , 100 ); nodo . zPosition = 5 ; Tambi\u00e9n podremos cambiar su rotaci\u00f3n y su escala (x,y): 1 2 3 miNodo . zRotation = 90 ; miNodo . xScale = - 1 ; miNodo . yScale = 1 ; Es de especial inter\u00e9s la posibilidad de hacer un escalado de -1, para as\u00ed crear un efecto \"espejo\". Adem\u00e1s de estas propiedades, otra caracter\u00edstica importante de los nodos es su m\u00e9todo addChild: , que nos permite a\u00f1adir otro nodo como hijo: 1 2 SKNode * miGrupo = [ SKNode node ]; [ miGrupo addChild : miNodo ]; El agrupamiento jer\u00e1rquico de nodos es importante porque nos permitir\u00e1 por ejemplo mover de forma conjunta todo un grupo de nodos cambiando \u00fanicamente la posici\u00f3n del nodo padre. Encontraremos tambi\u00e9n m\u00e9todos y propiedades para conocer qui\u00e9n es el padre de un nodo, eliminar un hijo de un nodo, o moverlo a otro nodo padre, entre otras funciones.","title":"Nodos de la escena"},{"location":"spritekit.html#acciones","text":"Los nodos de la escena nos permiten ejecutar acciones, que modifican las propiedades del nodos (como su posici\u00f3n o rotaci\u00f3n) a lo largo del tiempo. Estas acciones se definen como objetos de la clase SKAction . Dentro de SKAction encontramos n\u00famerosos m\u00e9todos factor\u00eda para crear diferentes tipos de acciones. Por ejemplo, tenemos acciones para mover un nodo a una posici\u00f3n o rotarlo a un cierto \u00e1ngulo: 1 2 3 4 SKAction * accionMoverFinal = [ SKAction moveTo : CGPointMake ( 200 , 200 ) duration : 2.0 ]; SKAction * accionRotarFinal = [ SKAction rotateToAngle : 3.14f duration : 1.0 ]; SKAction * accionMoverInicio = [ SKAction moveTo : CGPointMake ( 100 , 100 ) duration : 2.0 ]; SKAction * accionRotarInicio = [ SKAction rotateToAngle : 0.0f duration : 1.0 ]; En estas acciones se indica la posici\u00f3n o \u00e1ngulo destino a la que se mover\u00e1 el nodo, y el tiempo que tardar\u00e1 en hacerlo (en segundo). Existen tambi\u00e9n otros muchos tipos de acciones para modificar otras propiedades como la escala, la textura, el color o el control de audio. Tambi\u00e9n encontramos acciones que nos permiten combinar otras acciones, o repetirlas: 1 2 SKAction * accionSecuencia = [ SKAction sequence : @{ accionMoverFinal , accionRotarFinal , accionMoverInicio , accionRotarInicio } ]; SKAction * accionRepite = [ SKAction repeatActionForever : accionSecuencia ]; Con esta \u00faltima acci\u00f3n podemos especificar por ejemplo el movimiento de \"patrulla\" de un enemigo, que se mover\u00e1 cont\u00ednuamente entre los puntos (100, 100) y (200, 200) . Podemos ejecutar cualquiera de las acciones anteriores sobre cualquier nodo, utilizando el m\u00e9todo runAction: de la clase SKNode : 1 [ miNodo runAction : accionRepite ]; De esta forma dicho nodo reproducir\u00e1 la conducta especificada por la acci\u00f3n. Podremos parar todas las acciones de un nodo con removeAllActions . Tambi\u00e9n podemos a\u00f1adir una acci\u00f3n con una clave ( key ) que posteriormente nos permitir\u00e1 parar \u00fanicamente dicha acci\u00f3n, o podemos ejecutar una acci\u00f3n proporcionando un bloque de c\u00f3digo que se ejecutar\u00e1 cuando la acci\u00f3n se complete.","title":"Acciones"},{"location":"sprites_e_interaccion.html","text":"Sprites \u00b6 En esta sesi\u00f3n vamos a ver un componente b\u00e1sico de los videojuegos: los sprites . Vamos a ver las herramientas y t\u00e9cnicas para tratar estos elementos de forma apropiada, c\u00f3mo animarlos, moverlos por la pantalla y detectar colisiones entre ellos. Los sprites hemos dicho que son todos aquellos objetos de la escena que se mueven y/o podemos interactuar con ellos de alguna forma. B\u00e1sicamente, un sprite se compone de: Su posici\u00f3n en la escena. Una imagen o animaci\u00f3n (por ejemplo el ciclo de andar de un personaje). La forma m\u00e1s b\u00e1sica de crear el sprite es a partir de una imagen est\u00e1tica, pero habitualmente utilizaremos un conjunto de fotogramas con los que componer diferentes animaciones del sprite . Fotogramas \u00b6 Para animar un sprite deberemos definir los distintos fotogramas (o frames ) de la animaci\u00f3n. Podemos definir varias animaciones para cada sprite , seg\u00fan las acciones que pueda hacer. Por ejemplo, nuestro personaje puede tener una animaci\u00f3n para andar y otra para correr. El sprite tendr\u00e1 un determinado tama\u00f1o (ancho y alto), y cada fotograma ser\u00e1 una imagen de este tama\u00f1o. Cambiando el fotograma que se muestra del sprite en cada momento podremos animarlo. Para ello deberemos tener im\u00e1genes para los distintos fotogramas del sprite . Sin embargo, la memoria de v\u00eddeo es un recurso cr\u00edtico, y debemos aprovechar al m\u00e1ximo el espacio de las texturas que se almacenan en ella. El tama\u00f1o de las texturas en memoria de video debe ser potencia de 2, lo cual en ocasiones nos obliga a dejar zonas en blanco en cada imagen. Adem\u00e1s, conviene evitar empaquetar con la aplicaci\u00f3n un gran n\u00famero de im\u00e1genes, ya que esto har\u00e1 que el espacio que ocupen sea mayor, y que la carga de las mismas resulte m\u00e1s costosa. Para almacenar los fotogramas de los sprites de forma \u00f3ptima, utilizamos lo que se conoce como sprite sheets . Se trata de im\u00e1genes en las que incluyen de forma conjunta todos los fotogramas de los sprites , dispuestos en forma de mosaico. Podemos crear estos sprite sheets de forma manual, aunque encontramos herramientas que nos facilitar\u00e1n en\u00f3rmemente este trabajo, como: TexturePacker (http://www.texturepacker.com). Se trata de una herramienta muy completa, que cuenta con una versi\u00f3n b\u00e1sica gratuita,y opciones adicionales de pago. Adem\u00e1s de organizar los sprites de forma \u00f3ptima en el espacio de una textura OpenGL, nos permite optimizar el formato de la textura. Esta herramienta permite generar los sprite sheets en varios formatos reconocidos por los diferentes motores de videojuegos, como por ejemplo Unity, SpriteKit, Cocos2d-x,y libgdx. FreeTexturePacker (http://free-tex-packer.com). Se trata de una buena alternativa open source a la aplicaci\u00f3n anterior. Shoebox (https://renderhjs.net/shoebox/). Conjunto de herramientas gratuito desarrollado en Adobe Air, de ayuda para el desarrollo de videojuegos, entre las que se encuentra la generaci\u00f3n de sprite sheets . Con estas herramientas simplemente tendremos que arrastrar sobre ellas el conjunto de im\u00e1genes con los distintos fotogramas de nuestros sprites , y nos generar\u00e1n una textura optimizada para OpenGL con todos ellos dispuestos en forma de mosaico. Cuando almacenemos esta textura generada, normalmente se guardar\u00e1 un fichero .png con la textura, y un fichero de metadatos que contendr\u00e1 informaci\u00f3n sobre los distintos fotogramas que contiene la textura, y la regi\u00f3n que ocupa cada uno de ellos. Para poder utilizar los fotogramas a\u00f1adidos a la textura deberemos contar con alg\u00fan mecanismo que nos permita mostrar en pantalla de forma independiente cada regi\u00f3n de la textura anterior (cada fotograma). En pr\u00e1cticamente todos los motores para videojuegos encontraremos mecanismos para hacer esto. El motor ser\u00e1 capaz de leer el fichero de metadatos del spritesheet , y con esto nos permitir\u00e1 utilizar cada fotograma ( frame ) de forma independiente, pero almacen\u00e1ndolos internamente en una \u00fanica textura. Animaciones \u00b6 Podremos definir determinadas secuencias de frames para crear animaciones. Cada animaci\u00f3n se compondr\u00e1 de: Secuencia de fotogramas ( frames ) Periodicidad (tiempo que se tarde en cambiar de fotograma) Determinados motores nos dar\u00e1n facilidades para crear estas animaciones y aplicarlas sobre los sprites , de forma que se reproduzcan de forma autom\u00e1tica. Sprite batch \u00b6 En OpenGL los sprites se dibujan realmente en un contexto 3D. Es decir, son texturas que se mapean sobre pol\u00edgonos 3D (concretamente con una geometr\u00eda rect\u00e1ngular). Muchas veces encontramos en pantalla varios sprites que utilizan la misma textura (o distintas regiones de la misma textura, como hemos visto en el caso de los sprite sheets ). Podemos optimizar el dibujado de estos sprites generando la geometr\u00eda de todos ellos de forma conjunta en una \u00fanica operaci\u00f3n con la GPU. Esto ser\u00e1 posible s\u00f3lo cuando el conjunto de sprites a dibujar est\u00e9n contenidos en una misma textura. Esto es lo que se conoce como un sprite batch (dibujamos un conjunto de sprites mediante una \u00fanica operaci\u00f3n). Algunos motores 2D nos permitir\u00e1n utilizar esta caracter\u00edstica para optimizar el dibujado. Colisiones \u00b6 Otro aspecto importante de los sprites es la interacci\u00f3n entre ellos. Nos interesar\u00e1 saber cu\u00e1ndo somos tocados por un enemigo o una bala para disminuir la vida, o cu\u00e1ndo alcanzamos nosotros a nuestro enemigo. Para ello deberemos detectar las colisiones entre sprites . La colisi\u00f3n con sprites de formas complejas puede resultar costosa de calcular. Por ello se suele realizar el c\u00e1lculo de colisiones con una forma aproximada de los sprites con la que esta operaci\u00f3n resulte m\u00e1s sencilla. Para ello solemos utilizar el bounding box , es decir, un rect\u00e1ngulo que englobe el sprite . La intersecci\u00f3n de rect\u00e1ngulos es una operaci\u00f3n muy sencilla. En algunos casos nos puede interesar modificar el tama\u00f1o del bounding box respecto al \u00e1rea que ocupa el sprite en pantalla. Por ejemplo, puede ser una buena pr\u00e1ctica hacerlo m\u00e1s peque\u00f1o para evitar que cuando un enemigo \"roce\" una esquina del \u00e1rea del sprite nos mate, lo cual puede ser muy frustrante para el jugador. En algunos motores encontraremos de forma separada las propiedades size y boundingBox de los sprites .","title":"_Sprites_"},{"location":"sprites_e_interaccion.html#sprites","text":"En esta sesi\u00f3n vamos a ver un componente b\u00e1sico de los videojuegos: los sprites . Vamos a ver las herramientas y t\u00e9cnicas para tratar estos elementos de forma apropiada, c\u00f3mo animarlos, moverlos por la pantalla y detectar colisiones entre ellos. Los sprites hemos dicho que son todos aquellos objetos de la escena que se mueven y/o podemos interactuar con ellos de alguna forma. B\u00e1sicamente, un sprite se compone de: Su posici\u00f3n en la escena. Una imagen o animaci\u00f3n (por ejemplo el ciclo de andar de un personaje). La forma m\u00e1s b\u00e1sica de crear el sprite es a partir de una imagen est\u00e1tica, pero habitualmente utilizaremos un conjunto de fotogramas con los que componer diferentes animaciones del sprite .","title":"Sprites"},{"location":"sprites_e_interaccion.html#fotogramas","text":"Para animar un sprite deberemos definir los distintos fotogramas (o frames ) de la animaci\u00f3n. Podemos definir varias animaciones para cada sprite , seg\u00fan las acciones que pueda hacer. Por ejemplo, nuestro personaje puede tener una animaci\u00f3n para andar y otra para correr. El sprite tendr\u00e1 un determinado tama\u00f1o (ancho y alto), y cada fotograma ser\u00e1 una imagen de este tama\u00f1o. Cambiando el fotograma que se muestra del sprite en cada momento podremos animarlo. Para ello deberemos tener im\u00e1genes para los distintos fotogramas del sprite . Sin embargo, la memoria de v\u00eddeo es un recurso cr\u00edtico, y debemos aprovechar al m\u00e1ximo el espacio de las texturas que se almacenan en ella. El tama\u00f1o de las texturas en memoria de video debe ser potencia de 2, lo cual en ocasiones nos obliga a dejar zonas en blanco en cada imagen. Adem\u00e1s, conviene evitar empaquetar con la aplicaci\u00f3n un gran n\u00famero de im\u00e1genes, ya que esto har\u00e1 que el espacio que ocupen sea mayor, y que la carga de las mismas resulte m\u00e1s costosa. Para almacenar los fotogramas de los sprites de forma \u00f3ptima, utilizamos lo que se conoce como sprite sheets . Se trata de im\u00e1genes en las que incluyen de forma conjunta todos los fotogramas de los sprites , dispuestos en forma de mosaico. Podemos crear estos sprite sheets de forma manual, aunque encontramos herramientas que nos facilitar\u00e1n en\u00f3rmemente este trabajo, como: TexturePacker (http://www.texturepacker.com). Se trata de una herramienta muy completa, que cuenta con una versi\u00f3n b\u00e1sica gratuita,y opciones adicionales de pago. Adem\u00e1s de organizar los sprites de forma \u00f3ptima en el espacio de una textura OpenGL, nos permite optimizar el formato de la textura. Esta herramienta permite generar los sprite sheets en varios formatos reconocidos por los diferentes motores de videojuegos, como por ejemplo Unity, SpriteKit, Cocos2d-x,y libgdx. FreeTexturePacker (http://free-tex-packer.com). Se trata de una buena alternativa open source a la aplicaci\u00f3n anterior. Shoebox (https://renderhjs.net/shoebox/). Conjunto de herramientas gratuito desarrollado en Adobe Air, de ayuda para el desarrollo de videojuegos, entre las que se encuentra la generaci\u00f3n de sprite sheets . Con estas herramientas simplemente tendremos que arrastrar sobre ellas el conjunto de im\u00e1genes con los distintos fotogramas de nuestros sprites , y nos generar\u00e1n una textura optimizada para OpenGL con todos ellos dispuestos en forma de mosaico. Cuando almacenemos esta textura generada, normalmente se guardar\u00e1 un fichero .png con la textura, y un fichero de metadatos que contendr\u00e1 informaci\u00f3n sobre los distintos fotogramas que contiene la textura, y la regi\u00f3n que ocupa cada uno de ellos. Para poder utilizar los fotogramas a\u00f1adidos a la textura deberemos contar con alg\u00fan mecanismo que nos permita mostrar en pantalla de forma independiente cada regi\u00f3n de la textura anterior (cada fotograma). En pr\u00e1cticamente todos los motores para videojuegos encontraremos mecanismos para hacer esto. El motor ser\u00e1 capaz de leer el fichero de metadatos del spritesheet , y con esto nos permitir\u00e1 utilizar cada fotograma ( frame ) de forma independiente, pero almacen\u00e1ndolos internamente en una \u00fanica textura.","title":"Fotogramas"},{"location":"sprites_e_interaccion.html#animaciones","text":"Podremos definir determinadas secuencias de frames para crear animaciones. Cada animaci\u00f3n se compondr\u00e1 de: Secuencia de fotogramas ( frames ) Periodicidad (tiempo que se tarde en cambiar de fotograma) Determinados motores nos dar\u00e1n facilidades para crear estas animaciones y aplicarlas sobre los sprites , de forma que se reproduzcan de forma autom\u00e1tica.","title":"Animaciones"},{"location":"sprites_e_interaccion.html#sprite-batch","text":"En OpenGL los sprites se dibujan realmente en un contexto 3D. Es decir, son texturas que se mapean sobre pol\u00edgonos 3D (concretamente con una geometr\u00eda rect\u00e1ngular). Muchas veces encontramos en pantalla varios sprites que utilizan la misma textura (o distintas regiones de la misma textura, como hemos visto en el caso de los sprite sheets ). Podemos optimizar el dibujado de estos sprites generando la geometr\u00eda de todos ellos de forma conjunta en una \u00fanica operaci\u00f3n con la GPU. Esto ser\u00e1 posible s\u00f3lo cuando el conjunto de sprites a dibujar est\u00e9n contenidos en una misma textura. Esto es lo que se conoce como un sprite batch (dibujamos un conjunto de sprites mediante una \u00fanica operaci\u00f3n). Algunos motores 2D nos permitir\u00e1n utilizar esta caracter\u00edstica para optimizar el dibujado.","title":"Sprite batch"},{"location":"sprites_e_interaccion.html#colisiones","text":"Otro aspecto importante de los sprites es la interacci\u00f3n entre ellos. Nos interesar\u00e1 saber cu\u00e1ndo somos tocados por un enemigo o una bala para disminuir la vida, o cu\u00e1ndo alcanzamos nosotros a nuestro enemigo. Para ello deberemos detectar las colisiones entre sprites . La colisi\u00f3n con sprites de formas complejas puede resultar costosa de calcular. Por ello se suele realizar el c\u00e1lculo de colisiones con una forma aproximada de los sprites con la que esta operaci\u00f3n resulte m\u00e1s sencilla. Para ello solemos utilizar el bounding box , es decir, un rect\u00e1ngulo que englobe el sprite . La intersecci\u00f3n de rect\u00e1ngulos es una operaci\u00f3n muy sencilla. En algunos casos nos puede interesar modificar el tama\u00f1o del bounding box respecto al \u00e1rea que ocupa el sprite en pantalla. Por ejemplo, puede ser una buena pr\u00e1ctica hacerlo m\u00e1s peque\u00f1o para evitar que cuando un enemigo \"roce\" una esquina del \u00e1rea del sprite nos mate, lo cual puede ser muy frustrante para el jugador. En algunos motores encontraremos de forma separada las propiedades size y boundingBox de los sprites .","title":"Colisiones"},{"location":"unity.html","text":"El motor Unity \u00b6 Unity es un motor gen\u00e9rico para la creaci\u00f3n de videojuegos 2D y 3D enfocado hacia el desarrollo casual. La curva de aprendizaje del motor es bastante suave, especialmente si lo comparamos con motores m\u00e1s complejos como Unreal Engine 4, y nos permitir\u00e1 realizar un desarrollo r\u00e1pido de videojuegos. Esta caracter\u00edstica hace este motor muy apropiado tambi\u00e9n para crear prototipos r\u00e1pidos de nuestros juegos. A partir de la versi\u00f3n Unity 5, existen dos ediciones: Personal y Profesional . La primera es gratuita e incluye todas las funcionalidades del motor. La segunda incluye funcionalidades adicionales de soporte (construcci\u00f3n en la nube, herramientas de trabajo en equipo, etc), y es de pago (suscripci\u00f3n de $75 o pago \u00fanico de $1.500). La versi\u00f3n Personal podr\u00e1 ser utilizada por cualquier individuo o empresa cuyas ganancias anuales no superen los $100.000. Uno de los puntos fuertes de Unity es la posibilidad de exportar a gran cantidad de plataformas. Soporta las plataformas m\u00f3viles iOS, Android, Windows Phone y Blackberry , y adem\u00e1s tambi\u00e9n permite exportar a web (WebGL), a videoconsolas (PS4, PS3, PS Vita, Xbox One, Xbox 360, Wii U, etc) y a ordenadores (Mac, Windows y Linux). Introducci\u00f3n a Unity \u00b6 El editor de Unity \u00b6 Unity incorpora su propia herramienta integrada para la creaci\u00f3n de videojuegos, que nos permite incluso crear algunos videojuegos de forma visual sin la necesidad de programar. Dentro del entorno del editor de Unity encontramos diferentes paneles, de los cuales destacamos los siguientes: Project : Encontramos aqu\u00ed todos los recursos ( assets ) que componen nuestro proyecto. Estos recursos pueden ser por ejemplo texturas, clips de audio, scripts , o escenas. Destacamos aqu\u00ed el asset de tipo escena , que es el componente que nos permite definir cada estado (pantalla) del juego. Al hacer doble click sobre una escena se abrir\u00e1 para trabajar con ella desde el editor. Hierarchy : La escena est\u00e1 formada por una serie de nodos ( game objects ) organizados de forma jer\u00e1rquica. En este panel vemos el \u00e1rbol de objetos que contiene la escena abierta actualmente. Podemos seleccionar en ella cualquier objeto pulsando sobre su nombre. Scene : En este panel vemos de forma visual los elementos de la escena actual. Podremos movernos libremente por el espacio 3D de la escena para ubicar de forma correcta cada game object y tener una previsualizaci\u00f3n del escenario del juego. Inspector : Muestra las propiedades del game object o el asset seleccionado actualmente en el entorno. Arquitectura Orientada a Componentes \u00b6 Como hemos comentado, todos los elementos de la escena son objetos de tipo GameObject organizados de forma jer\u00e1rquica. Todos los objetos son del mismo tipo, independientemente de la funci\u00f3n que desempe\u00f1en en el juego. Lo que diferencia a unos de otros son los componentes que incorporen. Cada objeto podr\u00e1 contener varios componentes, y estos componentes determinar\u00e1n las funciones del objeto. Por ejemplo, un objeto que incorpore un componente Camera ser\u00e1 capaz de renderizar en pantalla lo que se vea en la escena desde su punto de vista. Si adem\u00e1s incorpora un componente Light , emitir\u00e1 luz que se proyectar\u00e1 sobre otros elementos de la escena, y si tiene un componente Renderer , tendr\u00e1 un contenido gr\u00e1fico que se renderizar\u00e1 dentro de la escena. Esto es lo que se conoce como Arquitectura Basada en Componentes , que nos proporciona la ventaja de que las funcionalidades de los componentes se podr\u00e1n reutilizar en diferentes tipos de entidades del juego. Es especialmente \u00fatil cuando tener un gran n\u00famero de diferentes entidades en el juego, pero que comparten m\u00f3dulos de funcionalidad. En Unity esta arquitectura se implementa mediante agregaci\u00f3n. Si bien en todos los objetos de la escena son objetos que heredan de GameObject , \u00e9stos podr\u00e1n contener un conjunto de componentes de distintos tipos ( Light , Camera , Renderer , etc) que determinar\u00e1n el comportamiento del objeto. En el inspector podremos ver la lista de componentes que incorpora el objeto seleccionado actualmente, y modificar sus propiedades: La escena 3D \u00b6 El el editor de Unity veremos la escena con la que estemos trabajando actualmente, tanto de forma visual ( Scene ) como de forma jer\u00e1rquica ( Hierarchy ). Nos podremos mover por ella y podremos a\u00f1adir diferentes tipos de objetos. Posicionamiento de los objetos en la escena \u00b6 Todos los game objects incorporan al menos un componente Transform que nos permite situarlo en la escena, indicando su traslaci\u00f3n, orientaci\u00f3n y escala. Podremos introducir esta informaci\u00f3n en el editor, para as\u00ed poder ajustar la posici\u00f3n del objeto de forma precisa. Tambi\u00e9n podemos mover un objeto de forma visual desde la vista Scene . Al seleccionar un objeto, bien en Scene o en Hierarchy , veremos sobre \u00e9l en Scene una serie de ejes que nos indicar\u00e1n que podemos moverlo. El tipo de ejes que se mostrar\u00e1n depender\u00e1 del tipo de transformaci\u00f3n que tengamos activa en la barra superior: Las posibles transformaciones son: Traslaci\u00f3n : Los ejes aparecer\u00e1n como flechas y nos permitir\u00e1n cambiar la posici\u00f3n del objeto. Rotaci\u00f3n : Veremos tres c\u00edrculos alrededor del objeto que nos pemtir\u00e1n rotarlo alrededor de sus ejes x , y , z . Escalado : Veremos los ejes acabando en cajas, indicando que podemos escalar el objeto en x , y , z . Si pinchamos sobre uno de los ejes y arrastramos, trasladaremos, rotaremos, o escalaremos el objeto s\u00f3lo en dicha eje. Si pinchamos sobre el objeto, pero no sobre ninguno de los ejes, podremos trasladarlo, rotarlo y escalarlo en todos los ejes al mismo tiempo. A\u00f1adir game objects a la escena \u00b6 Podemos a\u00f1adir a la escena nuevos game objects seleccionando en el men\u00fa la opci\u00f3n GameObject > Create Empty , lo cual crear\u00e1 un nuevo objeto vac\u00edo con un \u00fanico componente Transform , al que le deber\u00edamos a\u00f1adir los componentes que necesit\u00e1semos, o bien podemos crear objetos ya predefinidos mediante GameObject > Create Other . Entre los tipos de objetos predefinidos que nos permite crear, encontramos diferentes formas geom\u00e9tricas como Cube , Sphere , Capsule o Plane entre otras. Estas figuras pueden resultarnos de utilidad como objetos impostores en primeras versiones del juego en las que todav\u00eda no contamos con nuestros propios modelos gr\u00e1ficos. Por ejemplo, podr\u00edamos utilizar un cubo que de momento haga el papel de nuestro personaje hasta que contemos con su modelo 3D. Podremos organizar de forma jer\u00e1rquica los objetos de la escena mediante la vista Hierarchy . Si arrastramos un game object sobre otro en esta vista, haremos que pase a ser su hijo en el \u00e1rbol de la escena. Los objetos vac\u00edos con un \u00fanico componente Transform pueden sernos de gran utilidad para agrupar dentro de \u00e9l varios objetos. De esta forma, moviendo el objeto padre podremos mover de forma conjunta todos los objetos que contiene. De esta forma estaremos creando objetos compuestos. Tambi\u00e9n resulta de utilidad dar nombre a los objetos de la escena, para poder identificarlos f\u00e1cilmente. Si hacemos click sobre el nombre de un objeto en la vista Hierarchy podremos editarlo y darle un nombre significativo (por ejemplo Suelo , Pared , Enemigo , etc). Navegaci\u00f3n en la escena \u00b6 Adem\u00e1s de podemos a\u00f1adir objetos a la escena y moverlos a diferentes posiciones, deberemos poder movernos por la escena para posicionarnos en los puntos de vista que nos interesen para crear el contenido. Ser\u00e1 importante conocer una serie de atajos de teclado para poder movernos con fluidez a trav\u00e9s de la escena. Encontramos tres tipos de movimientos b\u00e1sicos para movernos por la escena en el editor: Traslaci\u00f3n lateral : Hacemos click sobre la escena y arrastramos el rat\u00f3n. Giro : Pulsamos Alt + click y arrastramos el rat\u00f3n para girar nuestro punto de vista. Avance : Pultamos Ctrl + click y arrastramos el rat\u00f3n, o bien movemos la rueda del rat\u00f3n para avanzar hacia delante o hace atr\u00e1s en la direcci\u00f3n en la que estamos mirando. Con los comandos anteriores podremos desplazarnos libremente sobre la escena, pero tambi\u00e9n es importante conocer otras forma m\u00e1s directas de movernos a la posici\u00f3n que nos interese: Ver un objeto : Si nos interesa ir r\u00e1pidamente a un punto donde veamos de cerca un objeto concreto de la escena, podemos hacer doble click sobre dicho objeto en la vista Hierarchy . Alineaci\u00f3n con un objeto : Alinea la vista de la escena con el objeto seleccionado. Es especialmente \u00fatil cuando se utiliza con la c\u00e1mara, ya que veremos la escena tal como se estar\u00eda bien desde la camara. Para hacer esto, seleccionaremos el game object con el que nos queramos alinear y seleccionaremos la opci\u00f3n del men\u00fa GameObject > Align View To Selected . Interfaz de usuario \u00b6 El sistema con el que cuenta Unity para crear la interfaz de usuario se introdujo a partir de la versi\u00f3n 4.6. Se trata de un sistema bastante vers\u00e1til, que utilizado de forma adecuada nos permite crear interfaces como por ejemplo los men\u00fas o el HUD del juego que se adapten a diferentes tama\u00f1os y formas de pantalla. Todo el contenido de la interfaz de usuario estar\u00e1 contenido en nuestra escena dentro de un elemento tipo Canvas (es decir, un game object que cuente con un componente Canvas ). Dentro de \u00e9l ubicaremos todos los componentes de la interfaz, como por ejemplo im\u00e1genes, etiquetas de texto o botones. Canvas \u00b6 El Canvas ser\u00e1 el panel 2D ( lienzo ) donde podremos crear el contenido de la interfaz de usuario. Los componentes de la interfaz siempre deber\u00e1n estar dentro de un Canvas en la jerarqu\u00eda de la de escena. Si intentamos arrastrar sobre la escena un componente de la UI sin un Canvas , el Canvas se crear\u00e1 de forma autom\u00e1tica. Una propiedad importante del componente Canvas es Render Mode , que podr\u00e1 tomar 3 valores: Screen Space - Overlay : El Canvas se dibuja sobre el contenido que aparece en pantalla, ajust\u00e1ndose siempre al tama\u00f1o de la misma. Screen Space - Camera : Similar a la anterior, pero en este caso debemos vincularlo a una c\u00e1mara, indicando la distancia a la que estar\u00e1 el Canvas de la c\u00e1mara seleccionada, y el Canvas se ajustar\u00e1 al tama\u00f1o que tenga el tronco de la c\u00e1mara a dicha distancia. Se aplicar\u00e1n sobre el Canvas los par\u00e1metros de la c\u00e1mara seleccionada. World Space : En este caso el Canvas se comportar\u00e1 como cualquier otro objeto 3D en la escena. Le daremos un tama\u00f1o fijo al panel y lo situaremos en una posici\u00f3n del mundo. As\u00ed podremos tener interfaces con las que podamos interactuar en nuestro mundo 3D. En la previsualizaci\u00f3n de la escena, cuando tengamos un Canvas de tipo Screen Space es posible que lo veamos de un tama\u00f1o mucho mayor que el resto de elementos de la escena. Esto se debe a que las unidades con las que trabaja internamente el Canvas son pixels en pantalla, mientras que es habitual que los elementos de la escena tengan dimensiones de alrededor de una unidad. Al ejecutar el juego no habr\u00e1 ning\u00fan problema ya que el Canvas se ajustar\u00e1 al tama\u00f1o de la pantalla o de la c\u00e1mara. Elementos de la UI \u00b6 Posicionamiento en el espacio de la UI \u00b6 Escalado del Canvas \u00b6 Normalmente en nuestro Canvas encontraremos un componente adicional que es el CanvasScaler . Se trata de un elemento importante a la hora de conseguir interfaces adaptables, ya que nos permite personalizar la forma en la que se escala el contenido del Canvas a distintos tama\u00f1os de pantalla. Podemos optar por tres modos: Constant Pixel Size Scale With Screen Size Constant Physical Size Realidad Virtual \u00b6 Existen diferentes dispositivos de realidad virtual, que nos proporcionan una inmersi\u00f3n casi total en la escena, reflejando en la c\u00e1mara los movimientos de nuestra cabeza, y proporcionando una visi\u00f3n estereosc\u00f3pica de la escena. Entre los dispositivos m\u00e1s famosos se encuentran Oculus Rift, Samsung Gear VR y Google Cardboard. Aunque todos estos dispositivos proporcionan su propio SDK que podemos integrar en las plataformas nativas de desarrollo, es de especial inter\u00e9s su integraci\u00f3n en el entorno Unity, que nos permitir\u00e1 realizar aplicaciones que los soporten de forma casi inmediata. A continuaci\u00f3n veremos c\u00f3mo utilizarlos con este entorno. Oculus Rift / Samsung Gear VR \u00b6 A partir de Unity 5.1 encontramos en este entorno soporte nativo para los dispositivos Oculus Rift y Samsung Gear VR. Ambos utilizan el mismo SDK y herramientas, con la diferencia de que Oculus Rift funciona sobre plataformas de sobremesa, mientras que Samsung Gear VR funciona sobre m\u00f3viles Samsung. Para activar el soporte para estos dispositivos en Unity simplemente tendremos que entrar en Player Settings ( Edit > Project Settings > Player ) y bien dentro de la plataforma Standalone (para Oculus Rift) o Android (para Samsung Gear VR) marcar la casilla Virtual Reality Supported , dentro de la secci\u00f3n Other Settings > Rendering . Una vez hecho esto, autom\u00e1ticamente la c\u00e1mara de la escena se comportar\u00e1 como una c\u00e1mara VR, girando cuando giremos la cabeza y renderizando una imagen para cada ojo, para as\u00ed proporcionar visi\u00f3n est\u00e9reo. Despliegue de la aplicaci\u00f3n en un dispositivo de prueba Antes de desplegar la aplicaci\u00f3n en un dispositivo de prueba, deberemos a\u00f1adir una firma que nos deber\u00e1 proporcionar Oculus para nuestro dispositivo concreto. Dicha firma s\u00f3lo se necesitar\u00e1 durante el desarrollo, cuando la aplicaci\u00f3n se publique ya no har\u00e1 falta. Para conseguir la firma en primer lugar necesitamos obtener el ID de nuestro dispositivo. Para ello lo conectaremos al sistema y ejecutaremos el comando: 1 adb devices En la lista de dispositivos en la primera columna veremos los IDs que buscamos, con el siguiente formato: 1 2 * daemon started successfully * 1235 ba5e7a311272 device En este caso, el ID que buscamos ser\u00eda 1235ba5e7a311272 . Una vez localizado dicho ID, iremos a la siguiente p\u00e1gina para solicitar la firma e introduciremos el ID (necesitaremos registrarnos previamente como usuarios de Oculus Developer, si no tenemos cuenta todav\u00eda): https://developer.oculus.com/osig/ Una vez introducido el ID nos descargar\u00e1 un fichero .osig que deber\u00e1 ser introducido en nuestro proyecto de Unity en el siguiente directorio: 1 Assets / Plugins / Android / assets Esto lo que har\u00e1 ser\u00e1 colocar dicho fichero en el directorio assets del proyecto Unity resultante. Una vez hecho esto ya podremos probar la aplicaci\u00f3n en un dispositivo Samsung con Gear VR seleccionando la plataforma Android y pulsando sobre Build & Run . Al desplegar la aplicaci\u00f3n en el m\u00f3vil Samsung, veremos que al ejecutarla nos pide conectar el dispositivo Gear VR al m\u00f3vil. Una vez conectado, se ejecutar\u00e1 la aplicaci\u00f3n y podremos ver nuestra escena de Unity de forma inmersiva. Sin embargo, veremos que la imagen aparece algo distorsionada al verla a trav\u00e9s de las lentes del Gear VR. Esto se debe a que aunque la c\u00e1mara renderiza en est\u00e9reo y responde al movimiento de la cabeza, no se realiza la correcci\u00f3n adecuada a la imagen para verla a trav\u00e9s de las lentes del Gear VR. Utilidades de Oculus Aunque la c\u00e1mara de Unity puede ser utilizada para aplicaciones de VR, hemos visto que tiene algunas carencias como por ejemplo el no realizar una correcci\u00f3n de la distorsi\u00f3n que realiza la lente. Para poder resolver estas carencias y tener la posibilidad de configurar e implementar diferentes componentes de la aplicaci\u00f3n VR, Oculus proporciona una serie de utilidades en forma de paquete de assets para Unity que podemos descargar desde su web: https://developer.oculus.com/downloads/ Desde esta p\u00e1gina podremos bajar tanto versiones actualizadas del plugin de Oculus/Gear para Unity ( OVR Plugin for Unity 5 ) como las utilidades adicionales ( Oculus Utilities for Unity 5 ). Para instalar el plugin simplemente tendremos que buscar dentro del directorio de instalaci\u00f3n de Unity el directorio VR (en caso de MacOS tendremos que mirar dentro del contenido del paquete Unity para localizar dicho directorio), y dentro de \u00e9l sustituir el directorio oculus y todo su contenido por el proporcionado por el plugin . Una vez actualizado el plugin podremos a\u00f1adir las utilities carg\u00e1ndolo en el proyecto como paquete de assets . Uno de los assets m\u00e1s \u00fatiles es el prefab OVRCameraRig . Podemos utilizarlo en la escena en lugar de la c\u00e1mara de Unity, y nos permitir\u00e1 configurar diferentes propiedades de la c\u00e1mara en la escena 3D, como por ejemplo la distancia entre los ojos. Adem\u00e1s, aplicar\u00e1 de forma correcta la correcci\u00f3n a la distorsi\u00f3n introducida por las lentes. Modo de desarrollador En los casos anteriores hemos probado la aplicaci\u00f3n con el dispositivo Gear VR. Sin embargo, durante el desarrollo nos podr\u00eda interesar poder probar la aplicaci\u00f3n en el m\u00f3vil sin la necesidad de tener que conectarlo al Gear VR. Podemos conseguir esto activando el modo desarrollador de Gear VR en el dispositivo m\u00f3vil Samsung. Para poder hacer esto antes deberemos haber instalado alguna aplicaci\u00f3n nuestra con la firma osig , en caso contrario no nos permitir\u00e1 activarlo. Para activar el modo de desarrollador de Gear VR deberemos entra en Ajustes > Aplicaciones > Administrador de aplicaciones > Gear VR Service > Almacenamiento > Administrar almacenamiento y pulsar repetidas veces sobre VR Service Version . Tras hacer esto nos aparecer\u00e1n opciones para activar el modo de desarrollador. Con este modo activo podremos lanzar la aplicaci\u00f3n en el m\u00f3vil sin tener que conectar el dispositivo Gear VR, lo cual agilizar\u00e1 el desarrollo. Esta forma de probar la aplicaci\u00f3n tendr\u00e1 la limitaci\u00f3n de que no reconocer\u00e1 el giro de la c\u00e1mara, ya que los sensores que utilizan estas aplicaciones para obtener la inclinaci\u00f3n de la cabeza van integrados en el dispositivo Gear VR. Google Cardboard \u00b6 Unity no incluye soporte nativo para Google Cardboard, pero podemos encontrar un plugin muy sencillo de utilizar en la web oficial: https://developers.google.com/cardboard/unity El plugin consiste en un paquete de assets que podemos incluir en nuestro proyecto (deberemos a\u00f1adir todo su contenido). La forma m\u00e1s sencilla de a\u00f1adir soporte para Cardboard es a\u00f1adir a nuestra c\u00e1mara el script StereoController :","title":"Unity"},{"location":"unity.html#el-motor-unity","text":"Unity es un motor gen\u00e9rico para la creaci\u00f3n de videojuegos 2D y 3D enfocado hacia el desarrollo casual. La curva de aprendizaje del motor es bastante suave, especialmente si lo comparamos con motores m\u00e1s complejos como Unreal Engine 4, y nos permitir\u00e1 realizar un desarrollo r\u00e1pido de videojuegos. Esta caracter\u00edstica hace este motor muy apropiado tambi\u00e9n para crear prototipos r\u00e1pidos de nuestros juegos. A partir de la versi\u00f3n Unity 5, existen dos ediciones: Personal y Profesional . La primera es gratuita e incluye todas las funcionalidades del motor. La segunda incluye funcionalidades adicionales de soporte (construcci\u00f3n en la nube, herramientas de trabajo en equipo, etc), y es de pago (suscripci\u00f3n de $75 o pago \u00fanico de $1.500). La versi\u00f3n Personal podr\u00e1 ser utilizada por cualquier individuo o empresa cuyas ganancias anuales no superen los $100.000. Uno de los puntos fuertes de Unity es la posibilidad de exportar a gran cantidad de plataformas. Soporta las plataformas m\u00f3viles iOS, Android, Windows Phone y Blackberry , y adem\u00e1s tambi\u00e9n permite exportar a web (WebGL), a videoconsolas (PS4, PS3, PS Vita, Xbox One, Xbox 360, Wii U, etc) y a ordenadores (Mac, Windows y Linux).","title":"El motor Unity"},{"location":"unity.html#introduccion-a-unity","text":"","title":"Introducci\u00f3n a Unity"},{"location":"unity.html#el-editor-de-unity","text":"Unity incorpora su propia herramienta integrada para la creaci\u00f3n de videojuegos, que nos permite incluso crear algunos videojuegos de forma visual sin la necesidad de programar. Dentro del entorno del editor de Unity encontramos diferentes paneles, de los cuales destacamos los siguientes: Project : Encontramos aqu\u00ed todos los recursos ( assets ) que componen nuestro proyecto. Estos recursos pueden ser por ejemplo texturas, clips de audio, scripts , o escenas. Destacamos aqu\u00ed el asset de tipo escena , que es el componente que nos permite definir cada estado (pantalla) del juego. Al hacer doble click sobre una escena se abrir\u00e1 para trabajar con ella desde el editor. Hierarchy : La escena est\u00e1 formada por una serie de nodos ( game objects ) organizados de forma jer\u00e1rquica. En este panel vemos el \u00e1rbol de objetos que contiene la escena abierta actualmente. Podemos seleccionar en ella cualquier objeto pulsando sobre su nombre. Scene : En este panel vemos de forma visual los elementos de la escena actual. Podremos movernos libremente por el espacio 3D de la escena para ubicar de forma correcta cada game object y tener una previsualizaci\u00f3n del escenario del juego. Inspector : Muestra las propiedades del game object o el asset seleccionado actualmente en el entorno.","title":"El editor de Unity"},{"location":"unity.html#arquitectura-orientada-a-componentes","text":"Como hemos comentado, todos los elementos de la escena son objetos de tipo GameObject organizados de forma jer\u00e1rquica. Todos los objetos son del mismo tipo, independientemente de la funci\u00f3n que desempe\u00f1en en el juego. Lo que diferencia a unos de otros son los componentes que incorporen. Cada objeto podr\u00e1 contener varios componentes, y estos componentes determinar\u00e1n las funciones del objeto. Por ejemplo, un objeto que incorpore un componente Camera ser\u00e1 capaz de renderizar en pantalla lo que se vea en la escena desde su punto de vista. Si adem\u00e1s incorpora un componente Light , emitir\u00e1 luz que se proyectar\u00e1 sobre otros elementos de la escena, y si tiene un componente Renderer , tendr\u00e1 un contenido gr\u00e1fico que se renderizar\u00e1 dentro de la escena. Esto es lo que se conoce como Arquitectura Basada en Componentes , que nos proporciona la ventaja de que las funcionalidades de los componentes se podr\u00e1n reutilizar en diferentes tipos de entidades del juego. Es especialmente \u00fatil cuando tener un gran n\u00famero de diferentes entidades en el juego, pero que comparten m\u00f3dulos de funcionalidad. En Unity esta arquitectura se implementa mediante agregaci\u00f3n. Si bien en todos los objetos de la escena son objetos que heredan de GameObject , \u00e9stos podr\u00e1n contener un conjunto de componentes de distintos tipos ( Light , Camera , Renderer , etc) que determinar\u00e1n el comportamiento del objeto. En el inspector podremos ver la lista de componentes que incorpora el objeto seleccionado actualmente, y modificar sus propiedades:","title":"Arquitectura Orientada a Componentes"},{"location":"unity.html#la-escena-3d","text":"El el editor de Unity veremos la escena con la que estemos trabajando actualmente, tanto de forma visual ( Scene ) como de forma jer\u00e1rquica ( Hierarchy ). Nos podremos mover por ella y podremos a\u00f1adir diferentes tipos de objetos.","title":"La escena 3D"},{"location":"unity.html#posicionamiento-de-los-objetos-en-la-escena","text":"Todos los game objects incorporan al menos un componente Transform que nos permite situarlo en la escena, indicando su traslaci\u00f3n, orientaci\u00f3n y escala. Podremos introducir esta informaci\u00f3n en el editor, para as\u00ed poder ajustar la posici\u00f3n del objeto de forma precisa. Tambi\u00e9n podemos mover un objeto de forma visual desde la vista Scene . Al seleccionar un objeto, bien en Scene o en Hierarchy , veremos sobre \u00e9l en Scene una serie de ejes que nos indicar\u00e1n que podemos moverlo. El tipo de ejes que se mostrar\u00e1n depender\u00e1 del tipo de transformaci\u00f3n que tengamos activa en la barra superior: Las posibles transformaciones son: Traslaci\u00f3n : Los ejes aparecer\u00e1n como flechas y nos permitir\u00e1n cambiar la posici\u00f3n del objeto. Rotaci\u00f3n : Veremos tres c\u00edrculos alrededor del objeto que nos pemtir\u00e1n rotarlo alrededor de sus ejes x , y , z . Escalado : Veremos los ejes acabando en cajas, indicando que podemos escalar el objeto en x , y , z . Si pinchamos sobre uno de los ejes y arrastramos, trasladaremos, rotaremos, o escalaremos el objeto s\u00f3lo en dicha eje. Si pinchamos sobre el objeto, pero no sobre ninguno de los ejes, podremos trasladarlo, rotarlo y escalarlo en todos los ejes al mismo tiempo.","title":"Posicionamiento de los objetos en la escena"},{"location":"unity.html#anadir-game-objects-a-la-escena","text":"Podemos a\u00f1adir a la escena nuevos game objects seleccionando en el men\u00fa la opci\u00f3n GameObject > Create Empty , lo cual crear\u00e1 un nuevo objeto vac\u00edo con un \u00fanico componente Transform , al que le deber\u00edamos a\u00f1adir los componentes que necesit\u00e1semos, o bien podemos crear objetos ya predefinidos mediante GameObject > Create Other . Entre los tipos de objetos predefinidos que nos permite crear, encontramos diferentes formas geom\u00e9tricas como Cube , Sphere , Capsule o Plane entre otras. Estas figuras pueden resultarnos de utilidad como objetos impostores en primeras versiones del juego en las que todav\u00eda no contamos con nuestros propios modelos gr\u00e1ficos. Por ejemplo, podr\u00edamos utilizar un cubo que de momento haga el papel de nuestro personaje hasta que contemos con su modelo 3D. Podremos organizar de forma jer\u00e1rquica los objetos de la escena mediante la vista Hierarchy . Si arrastramos un game object sobre otro en esta vista, haremos que pase a ser su hijo en el \u00e1rbol de la escena. Los objetos vac\u00edos con un \u00fanico componente Transform pueden sernos de gran utilidad para agrupar dentro de \u00e9l varios objetos. De esta forma, moviendo el objeto padre podremos mover de forma conjunta todos los objetos que contiene. De esta forma estaremos creando objetos compuestos. Tambi\u00e9n resulta de utilidad dar nombre a los objetos de la escena, para poder identificarlos f\u00e1cilmente. Si hacemos click sobre el nombre de un objeto en la vista Hierarchy podremos editarlo y darle un nombre significativo (por ejemplo Suelo , Pared , Enemigo , etc).","title":"A\u00f1adir game objects a la escena"},{"location":"unity.html#navegacion-en-la-escena","text":"Adem\u00e1s de podemos a\u00f1adir objetos a la escena y moverlos a diferentes posiciones, deberemos poder movernos por la escena para posicionarnos en los puntos de vista que nos interesen para crear el contenido. Ser\u00e1 importante conocer una serie de atajos de teclado para poder movernos con fluidez a trav\u00e9s de la escena. Encontramos tres tipos de movimientos b\u00e1sicos para movernos por la escena en el editor: Traslaci\u00f3n lateral : Hacemos click sobre la escena y arrastramos el rat\u00f3n. Giro : Pulsamos Alt + click y arrastramos el rat\u00f3n para girar nuestro punto de vista. Avance : Pultamos Ctrl + click y arrastramos el rat\u00f3n, o bien movemos la rueda del rat\u00f3n para avanzar hacia delante o hace atr\u00e1s en la direcci\u00f3n en la que estamos mirando. Con los comandos anteriores podremos desplazarnos libremente sobre la escena, pero tambi\u00e9n es importante conocer otras forma m\u00e1s directas de movernos a la posici\u00f3n que nos interese: Ver un objeto : Si nos interesa ir r\u00e1pidamente a un punto donde veamos de cerca un objeto concreto de la escena, podemos hacer doble click sobre dicho objeto en la vista Hierarchy . Alineaci\u00f3n con un objeto : Alinea la vista de la escena con el objeto seleccionado. Es especialmente \u00fatil cuando se utiliza con la c\u00e1mara, ya que veremos la escena tal como se estar\u00eda bien desde la camara. Para hacer esto, seleccionaremos el game object con el que nos queramos alinear y seleccionaremos la opci\u00f3n del men\u00fa GameObject > Align View To Selected .","title":"Navegaci\u00f3n en la escena"},{"location":"unity.html#interfaz-de-usuario","text":"El sistema con el que cuenta Unity para crear la interfaz de usuario se introdujo a partir de la versi\u00f3n 4.6. Se trata de un sistema bastante vers\u00e1til, que utilizado de forma adecuada nos permite crear interfaces como por ejemplo los men\u00fas o el HUD del juego que se adapten a diferentes tama\u00f1os y formas de pantalla. Todo el contenido de la interfaz de usuario estar\u00e1 contenido en nuestra escena dentro de un elemento tipo Canvas (es decir, un game object que cuente con un componente Canvas ). Dentro de \u00e9l ubicaremos todos los componentes de la interfaz, como por ejemplo im\u00e1genes, etiquetas de texto o botones.","title":"Interfaz de usuario"},{"location":"unity.html#canvas","text":"El Canvas ser\u00e1 el panel 2D ( lienzo ) donde podremos crear el contenido de la interfaz de usuario. Los componentes de la interfaz siempre deber\u00e1n estar dentro de un Canvas en la jerarqu\u00eda de la de escena. Si intentamos arrastrar sobre la escena un componente de la UI sin un Canvas , el Canvas se crear\u00e1 de forma autom\u00e1tica. Una propiedad importante del componente Canvas es Render Mode , que podr\u00e1 tomar 3 valores: Screen Space - Overlay : El Canvas se dibuja sobre el contenido que aparece en pantalla, ajust\u00e1ndose siempre al tama\u00f1o de la misma. Screen Space - Camera : Similar a la anterior, pero en este caso debemos vincularlo a una c\u00e1mara, indicando la distancia a la que estar\u00e1 el Canvas de la c\u00e1mara seleccionada, y el Canvas se ajustar\u00e1 al tama\u00f1o que tenga el tronco de la c\u00e1mara a dicha distancia. Se aplicar\u00e1n sobre el Canvas los par\u00e1metros de la c\u00e1mara seleccionada. World Space : En este caso el Canvas se comportar\u00e1 como cualquier otro objeto 3D en la escena. Le daremos un tama\u00f1o fijo al panel y lo situaremos en una posici\u00f3n del mundo. As\u00ed podremos tener interfaces con las que podamos interactuar en nuestro mundo 3D. En la previsualizaci\u00f3n de la escena, cuando tengamos un Canvas de tipo Screen Space es posible que lo veamos de un tama\u00f1o mucho mayor que el resto de elementos de la escena. Esto se debe a que las unidades con las que trabaja internamente el Canvas son pixels en pantalla, mientras que es habitual que los elementos de la escena tengan dimensiones de alrededor de una unidad. Al ejecutar el juego no habr\u00e1 ning\u00fan problema ya que el Canvas se ajustar\u00e1 al tama\u00f1o de la pantalla o de la c\u00e1mara.","title":"Canvas"},{"location":"unity.html#elementos-de-la-ui","text":"","title":"Elementos de la UI"},{"location":"unity.html#posicionamiento-en-el-espacio-de-la-ui","text":"","title":"Posicionamiento en el espacio de la UI"},{"location":"unity.html#escalado-del-canvas","text":"Normalmente en nuestro Canvas encontraremos un componente adicional que es el CanvasScaler . Se trata de un elemento importante a la hora de conseguir interfaces adaptables, ya que nos permite personalizar la forma en la que se escala el contenido del Canvas a distintos tama\u00f1os de pantalla. Podemos optar por tres modos: Constant Pixel Size Scale With Screen Size Constant Physical Size","title":"Escalado del Canvas"},{"location":"unity.html#realidad-virtual","text":"Existen diferentes dispositivos de realidad virtual, que nos proporcionan una inmersi\u00f3n casi total en la escena, reflejando en la c\u00e1mara los movimientos de nuestra cabeza, y proporcionando una visi\u00f3n estereosc\u00f3pica de la escena. Entre los dispositivos m\u00e1s famosos se encuentran Oculus Rift, Samsung Gear VR y Google Cardboard. Aunque todos estos dispositivos proporcionan su propio SDK que podemos integrar en las plataformas nativas de desarrollo, es de especial inter\u00e9s su integraci\u00f3n en el entorno Unity, que nos permitir\u00e1 realizar aplicaciones que los soporten de forma casi inmediata. A continuaci\u00f3n veremos c\u00f3mo utilizarlos con este entorno.","title":"Realidad Virtual"},{"location":"unity.html#oculus-rift-samsung-gear-vr","text":"A partir de Unity 5.1 encontramos en este entorno soporte nativo para los dispositivos Oculus Rift y Samsung Gear VR. Ambos utilizan el mismo SDK y herramientas, con la diferencia de que Oculus Rift funciona sobre plataformas de sobremesa, mientras que Samsung Gear VR funciona sobre m\u00f3viles Samsung. Para activar el soporte para estos dispositivos en Unity simplemente tendremos que entrar en Player Settings ( Edit > Project Settings > Player ) y bien dentro de la plataforma Standalone (para Oculus Rift) o Android (para Samsung Gear VR) marcar la casilla Virtual Reality Supported , dentro de la secci\u00f3n Other Settings > Rendering . Una vez hecho esto, autom\u00e1ticamente la c\u00e1mara de la escena se comportar\u00e1 como una c\u00e1mara VR, girando cuando giremos la cabeza y renderizando una imagen para cada ojo, para as\u00ed proporcionar visi\u00f3n est\u00e9reo.","title":"Oculus Rift / Samsung Gear VR"},{"location":"unity.html#google-cardboard","text":"Unity no incluye soporte nativo para Google Cardboard, pero podemos encontrar un plugin muy sencillo de utilizar en la web oficial: https://developers.google.com/cardboard/unity El plugin consiste en un paquete de assets que podemos incluir en nuestro proyecto (deberemos a\u00f1adir todo su contenido). La forma m\u00e1s sencilla de a\u00f1adir soporte para Cardboard es a\u00f1adir a nuestra c\u00e1mara el script StereoController :","title":"Google Cardboard"},{"location":"videojuegos_para_moviles.html","text":"Videojuegos para m\u00f3viles \u00b6 Sin duda uno de los tipos de aplicaciones que m\u00e1s famosos se han hecho en el mercado de los m\u00f3viles son los videojuegos. Con estos tel\u00e9fonos los usuarios pueden descargar juegos a trav\u00e9s de las diferentes tiendas online, normalmente a precios muy reducidos en relaci\u00f3n a otras plataformas de videojuegos, y cuentan con la gran ventaja de que son dispositivos que siempre llevamos con nosotros. En este primer cap\u00edtulo vamos a ver las caracter\u00edsticas particulares de los videojuegos para m\u00f3viles, y las herramientas y librer\u00edas que podemos utilizar para desarrollarlos y portarlos a las diferentes plataformas m\u00f3viles, especialmente Android e iOS. Historia de los videojuegos en m\u00f3viles \u00b6 Los primeros juegos que pod\u00edamos encontrar en los m\u00f3viles eran normalmente juegos muy sencillos tipo puzzle o de mesa, o en todo caso juegos de acci\u00f3n muy simples similares a los primeros videojuegos aparecidos antes de los 80. El primer juego que apareci\u00f3 fue el Snake, que se incluy\u00f3 preinstalado en determinados modelos de m\u00f3viles Nokia (como por ejemplo el 3210) a partir de 1997. Se trataba de un juego monocromo, cuya versi\u00f3n original data de finales de los 70. Su traslado a los m\u00f3viles Nokia supuso un enorme \u00e9xito, convirti\u00e9ndose en un icono de los dispositivos de esta compa\u00f1\u00eda. Este era el \u00fanico juego que ven\u00eda preinstalado en estos m\u00f3viles, y no cont\u00e1bamos con la posibilidad de descargar ning\u00fan otro. Con el avance de la tecnolog\u00eda, aparecieron m\u00f3viles capaces de instalar nuevas aplicaciones. El sistema operativo m\u00e1s com\u00fan era SymbianOS, pero casi todos los m\u00f3viles, independientemente del sistema operativo que incorporasen, tambi\u00e9n soportaban la instalaci\u00f3n de aplicaci\u00f3n Java (plataforma Java ME). Esto, junto con el \u00e9xito que hab\u00eda cosechado Snake , di\u00f3 lugar a la aparici\u00f3n de un gran n\u00famero de videojuegos para las plataformas Symbian y Java ME. Con esto aparecieron juegos algo m\u00e1s complejos, similares a los que hab\u00edan aparecido bastantes a\u00f1os antes para ordenadores y consolas de 8 bits. Estos juegos ir\u00edan mejorando conforme los tel\u00e9fonos m\u00f3viles evolucionaban, hasta llegar incluso a tener juegos sencillos en 3D. Los videojuegos fueron el tipo de aplicaci\u00f3n Java m\u00e1s com\u00fan para estos m\u00f3viles, llegando al punto de que los m\u00f3viles con soporte para Java ME comercialmente se vend\u00edan muchas veces como m\u00f3vil con Juegos Java . Adem\u00e1s ten\u00edamos la ventaja de que en aquel momento ya exist\u00eda una gran comunidad de programadores en Java, a los que no les costar\u00eda aprender a desarrollar este tipo de juegos para m\u00f3viles, por lo que el n\u00famero de juegos disponible crecer\u00eda r\u00e1pidamente. El poder descargar y a\u00f1adir estos juegos al m\u00f3vil de forma sencilla, como cualquier otra aplicaci\u00f3n Java, har\u00e1 estos juegos especialmente atractivos para los usuarios, permitiendo disponer continuamente de nuevos juegos en sus m\u00f3viles. Pero fue con la llegada del iPhone en 2007 y la App Store en 2008 cuando realmente se produjo el boom de los videojuegos para m\u00f3viles. La facilidad para obtener los contenidos en la tienda de Apple, junto a la capacidad de estos dispositivos para reproducir videojuegos causaron que en muy poco tiempo \u00e9sta pasase a ser la principal plataforma de videojuegos en m\u00f3viles, incluso ganando terreno r\u00e1pidamente a las videoconsolas port\u00e1tiles. En la actualidad las plataformas Android e iOS son el principal mercado de videojuegos para m\u00f3viles, superando ya a las videoconsolas port\u00e1tiles. Por detr\u00e1s quedan otras plataformas como Windows Phone o Blackberry, en las que tambi\u00e9n podemos encontrar una gran cantidad de videojuegos disponibles. La capacidad de los dispositivos actuales permite que veamos videojuegos t\u00e9cnicamente cercanos a los que podemos encontrar en algunas videoconsolas de sobremesa. El motor del videojuego \u00b6 Normalmente los juegos consisten en una serie de niveles. Cada vez que superemos un nivel, entraremos en uno nuevo en el que se habr\u00e1 incrementado la dificultad, y posiblemente encontremos alg\u00fan elemento nuevo, como nuevos tipos de enemigos y nuevos poderes a utilizar, pero la mec\u00e1nica del juego en esencia ser\u00e1 la misma. Por este motivo, en el desarrollo de videojuegos es conveniente que el c\u00f3digo fuente resulte lo m\u00e1s gen\u00e9rico y reutilizable posible, llevando la definici\u00f3n de los niveles a ficheros de datos (por ejemplo con formato xml o json ), que contendr\u00e1n la estructura del escenario, los enemigos que aparecer\u00e1n en \u00e9l, y otros elementos con los que podamos interactuar. De esta forma, cada vez que iniciemos un nuevo nivel, la cargar\u00e1n los datos del fichero del nivel, y se aplicar\u00e1 sobre ellos la mec\u00e1nica gen\u00e9rica del juego. Este c\u00f3digo gen\u00e9rico capaz de leer, interpretar y reproducir los niveles de nuestro juego es lo que conoceremos como motor del juego . Entre los ficheros de datos que podr\u00e1 cargar nuestro motor (recursos conocidos habitualmente como assets ) encontramos por ejemplo los gr\u00e1ficos del juego, fuentes, clips de audio, la estructura de cada nivel, e incluso scripts (programas en lenguajes de alto nivel que definen el comportamiento de las entidades del juego). En muchas ocasiones encontramos motores desarrollados para implementar un videojuego concreto. En estos casos, podremos a\u00f1adir nuevos contenidos a nuestro juego (niveles, personajes, etc) a\u00f1adiendo nuevos ficheros de datos que lea el motor sin tener que modificar el fuente. Sin embargo, conforme ha ido evolucionando la tecnolog\u00eda han ido apareciendo motores gen\u00e9ricos pensados para poder crear cualquier tipo de videojuego (o casi cualquiera). En estos casos ya no se lleva a los \"datos\" simplemente los contenidos del juego, sino tambi\u00e9n el comportamiento del mismo (normalmente mediante scripting ). El uso de este tipo de motores nos proporcionar\u00e1 una serie de ventajas: Independencia del hardware : Esto es de especial importancia en el caso de las plataformas m\u00f3viles. Si contamos con un motor gen\u00e9rico implementado para diferentes plataformas (Android, iOS, Windows Phone), podremos crear nuestro juego una \u00fanica vez sobre dicho motor (con los tipos de ficheros de datos que soporte), y exportarlo a todas las plataformas soportadas. Mejora del flujo de trabajo en el equipo de desarrollo : Cada miembro del equipo de desarrollo trabajar\u00e1 sobre sus propios assets : el dise\u00f1ador del juego con los datos de los niveles; el artista gr\u00e1fico con las texturas, modelos, y animaciones 3D; m\u00fasicos y t\u00e9cnicos de sonido con clips de audio; y programadores con scripts . El motor se encargar\u00e1 de integrar todos estos elementos en el juego. Centrarnos en lo que hace nuestro juego diferente : El contar con estos motores nos permitir\u00e1 crear juegos complejos centr\u00e1ndonos en el dise\u00f1o y contenidos del juego, sin tener que implementar nosotros el motor gen\u00e9rico. Es decir, nos centramos en aquello que hace a nuestros juego distinto a los dem\u00e1s (contenidos), y no en aquello que es com\u00fan a todos los juegos (motor). Menor coste de desarrollo y time to market : Evitar tener que implementar el motor a bajo nivel supondr\u00e1 un notable ahorro en el coste del desarrollo, especialmente conforme el hardware se hace m\u00e1s complejo, y nos permitir\u00e1 llegar m\u00e1s r\u00e1pidamente al mercado. Tecnolog\u00edas para el desarrollo de videojuegos para m\u00f3viles \u00b6 Encontramos diferentes motores y librer\u00edas que nos permiten crear videojuegos para distintas plataformas m\u00f3viles. Vamos a realizar una revisi\u00f3n de las principales tecnolog\u00edas disponibles que agruparemos en tres diferentes categor\u00edas: Motores completos : Motores completos que nos permitir\u00e1n crear casi cualquier tipo de videojuego (2D y 3D) mediante sus propias herramientas de creaci\u00f3n de contenidos. En estos casos la programaci\u00f3n suele hacerse mediante lenguajes de script . En este grupo encontramos motores como Unreal Engine 4 o Unity . Herramientas de creaci\u00f3n de videojuegos : Herramientas visuales que nos permiten crear videojuegos de forma sencilla, en muchos casos sin la necesidad de saber programar. En estas herramientas suele estar m\u00e1s restringido el tipo de juegos que se pueden realizar, limit\u00e1ndose normalmente a juegos 2D. Dentro de este grupo encontramos herramientas como Game Maker: Studio , Construct2 y Gamesalad . Frameworks para el desarrollo de videojuegos : En este grupo encontramos librer\u00edas multiplataforma (normalmente Open Source ) orientadas al desarrollo de videojuegos. No cuentan con las herramientas de creaci\u00f3n de contenidos de los casos anteriores, sino que casi todo lo tendremos que hacer mediante programaci\u00f3n, pero nos permitir\u00e1n escribir el juego una \u00fanica vez y portarlo a diferentes plataformas m\u00f3viles. En este grupo destacamos los frameworks multiplataforma Cocos2d-x (desarrollo en C++) y libgdx (desarrollo en Java). Adem\u00e1s, dentro de este grupo tambi\u00e9n encontramos los frameworks nativos de la plataforma iOS SpriteKit (juegos 2D) y SceneKit (juegos 3D). A continuaci\u00f3n veremos m\u00e1s detalles de cada uno de los motores anteriores. Game Maker: Studio \u00b6 Se trata de una herramienta para crear juegos 2D sencillos. Cuenta con una herramienta visual que simplifica la creaci\u00f3n de contenidos, y que nos permite crear videojuegos incluso sin necesidad de programar. Permite generar juegos para Windows de forma gratuita, pero para exportar a otras plataformas como Android o iOS deberemos adquirir una licencia de pago. Encontramos opciones similartes, como el motor Construct2 (en este caso la herramienta est\u00e1 s\u00f3lo para Windows), o Gamesalad (que cuenta con una licencia de pago mensual). Unreal Engine 4 \u00b6 Con este motor se han creado videojuegos como los juegos de la saga Gears of War , o Daylight , o Street Fighter V . Actualmente Unreal Engine 4 (UE4) es gratuito para todos los desarrolladores. Tiene un lenguaje de scripting visual ( blueprints ) y tambi\u00e9n nos permite incorporar componentes en C++. Los videojuegos desarrollados con UE4 pueden empaquetarse como aplicaciones Android o iOS (adem\u00e1s de PC, Mac, y videoconsolas como PS4 y Xbox One), y podemos distribuirlos en la App Store y en Google Play Market teniendo que pagar a Epic Games s\u00f3lo un porcentaje de los royalties en caso de que superemos cierto nivel de ganancias. Unity \u00b6 Nos permite crear videojuegos para un gran n\u00famero de plataformas (entre ellas iOS, Android y Windows Phone). En este caso tenemos un motor capaz de realizar juegos tanto 3D como 2D, y resulta m\u00e1s accesible para desarrolladores noveles que el motor anterior. Adem\u00e1s, permite realizar videojuegos de tama\u00f1o algo m\u00e1s reducido. A partir de Unity 5 existe una versi\u00f3n gratuita que podemos utilizar siempre que no superemos cierto nivel de ganancias anuales como particular o empresa. Esta versi\u00f3n incluye todas las funcionalidades del motor. Los juegos realizados con este motor podr\u00e1n publicarse de forma comercial libres de royalties . Cocos2d-x \u00b6 Aparte de los motores anteriores, que incorporan sus propias herramientas con las que podemos crear videojuegos de forma visual de forma independiente a la plataformas, tambi\u00e9n encontramos motores Open Source m\u00e1s sencillos que podemos utilizar para determinadas plataformas concretas. En este caso, no solemos contar con herramientas visuales completas para la creaci\u00f3n del videojuego, como es el caso de los anteriores, sino simplemente con frameworks y librer\u00edas que nos ayudar\u00e1n a implementar los videojuegos, aisl\u00e1ndonos de las capas de m\u00e1s bajo nivel como OpenGL (Metal en caso de iOS si utilizamos Cocos2d-x 4.0 o superior) o OpenAL, y ofreci\u00e9ndonos un marco que nos simplificar\u00e1 la implementaci\u00f3n del videojuego. Uno de estos motores es Cocos2d-x , que nos permite crear en C++ videojuegos para las principales plataformas m\u00f3viles (iOS, Android, Windows Phone, Blackberry, etc). Aunque el propio motor no incorpore herramientas de creaci\u00f3n de contenidos, se integra bien con herramientas externas como Tiled o Texture Packer que nos permiten editar escenarios u hojas de sprites respectivamente. Una opci\u00f3n similar es libgdx. En este caso se programa en lenguaje Java, y para pasar a iOS realiza una traducci\u00f3n autom\u00e1tica de Java a C++. Estos motores tienen como ventaja el acceso al c\u00f3digo fuente del motor, en el que puede participar la comunidad, y tambi\u00e9n generan un tama\u00f1o de paquete m\u00e1s reducido que motores m\u00e1s complejos como Unity o sobre todo UE4. Tecnolog\u00edas nativas: SpriteKit y SceneKit \u00b6 Aunque el uso de motores multiplataforma nos aporta una gran cantidad de ventajas, es algunos casos nos podr\u00eda interesar desarrollar videojuegos utilizando las tecnolog\u00edas nativas de la plataforma. Una posible raz\u00f3n para hacer esto es la de conseguir reducir el tama\u00f1o de la aplicaci\u00f3n lo m\u00e1ximo posible, lo cual puede ser conveniente en juegos sencillos que no necesiten un motor complejo. La tecnolog\u00eda nativa para desarrollo de videojuegos que podemos encontrar en las principales plataformas m\u00f3viles es OpenGL ES . Se trata de una librer\u00eda de bajo nivel, sobre la que tendremos que construir nuestro propio motor adaptado a las necesidades de nuestro videojuego. En el momento de la escritura de este texto, OpenGL ES es la \u00fanica opci\u00f3n nativa en el caso de Android , recomend\u00e1ndose utilizar el NDK para la implementaci\u00f3n de nuestro propio motor del videojuego, y as\u00ed poderlo optimizar al m\u00e1ximo. En Windows Phone encontraremos tambi\u00e9n la API nativa XNA . Contamos con el entorno XNA Game Studio dedicado al desarrollo de videojuegos en la plataforma de Microsoft. Sin embargo, la plataforma que mayor n\u00famero de opciones nativas nos ofrece es la de Apple. En iOS , adem\u00e1s de OpenGL ES , encontramos Metal , una librer\u00eda gr\u00e1fica similar a bajo nivel optimizada para esta plataforma. A parte de las opciones a bajo nivel, tenemos tambi\u00e9n dos librer\u00edas de alto nivel para el desarrollo de videojuegos 2D y 3D respectivamente: SpriteKit y SceneKit . Al ser nativos, nos permitir\u00e1n crear videojuegos optimizados para esta plataforma y reducir el tama\u00f1o del paquete de la aplicaci\u00f3n, pero s\u00f3lo podr\u00e1n ser utilizados en iOS. Caracter\u00edsticas de los videojuegos para m\u00f3viles \u00b6 Los dispositivos m\u00f3viles presentan diferencias notables respecto a los equipos de sobremesa (ordenadores y consolas), en relaci\u00f3n a la capacidad del hardware , la interfaz, y el tipo de uso que se les da. Esto tendr\u00e1 importantes repercusiones en el dise\u00f1o de videojuegos para estos dispositivos. Vamos a revisar a continuaci\u00f3n los principales aspectos que tendremos que tener en cuenta a la hora de dise\u00f1ar videojuegos para dispositivos m\u00f3viles: Limitaciones de la memoria . En los primeros dispositivos (Java ME) la memor\u00eda supon\u00eda una gran limitaci\u00f3n, ya que en algunos dispositivos cont\u00e1bamos con tan solo 128kb para todo el juego. Con el avance de la tecnolog\u00eda esta limitaci\u00f3n se ha ido atenuando y hoy en d\u00eda ya no supone algo cr\u00edtico. Sin embargo, deberemos llevar especial cuidado con la memoria de v\u00eddeo. Por este motivo ser\u00e1 importante seleccionar un formato de textura adecuado (el m\u00e1s compacto que cumpla con las necesidades para el videojuego), y ser\u00e1 com\u00fan comprimir las texturas. Tambi\u00e9n es importante empaquetar nuestros gr\u00e1ficos de forma \u00f3ptima para as\u00ed aprovechar al m\u00e1ximo el espacio de las texturas. Encontraremos herramientas como Texture Packer que se encargan de realizar esta tarea. Tama\u00f1o de la aplicaci\u00f3n . Los videojuegos para plataformas de sobremesa habitualmente ocupan varios gigas. En un m\u00f3vil la distribuci\u00f3n de juegos siempre es digital, por lo que deberemos reducir este tama\u00f1o en la medida de lo posible, tanto para evitar tener que descargar un paquete demasiado grande a trav\u00e9s de la limitada conexi\u00f3n del m\u00f3vil, como para evitar que ocupe demasiado espacio en la memoria de almacenamiento del dispositivo (que en algunos dispositivos es escaso). Para poder descargar un juego v\u00eda conexi\u00f3n de datos no deber\u00eda exceder los 20Mb, por lo que ser\u00e1 recomendable conseguir empaquetarlo en un espacio menor, para que los usuarios puedan acceder a \u00e9l sin necesidad de disponer de Wi-Fi. Esto nos dar\u00e1 una importante ventaja competitiva. Para esto es importante hacer una buena elecci\u00f3n del motor a utilizar. Motores complejos como Unity 5 generan paquetes con un tama\u00f1o m\u00ednimo de unas 20Mb, mientras que otros motores como Cocos2d-x nos permitir\u00edan tener juegos a partir de unas 5Mb. Si nuestro juego no necesita gr\u00e1ficos 3D ni otras de las caracter\u00edsticas que s\u00f3lo se encuentren en Unity, puede ser conveniente seleccionar un motor m\u00e1s sencillo como Cocos2d-x. Capacidad de procesamiento . La CPU y GPU de los m\u00f3viles en muchas ocasiones es m\u00e1s limitada que la de plataformas de sobremesa, y muy variable entre disintos dispositivos. Es importante que los juegos vayan de forma fluida, por lo que antes de distribuirlos deberemos probarlos en diferentes m\u00f3viles reales para asegurarnos de que funcione bien, ya que muchas veces los emuladores funcionar\u00e1n a velocidades distintas. Es conveniente empezar desarrollando un c\u00f3digo claro y limpio, y posteriormente optimizarlo. Para optimizar el juego deberemos identificar el lugar donde tenemos el cuello de botella, que podr\u00eda ser en el procesamiento, o en el dibujado de los gr\u00e1ficos. En el segundo caso podemos ajustar en el motor la calidad de los gr\u00e1ficos para cada plataforma. Pantalla reducida . Deberemos tener esto en cuenta en los juegos, y hacer que todos los objetos se vean correctamente. Podemos utilizar zoom en determinadas zonas para poder visualizar mejor los objetos de la escena. Deberemos cuidar que todos los elementos de la interfaz puedan visualizarse correctamente y que tengan un tama\u00f1o adecuado para interactuar con ellos. Los botones u otros elementos con los que podamos interactuar en la pantalla t\u00e1ctil tendr\u00e1n que tener al menos el tama\u00f1o de la yema del dedo. Diferente interfaz de entrada . Actualmente los m\u00f3viles no suelen tener teclado, y en aquellos que lo tienen este teclado es muy peque\u00f1o. Deberemos intentar proporcionar un manejo c\u00f3modo, adaptado a la interfaz de entrada con la que cuenta el m\u00f3vil, como el aceler\u00f3metro o la pantalla t\u00e1ctil, haciendo que el control sea lo m\u00e1s sencillo posible, con un n\u00famero reducido de posibles acciones. En muchos casos el manejo del juego se reduce a hacer tap en pantalla. Para mec\u00e1nicas m\u00e1s complejas, se puede utilizar un mando virtual (hay que hacer un buen dise\u00f1o del mismo para que sea usable), o soportar mandos externos. Ancho de banda reducido e inestable . Si desarrollamos juegos en red deberemos tener en determinados momentos velocidad puede ser baja, seg\u00fan la cobertura, y podemos tener tambi\u00e9n una elevada latencia de la red. Incluso es posible que en determinados momentos se pierda la conexi\u00f3n temporalmente. Deberemos minimizar el tr\u00e1fico que circula por la red. Posibles interrupciones . En el m\u00f3vil es muy probable que se produzca una interrupci\u00f3n involuntaria de la partida, por ejemplo cuando recibimos una llamada entrante. Deberemos permitir que esto ocurra. Adem\u00e1s tambi\u00e9n es conveniente que el usuario pueda pausar la partida f\u00e1cilmente, ya que estos dispositivos se utilizan habitualmente para \"hacer tiempo\". Si estamos jugando mientras esperamos el autob\u00fas o esperamos nuestro turno en una tienda, cuando llegue nuestro turno deberemos poder interrumpir la partida inmediatamente sin perder nuestro progreso. Es fundamental hacer que cuando otra aplicaci\u00f3n pase a segundo plano nuestro juego se pause autom\u00e1ticamente, para as\u00ed no afectar al progreso que ha hecho el usuario. Incluso lo deseable ser\u00eda que cuando salgamos de la aplicaci\u00f3n en cualquier momento siempre se guarde el estado actual del juego, para que el usuario pueda continuar por donde se hab\u00eda quedado la pr\u00f3xima vez que juegue. Esto permitir\u00e1 que el usuario pueda cerrar el juego en cualquier momento sin miedo de perder sus avances. Ante todo, estos deben ser atractivos para los jugadores, ya que su principal finalidad es entretener. Debemos tener en cuenta que son videojuegos que normalmente se utilizar\u00e1n para hacer tiempo, por lo que es deseable que la curva de aprendizaje sea suave y que permita partidas r\u00e1pidas. Dos aspectos fundamentales son la adquisici\u00f3n y la retenci\u00f3n de jugadores. Tenemos que conseguir que que los usuarios prueben nuestro juego y que continuen jugando a \u00e9l. Para incentivar esto deberemos ofrecerle alguna recompensa por seguir jugando, y la posibilidad de que pueda compartir estos logros con otros jugadores.","title":"Introducci\u00f3n a los videojuegos m\u00f3viles"},{"location":"videojuegos_para_moviles.html#videojuegos-para-moviles","text":"Sin duda uno de los tipos de aplicaciones que m\u00e1s famosos se han hecho en el mercado de los m\u00f3viles son los videojuegos. Con estos tel\u00e9fonos los usuarios pueden descargar juegos a trav\u00e9s de las diferentes tiendas online, normalmente a precios muy reducidos en relaci\u00f3n a otras plataformas de videojuegos, y cuentan con la gran ventaja de que son dispositivos que siempre llevamos con nosotros. En este primer cap\u00edtulo vamos a ver las caracter\u00edsticas particulares de los videojuegos para m\u00f3viles, y las herramientas y librer\u00edas que podemos utilizar para desarrollarlos y portarlos a las diferentes plataformas m\u00f3viles, especialmente Android e iOS.","title":"Videojuegos para m\u00f3viles"},{"location":"videojuegos_para_moviles.html#historia-de-los-videojuegos-en-moviles","text":"Los primeros juegos que pod\u00edamos encontrar en los m\u00f3viles eran normalmente juegos muy sencillos tipo puzzle o de mesa, o en todo caso juegos de acci\u00f3n muy simples similares a los primeros videojuegos aparecidos antes de los 80. El primer juego que apareci\u00f3 fue el Snake, que se incluy\u00f3 preinstalado en determinados modelos de m\u00f3viles Nokia (como por ejemplo el 3210) a partir de 1997. Se trataba de un juego monocromo, cuya versi\u00f3n original data de finales de los 70. Su traslado a los m\u00f3viles Nokia supuso un enorme \u00e9xito, convirti\u00e9ndose en un icono de los dispositivos de esta compa\u00f1\u00eda. Este era el \u00fanico juego que ven\u00eda preinstalado en estos m\u00f3viles, y no cont\u00e1bamos con la posibilidad de descargar ning\u00fan otro. Con el avance de la tecnolog\u00eda, aparecieron m\u00f3viles capaces de instalar nuevas aplicaciones. El sistema operativo m\u00e1s com\u00fan era SymbianOS, pero casi todos los m\u00f3viles, independientemente del sistema operativo que incorporasen, tambi\u00e9n soportaban la instalaci\u00f3n de aplicaci\u00f3n Java (plataforma Java ME). Esto, junto con el \u00e9xito que hab\u00eda cosechado Snake , di\u00f3 lugar a la aparici\u00f3n de un gran n\u00famero de videojuegos para las plataformas Symbian y Java ME. Con esto aparecieron juegos algo m\u00e1s complejos, similares a los que hab\u00edan aparecido bastantes a\u00f1os antes para ordenadores y consolas de 8 bits. Estos juegos ir\u00edan mejorando conforme los tel\u00e9fonos m\u00f3viles evolucionaban, hasta llegar incluso a tener juegos sencillos en 3D. Los videojuegos fueron el tipo de aplicaci\u00f3n Java m\u00e1s com\u00fan para estos m\u00f3viles, llegando al punto de que los m\u00f3viles con soporte para Java ME comercialmente se vend\u00edan muchas veces como m\u00f3vil con Juegos Java . Adem\u00e1s ten\u00edamos la ventaja de que en aquel momento ya exist\u00eda una gran comunidad de programadores en Java, a los que no les costar\u00eda aprender a desarrollar este tipo de juegos para m\u00f3viles, por lo que el n\u00famero de juegos disponible crecer\u00eda r\u00e1pidamente. El poder descargar y a\u00f1adir estos juegos al m\u00f3vil de forma sencilla, como cualquier otra aplicaci\u00f3n Java, har\u00e1 estos juegos especialmente atractivos para los usuarios, permitiendo disponer continuamente de nuevos juegos en sus m\u00f3viles. Pero fue con la llegada del iPhone en 2007 y la App Store en 2008 cuando realmente se produjo el boom de los videojuegos para m\u00f3viles. La facilidad para obtener los contenidos en la tienda de Apple, junto a la capacidad de estos dispositivos para reproducir videojuegos causaron que en muy poco tiempo \u00e9sta pasase a ser la principal plataforma de videojuegos en m\u00f3viles, incluso ganando terreno r\u00e1pidamente a las videoconsolas port\u00e1tiles. En la actualidad las plataformas Android e iOS son el principal mercado de videojuegos para m\u00f3viles, superando ya a las videoconsolas port\u00e1tiles. Por detr\u00e1s quedan otras plataformas como Windows Phone o Blackberry, en las que tambi\u00e9n podemos encontrar una gran cantidad de videojuegos disponibles. La capacidad de los dispositivos actuales permite que veamos videojuegos t\u00e9cnicamente cercanos a los que podemos encontrar en algunas videoconsolas de sobremesa.","title":"Historia de los videojuegos en m\u00f3viles"},{"location":"videojuegos_para_moviles.html#el-motor-del-videojuego","text":"Normalmente los juegos consisten en una serie de niveles. Cada vez que superemos un nivel, entraremos en uno nuevo en el que se habr\u00e1 incrementado la dificultad, y posiblemente encontremos alg\u00fan elemento nuevo, como nuevos tipos de enemigos y nuevos poderes a utilizar, pero la mec\u00e1nica del juego en esencia ser\u00e1 la misma. Por este motivo, en el desarrollo de videojuegos es conveniente que el c\u00f3digo fuente resulte lo m\u00e1s gen\u00e9rico y reutilizable posible, llevando la definici\u00f3n de los niveles a ficheros de datos (por ejemplo con formato xml o json ), que contendr\u00e1n la estructura del escenario, los enemigos que aparecer\u00e1n en \u00e9l, y otros elementos con los que podamos interactuar. De esta forma, cada vez que iniciemos un nuevo nivel, la cargar\u00e1n los datos del fichero del nivel, y se aplicar\u00e1 sobre ellos la mec\u00e1nica gen\u00e9rica del juego. Este c\u00f3digo gen\u00e9rico capaz de leer, interpretar y reproducir los niveles de nuestro juego es lo que conoceremos como motor del juego . Entre los ficheros de datos que podr\u00e1 cargar nuestro motor (recursos conocidos habitualmente como assets ) encontramos por ejemplo los gr\u00e1ficos del juego, fuentes, clips de audio, la estructura de cada nivel, e incluso scripts (programas en lenguajes de alto nivel que definen el comportamiento de las entidades del juego). En muchas ocasiones encontramos motores desarrollados para implementar un videojuego concreto. En estos casos, podremos a\u00f1adir nuevos contenidos a nuestro juego (niveles, personajes, etc) a\u00f1adiendo nuevos ficheros de datos que lea el motor sin tener que modificar el fuente. Sin embargo, conforme ha ido evolucionando la tecnolog\u00eda han ido apareciendo motores gen\u00e9ricos pensados para poder crear cualquier tipo de videojuego (o casi cualquiera). En estos casos ya no se lleva a los \"datos\" simplemente los contenidos del juego, sino tambi\u00e9n el comportamiento del mismo (normalmente mediante scripting ). El uso de este tipo de motores nos proporcionar\u00e1 una serie de ventajas: Independencia del hardware : Esto es de especial importancia en el caso de las plataformas m\u00f3viles. Si contamos con un motor gen\u00e9rico implementado para diferentes plataformas (Android, iOS, Windows Phone), podremos crear nuestro juego una \u00fanica vez sobre dicho motor (con los tipos de ficheros de datos que soporte), y exportarlo a todas las plataformas soportadas. Mejora del flujo de trabajo en el equipo de desarrollo : Cada miembro del equipo de desarrollo trabajar\u00e1 sobre sus propios assets : el dise\u00f1ador del juego con los datos de los niveles; el artista gr\u00e1fico con las texturas, modelos, y animaciones 3D; m\u00fasicos y t\u00e9cnicos de sonido con clips de audio; y programadores con scripts . El motor se encargar\u00e1 de integrar todos estos elementos en el juego. Centrarnos en lo que hace nuestro juego diferente : El contar con estos motores nos permitir\u00e1 crear juegos complejos centr\u00e1ndonos en el dise\u00f1o y contenidos del juego, sin tener que implementar nosotros el motor gen\u00e9rico. Es decir, nos centramos en aquello que hace a nuestros juego distinto a los dem\u00e1s (contenidos), y no en aquello que es com\u00fan a todos los juegos (motor). Menor coste de desarrollo y time to market : Evitar tener que implementar el motor a bajo nivel supondr\u00e1 un notable ahorro en el coste del desarrollo, especialmente conforme el hardware se hace m\u00e1s complejo, y nos permitir\u00e1 llegar m\u00e1s r\u00e1pidamente al mercado.","title":"El motor del videojuego"},{"location":"videojuegos_para_moviles.html#tecnologias-para-el-desarrollo-de-videojuegos-para-moviles","text":"Encontramos diferentes motores y librer\u00edas que nos permiten crear videojuegos para distintas plataformas m\u00f3viles. Vamos a realizar una revisi\u00f3n de las principales tecnolog\u00edas disponibles que agruparemos en tres diferentes categor\u00edas: Motores completos : Motores completos que nos permitir\u00e1n crear casi cualquier tipo de videojuego (2D y 3D) mediante sus propias herramientas de creaci\u00f3n de contenidos. En estos casos la programaci\u00f3n suele hacerse mediante lenguajes de script . En este grupo encontramos motores como Unreal Engine 4 o Unity . Herramientas de creaci\u00f3n de videojuegos : Herramientas visuales que nos permiten crear videojuegos de forma sencilla, en muchos casos sin la necesidad de saber programar. En estas herramientas suele estar m\u00e1s restringido el tipo de juegos que se pueden realizar, limit\u00e1ndose normalmente a juegos 2D. Dentro de este grupo encontramos herramientas como Game Maker: Studio , Construct2 y Gamesalad . Frameworks para el desarrollo de videojuegos : En este grupo encontramos librer\u00edas multiplataforma (normalmente Open Source ) orientadas al desarrollo de videojuegos. No cuentan con las herramientas de creaci\u00f3n de contenidos de los casos anteriores, sino que casi todo lo tendremos que hacer mediante programaci\u00f3n, pero nos permitir\u00e1n escribir el juego una \u00fanica vez y portarlo a diferentes plataformas m\u00f3viles. En este grupo destacamos los frameworks multiplataforma Cocos2d-x (desarrollo en C++) y libgdx (desarrollo en Java). Adem\u00e1s, dentro de este grupo tambi\u00e9n encontramos los frameworks nativos de la plataforma iOS SpriteKit (juegos 2D) y SceneKit (juegos 3D). A continuaci\u00f3n veremos m\u00e1s detalles de cada uno de los motores anteriores.","title":"Tecnolog\u00edas para el desarrollo de videojuegos para m\u00f3viles"},{"location":"videojuegos_para_moviles.html#game-maker-studio","text":"Se trata de una herramienta para crear juegos 2D sencillos. Cuenta con una herramienta visual que simplifica la creaci\u00f3n de contenidos, y que nos permite crear videojuegos incluso sin necesidad de programar. Permite generar juegos para Windows de forma gratuita, pero para exportar a otras plataformas como Android o iOS deberemos adquirir una licencia de pago. Encontramos opciones similartes, como el motor Construct2 (en este caso la herramienta est\u00e1 s\u00f3lo para Windows), o Gamesalad (que cuenta con una licencia de pago mensual).","title":"Game Maker: Studio"},{"location":"videojuegos_para_moviles.html#unreal-engine-4","text":"Con este motor se han creado videojuegos como los juegos de la saga Gears of War , o Daylight , o Street Fighter V . Actualmente Unreal Engine 4 (UE4) es gratuito para todos los desarrolladores. Tiene un lenguaje de scripting visual ( blueprints ) y tambi\u00e9n nos permite incorporar componentes en C++. Los videojuegos desarrollados con UE4 pueden empaquetarse como aplicaciones Android o iOS (adem\u00e1s de PC, Mac, y videoconsolas como PS4 y Xbox One), y podemos distribuirlos en la App Store y en Google Play Market teniendo que pagar a Epic Games s\u00f3lo un porcentaje de los royalties en caso de que superemos cierto nivel de ganancias.","title":"Unreal Engine 4"},{"location":"videojuegos_para_moviles.html#unity","text":"Nos permite crear videojuegos para un gran n\u00famero de plataformas (entre ellas iOS, Android y Windows Phone). En este caso tenemos un motor capaz de realizar juegos tanto 3D como 2D, y resulta m\u00e1s accesible para desarrolladores noveles que el motor anterior. Adem\u00e1s, permite realizar videojuegos de tama\u00f1o algo m\u00e1s reducido. A partir de Unity 5 existe una versi\u00f3n gratuita que podemos utilizar siempre que no superemos cierto nivel de ganancias anuales como particular o empresa. Esta versi\u00f3n incluye todas las funcionalidades del motor. Los juegos realizados con este motor podr\u00e1n publicarse de forma comercial libres de royalties .","title":"Unity"},{"location":"videojuegos_para_moviles.html#cocos2d-x","text":"Aparte de los motores anteriores, que incorporan sus propias herramientas con las que podemos crear videojuegos de forma visual de forma independiente a la plataformas, tambi\u00e9n encontramos motores Open Source m\u00e1s sencillos que podemos utilizar para determinadas plataformas concretas. En este caso, no solemos contar con herramientas visuales completas para la creaci\u00f3n del videojuego, como es el caso de los anteriores, sino simplemente con frameworks y librer\u00edas que nos ayudar\u00e1n a implementar los videojuegos, aisl\u00e1ndonos de las capas de m\u00e1s bajo nivel como OpenGL (Metal en caso de iOS si utilizamos Cocos2d-x 4.0 o superior) o OpenAL, y ofreci\u00e9ndonos un marco que nos simplificar\u00e1 la implementaci\u00f3n del videojuego. Uno de estos motores es Cocos2d-x , que nos permite crear en C++ videojuegos para las principales plataformas m\u00f3viles (iOS, Android, Windows Phone, Blackberry, etc). Aunque el propio motor no incorpore herramientas de creaci\u00f3n de contenidos, se integra bien con herramientas externas como Tiled o Texture Packer que nos permiten editar escenarios u hojas de sprites respectivamente. Una opci\u00f3n similar es libgdx. En este caso se programa en lenguaje Java, y para pasar a iOS realiza una traducci\u00f3n autom\u00e1tica de Java a C++. Estos motores tienen como ventaja el acceso al c\u00f3digo fuente del motor, en el que puede participar la comunidad, y tambi\u00e9n generan un tama\u00f1o de paquete m\u00e1s reducido que motores m\u00e1s complejos como Unity o sobre todo UE4.","title":"Cocos2d-x"},{"location":"videojuegos_para_moviles.html#tecnologias-nativas-spritekit-y-scenekit","text":"Aunque el uso de motores multiplataforma nos aporta una gran cantidad de ventajas, es algunos casos nos podr\u00eda interesar desarrollar videojuegos utilizando las tecnolog\u00edas nativas de la plataforma. Una posible raz\u00f3n para hacer esto es la de conseguir reducir el tama\u00f1o de la aplicaci\u00f3n lo m\u00e1ximo posible, lo cual puede ser conveniente en juegos sencillos que no necesiten un motor complejo. La tecnolog\u00eda nativa para desarrollo de videojuegos que podemos encontrar en las principales plataformas m\u00f3viles es OpenGL ES . Se trata de una librer\u00eda de bajo nivel, sobre la que tendremos que construir nuestro propio motor adaptado a las necesidades de nuestro videojuego. En el momento de la escritura de este texto, OpenGL ES es la \u00fanica opci\u00f3n nativa en el caso de Android , recomend\u00e1ndose utilizar el NDK para la implementaci\u00f3n de nuestro propio motor del videojuego, y as\u00ed poderlo optimizar al m\u00e1ximo. En Windows Phone encontraremos tambi\u00e9n la API nativa XNA . Contamos con el entorno XNA Game Studio dedicado al desarrollo de videojuegos en la plataforma de Microsoft. Sin embargo, la plataforma que mayor n\u00famero de opciones nativas nos ofrece es la de Apple. En iOS , adem\u00e1s de OpenGL ES , encontramos Metal , una librer\u00eda gr\u00e1fica similar a bajo nivel optimizada para esta plataforma. A parte de las opciones a bajo nivel, tenemos tambi\u00e9n dos librer\u00edas de alto nivel para el desarrollo de videojuegos 2D y 3D respectivamente: SpriteKit y SceneKit . Al ser nativos, nos permitir\u00e1n crear videojuegos optimizados para esta plataforma y reducir el tama\u00f1o del paquete de la aplicaci\u00f3n, pero s\u00f3lo podr\u00e1n ser utilizados en iOS.","title":"Tecnolog\u00edas nativas: SpriteKit y SceneKit"},{"location":"videojuegos_para_moviles.html#caracteristicas-de-los-videojuegos-para-moviles","text":"Los dispositivos m\u00f3viles presentan diferencias notables respecto a los equipos de sobremesa (ordenadores y consolas), en relaci\u00f3n a la capacidad del hardware , la interfaz, y el tipo de uso que se les da. Esto tendr\u00e1 importantes repercusiones en el dise\u00f1o de videojuegos para estos dispositivos. Vamos a revisar a continuaci\u00f3n los principales aspectos que tendremos que tener en cuenta a la hora de dise\u00f1ar videojuegos para dispositivos m\u00f3viles: Limitaciones de la memoria . En los primeros dispositivos (Java ME) la memor\u00eda supon\u00eda una gran limitaci\u00f3n, ya que en algunos dispositivos cont\u00e1bamos con tan solo 128kb para todo el juego. Con el avance de la tecnolog\u00eda esta limitaci\u00f3n se ha ido atenuando y hoy en d\u00eda ya no supone algo cr\u00edtico. Sin embargo, deberemos llevar especial cuidado con la memoria de v\u00eddeo. Por este motivo ser\u00e1 importante seleccionar un formato de textura adecuado (el m\u00e1s compacto que cumpla con las necesidades para el videojuego), y ser\u00e1 com\u00fan comprimir las texturas. Tambi\u00e9n es importante empaquetar nuestros gr\u00e1ficos de forma \u00f3ptima para as\u00ed aprovechar al m\u00e1ximo el espacio de las texturas. Encontraremos herramientas como Texture Packer que se encargan de realizar esta tarea. Tama\u00f1o de la aplicaci\u00f3n . Los videojuegos para plataformas de sobremesa habitualmente ocupan varios gigas. En un m\u00f3vil la distribuci\u00f3n de juegos siempre es digital, por lo que deberemos reducir este tama\u00f1o en la medida de lo posible, tanto para evitar tener que descargar un paquete demasiado grande a trav\u00e9s de la limitada conexi\u00f3n del m\u00f3vil, como para evitar que ocupe demasiado espacio en la memoria de almacenamiento del dispositivo (que en algunos dispositivos es escaso). Para poder descargar un juego v\u00eda conexi\u00f3n de datos no deber\u00eda exceder los 20Mb, por lo que ser\u00e1 recomendable conseguir empaquetarlo en un espacio menor, para que los usuarios puedan acceder a \u00e9l sin necesidad de disponer de Wi-Fi. Esto nos dar\u00e1 una importante ventaja competitiva. Para esto es importante hacer una buena elecci\u00f3n del motor a utilizar. Motores complejos como Unity 5 generan paquetes con un tama\u00f1o m\u00ednimo de unas 20Mb, mientras que otros motores como Cocos2d-x nos permitir\u00edan tener juegos a partir de unas 5Mb. Si nuestro juego no necesita gr\u00e1ficos 3D ni otras de las caracter\u00edsticas que s\u00f3lo se encuentren en Unity, puede ser conveniente seleccionar un motor m\u00e1s sencillo como Cocos2d-x. Capacidad de procesamiento . La CPU y GPU de los m\u00f3viles en muchas ocasiones es m\u00e1s limitada que la de plataformas de sobremesa, y muy variable entre disintos dispositivos. Es importante que los juegos vayan de forma fluida, por lo que antes de distribuirlos deberemos probarlos en diferentes m\u00f3viles reales para asegurarnos de que funcione bien, ya que muchas veces los emuladores funcionar\u00e1n a velocidades distintas. Es conveniente empezar desarrollando un c\u00f3digo claro y limpio, y posteriormente optimizarlo. Para optimizar el juego deberemos identificar el lugar donde tenemos el cuello de botella, que podr\u00eda ser en el procesamiento, o en el dibujado de los gr\u00e1ficos. En el segundo caso podemos ajustar en el motor la calidad de los gr\u00e1ficos para cada plataforma. Pantalla reducida . Deberemos tener esto en cuenta en los juegos, y hacer que todos los objetos se vean correctamente. Podemos utilizar zoom en determinadas zonas para poder visualizar mejor los objetos de la escena. Deberemos cuidar que todos los elementos de la interfaz puedan visualizarse correctamente y que tengan un tama\u00f1o adecuado para interactuar con ellos. Los botones u otros elementos con los que podamos interactuar en la pantalla t\u00e1ctil tendr\u00e1n que tener al menos el tama\u00f1o de la yema del dedo. Diferente interfaz de entrada . Actualmente los m\u00f3viles no suelen tener teclado, y en aquellos que lo tienen este teclado es muy peque\u00f1o. Deberemos intentar proporcionar un manejo c\u00f3modo, adaptado a la interfaz de entrada con la que cuenta el m\u00f3vil, como el aceler\u00f3metro o la pantalla t\u00e1ctil, haciendo que el control sea lo m\u00e1s sencillo posible, con un n\u00famero reducido de posibles acciones. En muchos casos el manejo del juego se reduce a hacer tap en pantalla. Para mec\u00e1nicas m\u00e1s complejas, se puede utilizar un mando virtual (hay que hacer un buen dise\u00f1o del mismo para que sea usable), o soportar mandos externos. Ancho de banda reducido e inestable . Si desarrollamos juegos en red deberemos tener en determinados momentos velocidad puede ser baja, seg\u00fan la cobertura, y podemos tener tambi\u00e9n una elevada latencia de la red. Incluso es posible que en determinados momentos se pierda la conexi\u00f3n temporalmente. Deberemos minimizar el tr\u00e1fico que circula por la red. Posibles interrupciones . En el m\u00f3vil es muy probable que se produzca una interrupci\u00f3n involuntaria de la partida, por ejemplo cuando recibimos una llamada entrante. Deberemos permitir que esto ocurra. Adem\u00e1s tambi\u00e9n es conveniente que el usuario pueda pausar la partida f\u00e1cilmente, ya que estos dispositivos se utilizan habitualmente para \"hacer tiempo\". Si estamos jugando mientras esperamos el autob\u00fas o esperamos nuestro turno en una tienda, cuando llegue nuestro turno deberemos poder interrumpir la partida inmediatamente sin perder nuestro progreso. Es fundamental hacer que cuando otra aplicaci\u00f3n pase a segundo plano nuestro juego se pause autom\u00e1ticamente, para as\u00ed no afectar al progreso que ha hecho el usuario. Incluso lo deseable ser\u00eda que cuando salgamos de la aplicaci\u00f3n en cualquier momento siempre se guarde el estado actual del juego, para que el usuario pueda continuar por donde se hab\u00eda quedado la pr\u00f3xima vez que juegue. Esto permitir\u00e1 que el usuario pueda cerrar el juego en cualquier momento sin miedo de perder sus avances. Ante todo, estos deben ser atractivos para los jugadores, ya que su principal finalidad es entretener. Debemos tener en cuenta que son videojuegos que normalmente se utilizar\u00e1n para hacer tiempo, por lo que es deseable que la curva de aprendizaje sea suave y que permita partidas r\u00e1pidas. Dos aspectos fundamentales son la adquisici\u00f3n y la retenci\u00f3n de jugadores. Tenemos que conseguir que que los usuarios prueben nuestro juego y que continuen jugando a \u00e9l. Para incentivar esto deberemos ofrecerle alguna recompensa por seguir jugando, y la posibilidad de que pueda compartir estos logros con otros jugadores.","title":"Caracter\u00edsticas de los videojuegos para m\u00f3viles"}]}