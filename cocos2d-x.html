



<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copiar al portapapeles">
      
        <meta name="lang:clipboard.copied" content="Copiado al portapapeles">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No se encontraron documentos">
      
        <meta name="lang:search.result.one" content="1 documento encontrado">
      
        <meta name="lang:search.result.other" content="# documentos encontrados">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.4.0">
    
    
      
        <title>Cocos2d-x - Videojuegos para Dispositivos Móviles</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/application.0284f74d.css">
      
        <link rel="stylesheet" href="assets/stylesheets/application-palette.01803549.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
      <script src="assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#el-motor-cocos2d-x" tabindex="1" class="md-skip">
        Saltar a contenido
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="index.html" title="Videojuegos para Dispositivos Móviles" class="md-header-nav__button md-logo">
          
            <img src="imagenes/logo.png" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              Videojuegos para Dispositivos Móviles
            </span>
            <span class="md-header-nav__topic">
              
                Cocos2d-x
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Teclee para comenzar búsqueda
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="index.html" title="Videojuegos para Dispositivos Móviles" class="md-nav__button md-logo">
      
        <img src="imagenes/logo.png" width="48" height="48">
      
    </a>
    Videojuegos para Dispositivos Móviles
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="index.html" title="Presentación" class="md-nav__link">
      Presentación
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="videojuegos_para_moviles.html" title="Introducción a los videojuegos móviles" class="md-nav__link">
      Introducción a los videojuegos móviles
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Fundamentos de los motores
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Fundamentos de los motores
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="fundamentos-motores.html" title="Escena y nodos" class="md-nav__link">
      Escena y nodos
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="motor_de_fisicas.html" title="Físicas" class="md-nav__link">
      Físicas
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="sprites_e_interaccion.html" title="Sprites" class="md-nav__link">
      Sprites
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="escenario_y_fondos.html" title="Fondo y scroll" class="md-nav__link">
      Fondo y scroll
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    
    <label class="md-nav__link" for="nav-4">
      Motores para  móviles
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Motores para  móviles
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="spritekit.html" title="SpriteKit" class="md-nav__link">
      SpriteKit
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="scenekit.html" title="SceneKit" class="md-nav__link">
      SceneKit
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Cocos2d-x
      </label>
    
    <a href="cocos2d-x.html" title="Cocos2d-x" class="md-nav__link md-nav__link--active">
      Cocos2d-x
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#instalacion-de-cocos2d-x" title="Instalación de Cocos2d-x" class="md-nav__link">
    Instalación de Cocos2d-x
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#instalacion-de-cocos2d-x_1" title="Instalación de Cocos2d-x" class="md-nav__link">
    Instalación de Cocos2d-x
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#organizacion-del-motor" title="Organización del motor" class="md-nav__link">
    Organización del motor
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#el-singleton-director" title="El singleton Director" class="md-nav__link">
    El singleton Director
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#creacion-de-escenas" title="Creación de escenas" class="md-nav__link">
    Creación de escenas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transiciones-entre-escenas" title="Transiciones entre escenas" class="md-nav__link">
    Transiciones entre escenas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#arbol-de-la-escena" title="Árbol de la escena" class="md-nav__link">
    Árbol de la escena
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tipos-de-datos" title="Tipos de datos" class="md-nav__link">
    Tipos de datos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gestion-de-la-memoria" title="Gestión de la memoria" class="md-nav__link">
    Gestión de la memoria
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#contador-de-referencias" title="Contador de referencias" class="md-nav__link">
    Contador de referencias
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quien-retiene-debe-liberar" title="Quien retiene, debe liberar" class="md-nav__link">
    Quien retiene, debe liberar
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estructuras-de-cocos2d-x" title="Estructuras de Cocos2d-x" class="md-nav__link">
    Estructuras de Cocos2d-x
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#referencias-fuertes" title="Referencias fuertes" class="md-nav__link">
    Referencias fuertes
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#interfaz-de-usuario" title="Interfaz de usuario" class="md-nav__link">
    Interfaz de usuario
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etiquetas" title="Etiquetas" class="md-nav__link">
    Etiquetas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#menus" title="Menús" class="md-nav__link">
    Menús
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sprites" title="Sprites" class="md-nav__link">
    Sprites
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#posicion" title="Posición" class="md-nav__link">
    Posición
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fotogramas" title="Fotogramas" class="md-nav__link">
    Fotogramas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#animacion" title="Animación" class="md-nav__link">
    Animación
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sprite-batch" title="Sprite batch" class="md-nav__link">
    Sprite batch
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#colisiones" title="Colisiones" class="md-nav__link">
    Colisiones
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#motor-del-juego" title="Motor del juego" class="md-nav__link">
    Motor del juego
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ciclo-del-juego" title="Ciclo del juego" class="md-nav__link">
    Ciclo del juego
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#actualizacion-de-la-escena" title="Actualización de la escena" class="md-nav__link">
    Actualización de la escena
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#acciones" title="Acciones" class="md-nav__link">
    Acciones
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tilemaps" title="Tilemaps" class="md-nav__link">
    Tilemaps
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#capas-de-patrones" title="Capas de patrones" class="md-nav__link">
    Capas de patrones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conversion-entre-coordenadas-de-la-escena-y-tilecoords" title="Conversion entre coordenadas de la escena y tilecoords" class="md-nav__link">
    Conversion entre coordenadas de la escena y tilecoords
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modificacion-del-mapa" title="Modificación del mapa" class="md-nav__link">
    Modificación del mapa
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#capas-de-objetos" title="Capas de objetos" class="md-nav__link">
    Capas de objetos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#scroll-del-escenario" title="Scroll del escenario" class="md-nav__link">
    Scroll del escenario
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#limites-del-escenario" title="Límites del escenario" class="md-nav__link">
    Límites del escenario
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scroll-parallax" title="Scroll parallax" class="md-nav__link">
    Scroll parallax
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reproduccion-de-audio" title="Reproducción de audio" class="md-nav__link">
    Reproducción de audio
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#musica-de-fondo" title="Música de fondo" class="md-nav__link">
    Música de fondo
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#efectos-de-sonido" title="Efectos de sonido" class="md-nav__link">
    Efectos de sonido
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="unity.html" title="Unity" class="md-nav__link">
      Unity
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="box2d.html" title="Box2D" class="md-nav__link">
      Box2D
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="mandos.html" title="Controles del videojuego" class="md-nav__link">
      Controles del videojuego
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="adaptacion_a_moviles.html" title="Adaptación a diferentes dispositivos" class="md-nav__link">
      Adaptación a diferentes dispositivos
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="redes_sociales.html" title="Logros y marcadores" class="md-nav__link">
      Logros y marcadores
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#instalacion-de-cocos2d-x" title="Instalación de Cocos2d-x" class="md-nav__link">
    Instalación de Cocos2d-x
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#instalacion-de-cocos2d-x_1" title="Instalación de Cocos2d-x" class="md-nav__link">
    Instalación de Cocos2d-x
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#organizacion-del-motor" title="Organización del motor" class="md-nav__link">
    Organización del motor
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#el-singleton-director" title="El singleton Director" class="md-nav__link">
    El singleton Director
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#creacion-de-escenas" title="Creación de escenas" class="md-nav__link">
    Creación de escenas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transiciones-entre-escenas" title="Transiciones entre escenas" class="md-nav__link">
    Transiciones entre escenas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#arbol-de-la-escena" title="Árbol de la escena" class="md-nav__link">
    Árbol de la escena
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tipos-de-datos" title="Tipos de datos" class="md-nav__link">
    Tipos de datos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gestion-de-la-memoria" title="Gestión de la memoria" class="md-nav__link">
    Gestión de la memoria
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#contador-de-referencias" title="Contador de referencias" class="md-nav__link">
    Contador de referencias
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quien-retiene-debe-liberar" title="Quien retiene, debe liberar" class="md-nav__link">
    Quien retiene, debe liberar
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estructuras-de-cocos2d-x" title="Estructuras de Cocos2d-x" class="md-nav__link">
    Estructuras de Cocos2d-x
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#referencias-fuertes" title="Referencias fuertes" class="md-nav__link">
    Referencias fuertes
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#interfaz-de-usuario" title="Interfaz de usuario" class="md-nav__link">
    Interfaz de usuario
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etiquetas" title="Etiquetas" class="md-nav__link">
    Etiquetas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#menus" title="Menús" class="md-nav__link">
    Menús
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sprites" title="Sprites" class="md-nav__link">
    Sprites
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#posicion" title="Posición" class="md-nav__link">
    Posición
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fotogramas" title="Fotogramas" class="md-nav__link">
    Fotogramas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#animacion" title="Animación" class="md-nav__link">
    Animación
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sprite-batch" title="Sprite batch" class="md-nav__link">
    Sprite batch
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#colisiones" title="Colisiones" class="md-nav__link">
    Colisiones
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#motor-del-juego" title="Motor del juego" class="md-nav__link">
    Motor del juego
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ciclo-del-juego" title="Ciclo del juego" class="md-nav__link">
    Ciclo del juego
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#actualizacion-de-la-escena" title="Actualización de la escena" class="md-nav__link">
    Actualización de la escena
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#acciones" title="Acciones" class="md-nav__link">
    Acciones
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tilemaps" title="Tilemaps" class="md-nav__link">
    Tilemaps
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#capas-de-patrones" title="Capas de patrones" class="md-nav__link">
    Capas de patrones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conversion-entre-coordenadas-de-la-escena-y-tilecoords" title="Conversion entre coordenadas de la escena y tilecoords" class="md-nav__link">
    Conversion entre coordenadas de la escena y tilecoords
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modificacion-del-mapa" title="Modificación del mapa" class="md-nav__link">
    Modificación del mapa
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#capas-de-objetos" title="Capas de objetos" class="md-nav__link">
    Capas de objetos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#scroll-del-escenario" title="Scroll del escenario" class="md-nav__link">
    Scroll del escenario
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#limites-del-escenario" title="Límites del escenario" class="md-nav__link">
    Límites del escenario
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scroll-parallax" title="Scroll parallax" class="md-nav__link">
    Scroll parallax
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reproduccion-de-audio" title="Reproducción de audio" class="md-nav__link">
    Reproducción de audio
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#musica-de-fondo" title="Música de fondo" class="md-nav__link">
    Música de fondo
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#efectos-de-sonido" title="Efectos de sonido" class="md-nav__link">
    Efectos de sonido
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="el-motor-cocos2d-x">El motor cocos2d-x<a class="headerlink" href="#el-motor-cocos2d-x" title="Permanent link">&para;</a></h1>
<p>Uno de los motores más conocidos y utilizados para desarrollo de videojuegos para
dispositivos móviles es <strong>Cocos2D</strong>. Existe gran
cantidad de juegos para iOS implementados con este motor. Aunque inicialmente se trataba de un motor escrito en Objective-C únicamente para iOS, actualmente contamos con <a href="https://www.cocos.com/en/">Cocos2d-x</a> que es la versión multiplataforma de este motor. </p>
<p>El juego se desarrolla con C++, y puede ser portado directamente a distintos tipos de dispositivos (Android, iOS, y plataformas de escritorio). </p>
<p>Vamos a comenzar viendo cómo instalar el motor Cocos2d-x y crear un nuevo proyecto con él. </p>
<h2 id="instalacion-de-cocos2d-x">Instalación de Cocos2d-x<a class="headerlink" href="#instalacion-de-cocos2d-x" title="Permanent link">&para;</a></h2>
<p>Si entramos en la <a href="https://www.cocos.com/en/">página web de Cocos</a>, veremos que ofrecen dos productos principales:</p>
<ul>
<li><strong>Cocos</strong>. Herramienta visual de creación de videojuegos. Podremos introducir <em>scripts</em> con lenguajes como Javacript o LUA.</li>
<li><strong>Cocos2d-x</strong>. <em>Framework</em> escrito en C++ para el desarrollo de videojuegos. El videojuego se implementará en clases C++, y dentro de ellas tendremos la opción de cargar contenidos creados con la herramienta anterior o con otras herramientas de terceros.</li>
</ul>
<p>Nos decantaremos por la segunda opción, para crear videojuegos en C++. Veremos que la API de este motor es muy similar a la que encontramos en motores como SpriteKit y SceneKit, en este caso centrada en contenido 2D.</p>
<h3 id="instalacion-de-cocos2d-x_1">Instalación de Cocos2d-x<a class="headerlink" href="#instalacion-de-cocos2d-x_1" title="Permanent link">&para;</a></h3>
<p>Para instalar Cocos2d-x simplemente deberemos:</p>
<ol>
<li><strong><a href="https://www.cocos.com/en/cocos2dx">Descargar</a> y descomprimir</strong> Cocos2d-x en el directorio donde queramos tenerlo instalado.</li>
<li>En un <em>Terminal</em>, ir al directorio donde hayamos descomprimido el motor y ejecutar:
    <table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>./setup.py
</pre></div>
</td></tr></table></li>
<li>Nos preguntará por las rutas donde tengamos instalado <code>ANDROID_SDK</code> y <code>ANDROID_NDK</code>. Estas rutas en macOS por defecto son las siguientes, aunque podría cambiar:
    <table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="nv">ANDROID_SDK</span><span class="o">=</span>~/Library/Android/sdk/
<span class="nv">ANDROID_NDK</span><span class="o">=</span>~/Library/Android/sdk/ndk-bundle/
</pre></div>
</td></tr></table></li>
</ol>
<p>De esta manera tendremos acceso a un script llamado <code>cocos</code>que permite entre otras cosas crear la plantilla para un nuevo proyecto Cocos2d-x multiplataforma. </p>
<p>Deberemos proporcionar la siguiente información:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>cocos new MiJuego   -p es.ua.eps.MiJuego
                    -l cpp
</pre></div>
</td></tr></table>

<p>Esto nos creará un proyecto (carpeta) <code>MiJuego</code> en el directorio donde nos encontremos, con <em>bundle ID</em> <code>es.ua.eps.MiJuego</code>. El lenguaje utilizado será C++ (<code>-l cpp</code>). </p>
<p>Dentro del directorio generado encontraremos los siguientes directorios:</p>
<ul>
<li><code>Classes</code>: Código fuente C++ de nuestro juego</li>
<li><code>Resources</code>: Recursos y <em>assets</em> del videojuego (<em>sprites</em>, efectos de sonido, fuentes, ficheros de datos, etc)</li>
</ul>
<p>El contenido de los dos directorios anteriores será común para <strong>todas las plataformas</strong> soportadas por Cocos2d-x. Será en ellos donde introduciremos los distintos componentes del videojuego. </p>
<p>Además, encontraremos una serie de carpetas adicionales con recursos propios de cada plataforma específica:</p>
<ul>
<li><code>proj.ios_mac</code>: Recursos para las versiones iOS y Mac basadas en el entorno Xcode. </li>
<li><code>proj.android</code>: Recursos para la plataforma Android (entorno Android Studio)</li>
<li><code>proj.linux</code>: Recursos para la compilación para Linux (se compila desde línea de comando)</li>
<li><code>proj.win32</code>: Recursos para la compilación para Windows (proyecto Visual Studio)</li>
</ul>
<p><img alt="Organización del proyecto" src="imagenes/cocos/cocos_directorios.png" /></p>
<h4>Configuración CMake</h4>
<p>Para la construcción de los proyectos se utiliza la herramienta <a href="https://cmake.org">CMake</a>, por lo que es necesario tenerla instalada. </p>
<p>Encontramos además en la raíz del proyecto un fichero <code>CMakeLists.txt</code> en el que se indica la forma de construir el proyecto multiplataforma. En dicho fichero simplemente tendremos que actualizar la lista de clases a compilar. En la plantilla veremos un bloque como el siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="o">#</span> <span class="k">add</span> <span class="k">cross</span><span class="o">-</span><span class="n">platforms</span> <span class="k">source</span> <span class="n">files</span> <span class="k">and</span> <span class="n">header</span> <span class="n">files</span> 
<span class="n">list</span><span class="p">(</span><span class="n">APPEND</span> <span class="n">GAME_SOURCE</span>
     <span class="n">Classes</span><span class="o">/</span><span class="n">AppDelegate</span><span class="p">.</span><span class="n">cpp</span>
     <span class="n">Classes</span><span class="o">/</span><span class="n">HelloWorldScene</span><span class="p">.</span><span class="n">cpp</span>
     <span class="p">)</span>
<span class="n">list</span><span class="p">(</span><span class="n">APPEND</span> <span class="n">GAME_HEADER</span>
     <span class="n">Classes</span><span class="o">/</span><span class="n">AppDelegate</span><span class="p">.</span><span class="n">h</span>
     <span class="n">Classes</span><span class="o">/</span><span class="n">HelloWorldScene</span><span class="p">.</span><span class="n">h</span>
     <span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Deberemos ir actualizando este bloque conforme añadamos o eliminemos clases de nuestro proyecto.</p>
<h4>Compilación en línea de comando</h4>
<p>Tenemos también la opción de compilar y ejecutar el proyecto desde la consola con el comando <code>cocos</code>. </p>
<p>Por ejemplo, si queremos compilar el proyecto para la plataforma macOS, desde el directorio del proyecto podemos hacer:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>cocos compile -p mac
</pre></div>
</td></tr></table>

<p>Podemos también ejecutar el proyecto en dicha plataforma con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>cocos run -p mac
</pre></div>
</td></tr></table>

<p>En este caso previamente lo compilará, si fuera necesario. </p>
<p>Podemos compilar y ejecutar para el resto de plataformas disponibles.  Puedes ver la <a href="https://docs.cocos.com/cocos2d-x/v4/manual/en/editors_and_tools/cocosCLTool.html">documentación de la herramienta de consola de Cocos</a> para más información.</p>
<p>Esta forma de trabajar en línea de comando será la habitual si estamos en <strong>entorno Linux</strong> y queremos probar el proyecto como aplicación de escritorio Linux. </p>
<p>Pero tenemos la opción de trabajar en otros entornos, como Android Studio (para probar en <strong>Android</strong>), Xcode (para probar en <strong>iOS</strong> y <strong>Mac</strong>) y Visual Studio (para probar en <strong>Windows</strong>). </p>
<p>Podremos elegir el entorno de desarrollo que nos resulte más conveniente. Hemos de destacar que podremos cambiar de uno a otro sin problemas, ya que el código que introduzcamos estará siempre en carpetas compartidas por todas las plataformas. Podremos elegir el entorno en el que nos encontremos más cómodos, y utilizar el resto sólo cuando queramos hacer pruebas en plataformas específicas.</p>
<p>A continuación vamos a ver cómo trabajar con cada entorno.</p>
<h4>Proyecto Android</h4>
<p>Desde Android Studio podremos abrir directamente el proyecto que se encuentra en el directorio <code>proj.android</code>. </p>
<p>Podremos construir y ejecutar el proyecto directamenter desde Android Studio, aunque para que la construcción funcione debemos <a href="https://ninja-build.org">tener instalado el sistema de construcción Ninja</a>. En caso contrario, obtendremos un error durante el proceso de construcción. </p>
<h4>Proyecto iOS / Mac</h4>
<p>En <strong>Cocos2d-x 3.X</strong>, dentro del directorio <code>proj.ios_mac</code> encontraremos un proyecto Xcode que podremos abrir directamente con este IDE. </p>
<p>Sin embargo, en <strong>Cocos2d-x 4.X</strong> será necesario generar un proyecto para las plataformas iOS y Mac utilizando la herramienta CMake:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1"># Generación del proyecto Xcode para MacOS</span>
mkdir mac-build <span class="o">&amp;&amp;</span> <span class="nb">cd</span> mac-build
cmake .. -GXcode

<span class="c1"># Generación del proyecto Xcode para iOS </span>
mkdir ios-build <span class="o">&amp;&amp;</span> <span class="nb">cd</span> ios-build
cmake .. -GXcode -DCMAKE_SYSTEM_NAME<span class="o">=</span>iOS -DCMAKE_OSX_SYSROOT<span class="o">=</span>iphoneos
</pre></div>
</td></tr></table>

<p>Una vez creado el proyecto (directorio <code>mac-build</code> o <code>ios-build</code>) podremos abrirlo con Xcode y trabajar de forma normal con este entorno. </p>
<h4>Proyecto Windows</h4>
<p>Tenemos también la opción de trabajar en Windows con Visual Studio. Al igual que en el caso de Xcode, con <strong>Cocos2d-x 3.X</strong> disponemos de dicho proyecto directamente, pero en <strong>Cocos2d-x 4.X</strong> deberemos generarlo con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1"># Generación del proyecto Visual Studio para Windows</span>
mkdir win32-build <span class="o">&amp;&amp;</span> <span class="nb">cd</span> win32-build
cmake .. -G<span class="s2">&quot;Visual Studio 15 2017&quot;</span> -Tv141
</pre></div>
</td></tr></table>

<p>Puedes ver la <a href="https://docs.cocos.com/cocos2d-x/v4/manual/en/installation/CMake-Guide.html">documentación de CMake en Cocos2d-x 4.0</a> para más detalles. </p>
<h2 id="organizacion-del-motor">Organización del motor<a class="headerlink" href="#organizacion-del-motor" title="Permanent link">&para;</a></h2>
<p>En el apartado anterior hemos visto cómo crear un nuevo proyecto Cocos2d-x. Vamos ahora a ver cómo están estructuradas las clases de esto motor.</p>
<h3 id="el-singleton-director">El <em>singleton</em> <code>Director</code><a class="headerlink" href="#el-singleton-director" title="Permanent link">&para;</a></h3>
<p>El <strong>elemento central del motor</strong> es un <em>singleton</em> de tipo <code>Director</code>, al que podemos acceder de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>El <strong>director</strong> será el encargado de gestionar toda la ejecución del juego, y entre sus funciones se encuentran:</p>
<ul>
<li>Tiene una <strong>escena activa</strong>, y permite realizar transiciones a otras escenar, representadas todas ellas con la clase <code>Scene</code>.</li>
<li>Gestiona el <strong>ciclo del juego</strong>, actualizando y <em>renderizando</em> la escena activa en cada iteración. Sólo se actualizará y se mostrará la escena que esté actualmente activa.</li>
</ul>
<h3 id="creacion-de-escenas">Creación de escenas<a class="headerlink" href="#creacion-de-escenas" title="Permanent link">&para;</a></h3>
<p>En Cocos2d-x la escena se representa con la clase <code>Scene</code>, y contendrá un árbol de nodos, los cuales están representados por la clase <code>Node</code>. La propia escena es un nodo (<code>Scene</code> es subclase de <code>Node</code>), y tendrá como papel siempre hacer de nodo raíz del árbol de nodos de la escena.</p>
<p>Antes de entrar a estudiar el árbol de la escena, vamos a ver cómo crear una escena. Para crear cada escena (pantalla) del videojuego, crearemos una clase que herede de <code>Scene</code>, como la que vemos a continuación (fichero <code>.h</code>):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// MenuScene.h</span>

<span class="k">class</span> <span class="nc">MenuScene</span> <span class="o">:</span> <span class="k">public</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">Scene</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">cocos2d</span><span class="o">::</span><span class="n">Scene</span><span class="o">*</span> <span class="n">createScene</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">init</span><span class="p">();</span>

    <span class="n">CREATE_FUNC</span><span class="p">(</span><span class="n">MenuScene</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>Todos los objetos de Cocos2d-x se instanciarán mediante un método <code>create</code>, incluyendo la escena. Este <em>método factoría</em> se genera de forma estática con la macro <code>CREATE_FUNC</code>, por ese motivo está declarada en la clase anterior. </p>
<p>Ya en la implementación de la clase (fichero <code>.cpp</code>), podemos implementar el método estático <code>createScene</code> que hemos declarado anteriormente de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// MenuScene.cpp</span>

<span class="n">Scene</span><span class="o">*</span> <span class="n">MenuScene</span><span class="o">::</span><span class="n">createScene</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">MenuScene</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Recordamos que podemos utilizar este método <code>create</code> porque lo hemos declarado previamente con <code>CREATE_FUNC</code>. Dicho método instanciará la clase y reservará memoria para el nuevo objeto, sin que tengamos que hacerlo nosotros, pero para inicializarlo llamará al método <code>init()</code> donde nosotros podremos indicar la forma en la que se inicializan nuestros objetos. Este método tendrá habitualmente la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">bool</span> <span class="n">MenuScene</span><span class="o">::</span><span class="n">init</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">Scene</span><span class="o">::</span><span class="n">init</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Inicializar componentes de la escena</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Lo primero que hacemos es inicializar la superclase (en nuestro caso <code>Scene</code>). Si todo va bien, inicializaremos todos los componentes de la escena (etiquetas, menús, <em>sprites</em>, etc) y los añadiremos al árbol de nodos.</p>
<p>Más adelante veremos cómo crear estos nodos, pero antes vamos a ver cómo cambiar la escena que se muestra en el motor.</p>
<h3 id="transiciones-entre-escenas">Transiciones entre escenas<a class="headerlink" href="#transiciones-entre-escenas" title="Permanent link">&para;</a></h3>
<p>Al ejecutar el motor deberemos indicar la escena que mostraremos inicialmente como escena activa. Esto lo haremos con el método <code>runWithScene</code> del director:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">runWithScene</span><span class="p">(</span><span class="n">MenuPrincipal</span><span class="o">::</span><span class="n">scene</span><span class="p">());</span>
</pre></div>
</td></tr></table>

<p>Con esto pondremos en marcha el motor del juego mostrando la escena indicada. Si el motor ya está en marcha y queremos cambiar de escena, deberemos hacerlo con el método <code>replaceScene</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">replaceScene</span><span class="p">(</span><span class="n">Creditos</span><span class="o">::</span><span class="n">scene</span><span class="p">());</span>
</pre></div>
</td></tr></table>

<p>También podemos implementar transiciones entre escenas de forma animada utilizando como escena una serie de clases todas ellas con prefijo <code>Transition*</code>, que heredan de <code>TransitionScene</code>,
y que a su vez hereda de <code>Scene</code>. </p>
<p>Podemos mostrar una transición animada reemplazando la
escena actual por una escena de transición:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Scene</span> <span class="o">*</span><span class="n">puntuacionesScene</span> <span class="o">=</span> <span class="n">Puntuaciones</span><span class="o">::</span><span class="n">scene</span><span class="p">();</span>
<span class="n">TransitionCrossFade</span> <span class="o">*</span><span class="n">transition</span> <span class="o">=</span> 
    <span class="n">TransitionCrossFade</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">puntuacionScene</span><span class="p">);</span>
<span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">replaceScene</span><span class="p">(</span><span class="n">transition</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Podemos observar que la escena de transición se construye a partir de la duración de la transición, y de la escena que debe mostrarse una vez finalice la transición.</p>
<h3 id="arbol-de-la-escena">Árbol de la escena<a class="headerlink" href="#arbol-de-la-escena" title="Permanent link">&para;</a></h3>
<p>El contenido de la escena se definirá como un árbol de nodos, todos ellos subclases de <code>Node</code>. Entre las subclases encontramos:</p>
<ul>
<li><code>Scene</code>: Hará siempre de nodo raíz del árbol.</li>
<li><code>Label</code>: Etiquetas de texto</li>
<li><code>Sprite</code>: Personajes y otros elementos que podremos mover por pantalla y animar.</li>
<li><code>TMXTiledMap</code>: Mapa que podremos utilizar para el fondo del escenario.</li>
<li><code>Layer</code>: Nodo que implementa eventos de la pantalla táctil y al que podremos añadir contenido como hijos.</li>
</ul>
<p><img alt="Árbol de la escena" src="imagenes/cocos/cocos_arbol.png" /></p>
<p>Podemos añadir un nodo como hijo de cualquier nodo de la escena con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">_fondo</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">_personaje</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Al añadirlo podemos también especificar el <em>orden Z</em> del nodo (orden de dibujado entre sus hermanos). También podremos establecer o modificar este orden mediante el método <code>setLocalZOrder()</code>.</p>
<p>Podremos eliminar un nodo de la escena eliminandolo de su padre:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">_personaje</span><span class="o">-&gt;</span><span class="n">removeFromParent</span><span class="p">();</span>
</pre></div>
</td></tr></table>

<p>También podremos buscar un nodo dado su nombre, o listar todos los hijos de un determinado nodo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">_fondo</span><span class="o">-&gt;</span><span class="n">getChildByName</span><span class="p">(</span><span class="err">“</span><span class="n">personaje</span><span class="err">”</span><span class="p">);</span>
<span class="n">_fondo</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">();</span>
</pre></div>
</td></tr></table>

<h3 id="tipos-de-datos">Tipos de datos<a class="headerlink" href="#tipos-de-datos" title="Permanent link">&para;</a></h3>
<p>Como hemos comentado, Cocos2d-x proviene del motor Cocos2d para iOS. Este motor estaba  implementado en Objective-C, sobre la API Cocoa Touch, y por lo tanto estaba muy vinculado a sus tipos de datos. </p>
<p>Por este motivo Cocos2d-x implementa sus propios tipos de datos equivalentes a los de Cocoa Touch para poder trabajar de la misma forma. Vamos a ver cuáles son estos tipos de datos.</p>
<p>Por un lado tenemos la clase <code>Ref</code>. Todos los objetos de la librería
heredan en última instancia de esta clase. En ella se define por ejemplo el mecanismo de gestión de memoria que utilizan todos los objetos de la librería.</p>
<p>Tenemos una serie de colecciones como <code>Vector&lt;&gt;</code>, <code>Map&lt;&gt;</code> especiales de Cocos2d-x que tienen en cuenta su modelo particular de memoria, pero con los que podremos utilizar la sintaxis de C++ para este tipo de colecciones. También tenemos los tipos <code>Value</code>, <code>ValueVector</code> y <code>ValueMap</code> para la representación de estructuras de datos, que nos permiten por ejemplo cargar ficheros <code>.plist</code> de forma automática. El primero de ellos es un <em>wrapper</em> que permite almacenar tipos básicos (<code>bool</code>, <code>int</code>, <code>string</code>, etc) o complejos, mientras que los otros dos representan las listas y diccionarios respectivamente.</p>
<p>Encontramos también una serie de tipos de datos geométricos: <code>Point</code>, 
<code>Rect</code> y <code>Size</code>. Estos tipos de datos incorporan también algunas
operaciones, por ejemplo para comprobar si dos rectángulos intersectan.</p>
<h2 id="gestion-de-la-memoria">Gestión de la memoria<a class="headerlink" href="#gestion-de-la-memoria" title="Permanent link">&para;</a></h2>
<p>La memoria en Cocos2d-x se gestiona mediante cuenta de referencias, siguiendo el mismo mecanismo de gestión de memoria que se utilizaba antiguamente en iOS. </p>
<h3 id="contador-de-referencias">Contador de referencias<a class="headerlink" href="#contador-de-referencias" title="Permanent link">&para;</a></h3>
<p>Este mecanismo consiste en que los objetos de la librería (todos  derivan en última instancia de <code>Ref</code>) tienen un contador de referencias que existen hacia ellos.  Cuando el contador de referencias llegue a cero, el objeto se eliminará de memoria.</p>
<p>Podemos incrementar el número de referencias sobre un objeto llamando a su método  <code>retain</code>, y decrementarlo llamando a <code>release</code>. En caso de que al hacer <code>release</code> el contador de referencias llegue a <code>0</code>, el objeto será eliminado inmediatamente de la memoria.</p>
<p>Existe un tercer método para manipular dicho contador de referencias: <code>autorelease</code>. Dicho método no decrementa el contador inmediatamente, sino que deja programado el decremento para el final del ciclo actual del juego. Es decir, podremos seguir utilizando el objeto mientras dure el ciclo, pero al final de éste, si el contador llegase a cero, se eliminará el objeto. </p>
<p>Deberemos asegurarnos de que el número de llamadas a <code>retain</code> sobre un objeto sea igual al número de llamadas a <code>release</code> / <code>autorelease</code>. Si el primero fuese superior al segundo,  entonces tendríamos una fuga de memoria. Si fuese inferior tendríamos un error de acceso a memoria cuando intentemos decrementar las referencias de un objeto que ha sido ya liberado. </p>
<h3 id="quien-retiene-debe-liberar">Quien retiene, debe liberar<a class="headerlink" href="#quien-retiene-debe-liberar" title="Permanent link">&para;</a></h3>
<p>Si no organizamos bien el código de gestión de memoria puede ser complicado garantizar que el número de llamadas a<code>retain</code> y a <code>release</code> / <code>autorelease</code> esté equilibrado. Para evitar este problema la regla fundamental es que quien incremente el número de referencias (<code>retain</code>) será responsable de decrementarlo (<code>release</code> /  <code>autorelease</code>). Vemos a continuación con mayor detalle las implicaciones que esta regla tiene en el uso de la librería:</p>
<p>Cuando instanciamos un objeto con el método factoría <code>create</code>, éste método lo inicializa con una referencia, pero él mismo es responsable de eliminarla. Si lo hiciese antes de devolver el objeto, éste se eliminaría de la memoria antes de que alguien pudiera usarlo, mientras que si no lo hace en ese momento ya no tendrá más oportunidades de liberarlo. Para solucionar este problema hará uso del método <code>autorelease</code>, dejando programado que la referencia se librere automáticamente cuando termine el ciclo actual. De esta forma, el código que haya llamado a <code>create</code> tendrá la oportunidad de retener el objeto recibido, y entonces se mantendría en memoria, pero si nadie lo retuviese sería eliminado al final del ciclo.</p>
<h3 id="estructuras-de-cocos2d-x">Estructuras de Cocos2d-x<a class="headerlink" href="#estructuras-de-cocos2d-x" title="Permanent link">&para;</a></h3>
<p>Cuando añadimos un nodo como hijo de otro en la escena 2D, o cuando se añade un objeto a otras estructuras como los tipos <code>Vector</code> o <code>Map</code> de Cocos2d-x, o alguna de las cachés de objetos que gestiona el motor, estas estructuras se encargarán de retener el objeto en memoria, y cuando se elimine de ellas lo liberarán. </p>
<p>Es decir, podemos por ejemplo crear un nodo con <code>create</code> y en ese momento añadirlo como hijo a otro con <code>addChild</code>, y no tendremos que preocuparnos de retenerlo ni de liberarlo nosotros. El propio grafo de la escena será el encargado de gestionar la memoria en este caso.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="nt">Node</span> <span class="o">*</span><span class="nt">nodo</span> <span class="o">=</span> <span class="nt">Node</span><span class="p">::</span><span class="nd">create</span><span class="o">();</span>
<span class="nt">this-</span><span class="o">&gt;</span><span class="nt">addChild</span><span class="o">(</span><span class="nt">nodo</span><span class="o">);</span>
</pre></div>
</td></tr></table>

<p>Esta será la forma más habitual de trabajar, y que hará que la gestión de la memoria sea totalmente transparente, sin tener que hacer nada nosotros.</p>
<h3 id="referencias-fuertes">Referencias fuertes<a class="headerlink" href="#referencias-fuertes" title="Permanent link">&para;</a></h3>
<p>Si queremos guardar un nodo como campo de nuestro objeto con una <strong>referencia fuerte</strong> hacia él, tras instanciarlo con  <code>create</code> deberemos reternarlo con <code>retain</code> para que no se libere automáticamente. De esta forma, aunque no estuviera retenido por otros objetos, nosotros lo mantendremos en memoria.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// .h</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">cocos2d</span><span class="o">::</span><span class="n">Node</span> <span class="o">*</span><span class="n">_hud</span><span class="p">;</span>

<span class="c1">// .cpp</span>

<span class="n">Game</span><span class="o">::</span><span class="n">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="n">_hud</span> <span class="o">=</span> <span class="n">Node</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
    <span class="n">_hud</span><span class="o">-&gt;</span><span class="n">retain</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Como lo hemos retenido, nosotros seremos responsables de liberarlo, por lo que  deberemos llamar a <code>release</code> sobre dicho campo cuando nuestro objeto sea destruido (en el destructor de la clase), o cuando vayamos a cambiar el valor del campo y el antiguo deba ser liberado. </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// .cpp</span>

<span class="n">Game</span><span class="o">::~</span><span class="n">Game</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">_hud</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_hud</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
        <span class="n">_hud</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Es recomendable, como vemos en el código anterior, poner a <code>NULL</code> el objeto cuando lo hayamos liberado, para así saber que ya está liberado y evitar liberar dos veces por error. Hay una macro de Cocos2d-x que implementa este comportamiento. El siguiente código sería equivalente al anterior, pero usando dicha macro:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// .cpp</span>

<span class="n">Game</span><span class="o">::~</span><span class="n">Game</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">CC_SAFE_RELEASE_NULL</span><span class="p">(</span><span class="n">_hud</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h2 id="interfaz-de-usuario">Interfaz de usuario<a class="headerlink" href="#interfaz-de-usuario" title="Permanent link">&para;</a></h2>
<p>Encontramos distintos tipos de nodos que podemos añadir a la escena para crear nuestra interfaz de usuario, como por ejemplo menús y etiquetas de texto, que nos pueden servir por ejemplo para mostrar
el marcador de puntuación, o el mensaje <em>Game Over</em>. </p>
<h3 id="etiquetas">Etiquetas<a class="headerlink" href="#etiquetas" title="Permanent link">&para;</a></h3>
<p>Tenemos dos formas alternativas de crear una etiqueta de texto:</p>
<ul>
<li>Utilizar una fuente <em>TrueType</em> predefinida.</li>
<li>Crear nuestro propio tipo de fuente <em>bitmap</em>.</li>
</ul>
<p>La primera opción es la más sencilla, ya que podemos crear la cadena directamente a partir de un tipo de fuente ya existen y añadirla a la escena con <code>addChild</code> (por ejemplo añadiéndola como hija
de la capa principal de la escena). Se define mediante la clase <code>LabelTTF</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">LabelTTF</span><span class="o">*</span> <span class="n">label</span> <span class="o">=</span> <span class="n">LabelTTF</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;Game Over&quot;</span><span class="p">,</span> <span class="s">&quot;Arial&quot;</span><span class="p">,</span> <span class="mi">24</span><span class="p">);</span>
<span class="k">this</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">label</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Sin embargo, en un videojuego debemos cuidar al máximo el aspecto y la personalización de los gráficos.
Por lo tanto, suele ser más adecuado crear nuestros propios tipos de fuentes. La mayoría de motores de
videojuegos soportan el formato <code>.fnt</code>, con el que podemos definir fuentes de tipo
<em>bitmap</em> personalizadas. Para crear una fuente con dicho formato podemos utilizar herramientas
como <strong>Angel Code</strong> o <a href="http://www.n4te.com/hiero/hiero.jnlp"><strong>Hiero</strong></a>.
Una vez creada la fuente con este formato, podemos mostrar una cadena con dicha fuente mediante
la clase <code>LabelBMFont</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">LabelBMFont</span> <span class="o">*</span><span class="n">label</span> <span class="o">=</span> <span class="n">LabelBMFont</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;Game Over&quot;</span><span class="p">,</span> <span class="s">&quot;fuente.fnt&quot;</span><span class="p">);</span>
<span class="k">this</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">label</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p><img alt="Herramienta Hiero Font Tool" src="imagenes/juegos/herramientas_hiero.jpg" /></p>
<h3 id="menus">Menús<a class="headerlink" href="#menus" title="Permanent link">&para;</a></h3>
<p>Por otro lado, también podemos crear menús de opciones. Normalmente en la pantalla principal del juego
siempre encontraremos un menú con todas las opciones que nos ofrece dicho juego. Los menús se crean con
la clase <code>Menu</code>, a la que añadiremos una serie de <em>items</em>, de tipo <code>MenuItem</code> (o subclases suyas), 
que representarán las opciones del menú. Estos <em>items</em> pueden ser etiquetas de texto, pero también
podemos utilizar imágenes para darles un aspecto más vistoso. El menú se añadirá a la escena como cualquier
otro tipo de <em>item</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">MenuItemImage</span> <span class="o">*</span><span class="n">item1</span> <span class="o">=</span> <span class="n">MenuItemImage</span><span class="o">::</span><span class="n">create</span><span class="p">(</span>
      <span class="s">&quot;nuevo_juego.png&quot;</span><span class="p">,</span> <span class="s">&quot;nuevo_juego_selected.png&quot;</span><span class="p">,</span> <span class="n">CC_CALLBACK_1</span><span class="p">(</span><span class="n">MenuPrincipal</span><span class="o">::</span><span class="n">menuNuevoJuegoCallback</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>

<span class="n">MenuItemImage</span> <span class="o">*</span><span class="n">item2</span> <span class="o">=</span> <span class="n">MenuItemImage</span><span class="o">::</span><span class="n">create</span><span class="p">(</span>
      <span class="s">&quot;continuar.png&quot;</span><span class="p">,</span> <span class="s">&quot;continuar_selected.png&quot;</span><span class="p">,</span> <span class="n">CC_CALLBACK_1</span><span class="p">(</span><span class="n">MenuPrincipal</span><span class="o">::</span><span class="n">menuContinuarCallback</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>

<span class="n">MenuItemImage</span> <span class="o">*</span><span class="n">item3</span> <span class="o">=</span> <span class="n">MenuItemImage</span><span class="o">::</span><span class="n">create</span><span class="p">(</span>
      <span class="s">&quot;opciones.png&quot;</span><span class="p">,</span> <span class="s">&quot;opciones_selected.png&quot;</span><span class="p">,</span> <span class="n">CC_CALLBACK_1</span><span class="p">(</span><span class="n">MenuPrincipal</span><span class="o">::</span><span class="n">menuOpcionesCallback</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>

<span class="n">Menu</span><span class="o">*</span> <span class="n">menu</span> <span class="o">=</span> <span class="n">Menu</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">,</span> <span class="n">item3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">menu</span><span class="o">-&gt;</span><span class="n">alignItemsVertically</span><span class="p">();</span>    

<span class="k">this</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">menu</span><span class="p">);</span>  
</pre></div>
</td></tr></table>

<p>Vemos que para cada <em>item</em> del menú añadimos dos imágenes. Una para su estado normal, y otra
para cuando esté pulsado. También propocionamos la acción a realizar cuando se pulse sobre cada opción,
mediante un par <em>target-selector</em>: el <em>target</em> es el objeto sobre el que se 
va a llamar a la acción (normalmente nuestro propio objeto <code>this</code>), y el <em>selector</em> es la forma de indicar
el método al que se va a invocar. Los métodos indicados como <em>selectores</em> de tipo menú
deberán tener la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">MenuPrincipal</span><span class="o">::</span><span class="n">menuNuevoJuegoCallback</span><span class="p">(</span><span class="n">Ref</span><span class="o">*</span> <span class="n">pSender</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">replaceScene</span><span class="p">(</span><span class="n">Game</span><span class="o">::</span><span class="n">scene</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Una vez creadas las opciones, construirmos un menú a partir de ellas,
organizamos los <em>items</em> (podemos disponerlos en vertical de forma automática como vemos en el ejemplo), y
añadimos el menú a la escena.</p>
<h2 id="sprites">Sprites<a class="headerlink" href="#sprites" title="Permanent link">&para;</a></h2>
<p>Podemos crear un <em>sprite</em> en Cocos2D con la clase <code>Sprite</code> a partir de la textura de dicho <em>sprite</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Sprite</span> <span class="o">*</span><span class="n">sprite</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;personaje.png&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>El <em>sprite</em> podrá ser añadido a la escena como cualquier otro nodo, añadiéndolo
como hijo de alguna de las capas con <code>addChild:</code>.</p>
<h3 id="posicion">Posición<a class="headerlink" href="#posicion" title="Permanent link">&para;</a></h3>
<p>Al igual que cualquier nodo, un <em>sprite</em> tiene una posición en pantalla
representada por su propiedad <code>position</code>, de tipo <code>Vec2</code> (también podemos utilizar como tipo <code>Point</code>, ya que es un alias de <code>Vec2</code>). </p>
<p>Por ejemplo, para posicionar un <em>sprite</em> en unas determinadas coordenadas
le asignaremos un valor a su propiedad <code>position</code> (esto es aplicable a 
cualquier nodo):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">sprite</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">160</span><span class="p">));</span>
</pre></div>
</td></tr></table>

<p>La posición indicada corresponde al punto central del <em>sprite</em>, aunque 
podríamos modificar esto con la propiedad <code>anchorPoint</code>, de forma similar
a las capas de CoreAnimation. El sistema de coordenadas de Cocos2D es el mismo que el
de CoreGraphics, el origen de coordenadas se encuentra en la esquina inferior 
izquierda, y las <em>y</em> son positivas hacia arriba.</p>
<p>Podemos aplicar otras transformaciones al <em>sprite</em>, como rotaciones 
(<code>rotation</code>), escalados (<code>scale</code>, <code>scaleX</code>, <code>scaleY</code>), o desencajados
(<code>skewX</code>, <code>skewY</code>). También podemos especificar su orden Z (<code>zOrder</code>). 
Recordamos que todas estas propiedades no son exclusivas de los <em>sprites</em>, sino que son
aplicables a cualquier nodo, aunque tienen un especial interés en el caso de los <em>sprites</em>.</p>
<h3 id="fotogramas">Fotogramas<a class="headerlink" href="#fotogramas" title="Permanent link">&para;</a></h3>
<p>Estos objetos pueden estar animados. Para ello deberemos definir los distintos 
  fotogramas (o <em>frames</em>) de la animación. Podemos definir varias 
  animaciones para cada <em>sprite</em>, según las acciones que pueda hacer. 
  Por ejemplo, si tenemos un personaje podemos tener una animación para 
  andar hacia la derecha y otra para andar hacia la izquierda.
El <em>sprite</em> tendrá un determinado tamaño (ancho y alto), 
  y cada fotograma será una imagen de este tamaño.</p>
<p>Cambiando el fotograma que se muestra del <em>sprite</em> en cada momento podremos 
  animarlo. Para ello deberemos tener imágenes para los distintos fotogramas del <em>sprite</em>.
  Sin embargo, como hemos comentado anteriormente, la memoria de vídeo es un recurso crítico, y 
  debemos aprovechar al máximo el espacio de las texturas que se almacenan en ella. Recordemos
  que el tamaño de las texturas en memoria debe ser potencia de 2. Además, conviene evitar
  empaquetar con la aplicación un gran número de imágenes, ya que esto hará que el espacio
  que ocupan sea mayor, y que la carga de las mismas resulte más costosa.</p>
<p>Para almacenar los fotogramas de los <em>sprites</em> de forma óptima, utilizamos lo que se conoce como
<em>sprite sheets</em>. Se trata de imágenes en las que incluyen de forma conjunta todos los fotogramas
de los <em>sprites</em>, dispuestos en forma de mosaico.</p>
<p><img alt="Mosaico con los frames de un sprite" src="imagenes/juegos/sprite.gif" /></p>
<p>Podemos crear estos <em>sprite sheets</em> de forma manual, aunque encontramos herramientas que nos
facilitarán enórmemente este trabajo, como <a href="http://www.texturepacker.com"><strong>TexturePacker</strong></a>, <a href="https://renderhjs.net/shoebox/"><strong>Shoebox</strong></a> o <a href="http://free-tex-packer.com"><strong>FreeTexturePacker</strong></a>.
Esta herramienta cuenta con una versión básica gratuita, y opciones adicionales de pago. Además de organizar
los <em>sprites</em> de forma óptima en el espacio de una textura OpenGL, nos permite almacenar esta textura
en diferentes formatos (RGBA8888, RGBA4444, RGB565, RGBA5551, PVRTC) y aplicar efectos de mejora como 
<em>dithering</em>. Esta herramienta permite generar los <em>sprite sheets</em> en varios formatos reconocidos por los diferentes
motores de videojuegos, como por ejemplo Cocos2D o libgdx.</p>
<p><img alt="Herramienta TexturePacker" src="imagenes/juegos/texturas_packer.jpg" /></p>
<p>Con esta herramienta simplemente tendremos que arrastrar sobre ella el conjunto de imágenes con los distintos 
fotogramas de nuestros <em>sprites</em>, y nos generará una textura optimizada para OpenGL con todos ellos 
dispuestos en forma de mosaico. Cuando almacenemos esta textura generada, normalmente se guardará un fichero
<code>.png</code> con la textura, y un fichero de datos que contendrá información sobre los distintos fotogramas
que contiene la textura, y la región que ocupa cada uno de ellos.</p>
<p>Para poder utilizar los fotogramas añadidos a la textura deberemos contar con algún mecanismo que nos permita
mostrar en pantalla de forma independiente cada región de la textura anterior (cada fotograma). En 
prácticamente todos los motores para videojuegos encontraremos mecanismos para hacer esto.</p>
<p>En el caso de Cocos2D, tenemos la clase <code>SpriteFrameCache</code> que se encarga de almacenar la
caché de fotogramas de <em>sprites</em> que queramos utilizar. Con TexturePacker habremos
obtenido un fichero <code>.plist</code> (es el formato utilizado por Cocos2D) y una imagen <code>.png</code>. 
Podremos añadir fotogramas a la caché a partir de estos dos ficheros. En el fichero <code>.plist</code> se 
incluye la información de cada fotograma (tamaño, región que ocupa en la textura, etc). Cada fotograma se 
encuentra indexado por defecto mediante el nombre de la imagen original que añadimos a TexturePacker, aunque 
podríamos editar esta información de forma manual en el <code>.plist</code>.</p>
<p>La caché de fotogramas se define como <em>singleton</em>. Podemos añadir nuevos fotogramas a este
<em>singleton</em> de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">SpriteFrameCache</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="n">addSpriteFramesWithFile</span><span class="p">(</span><span class="s">&quot;sheet.plist&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>En el caso anterior, utilizará como textura un fichero con el mismo nombre que el <code>.plist</code> pero
con extensión <code>.png</code>. También encontramos una versión del método anterior que también recibe como
parámetro la textura a utilizar, y de esta forma nos permite utilizar un fichero de textura 
con distinto nombre al <code>.plist</code>.</p>
<p>Una vez introducidos los fotogramas empaquetados por TexturePacker en la caché de Cocos2D, podemos crear 
<em>sprites</em> a partir de dicha caché con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Sprite</span> <span class="o">*</span><span class="n">sprite</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;frame01.png&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>En el caso anterior creamos un nuevo <em>sprite</em>, pero en lugar de hacerlo directamente a partir de una
imagen, debemos hacerlo a partir del nombre de un fotograma añadido a la caché de textura. No debemos confundirnos
con esto, ya que en este caso al especificar <code>"frame01.png"</code> no buscará un fichero con este nombre
en la aplicación, sino que buscará un fotograma con ese nombre en la caché de textura. El que los fotogramas
se llamen por defecto como la imagen original que añadimos a TexturePacker puede llevarnos a confusión.</p>
<p>También podemos obtener el fotograma como un objeto <code>SpriteFrame</code>. Esta clase no define un 
<em>sprite</em>, sino el fotograma almacenado en caché. Es decir, no es un nodo que podamos almacenar en la 
escena, simplemente define la región de textura correspondiente al fotograma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">SpriteFrame</span><span class="o">*</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">SpriteFrameCache</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="n">spriteFrameByName</span><span class="p">(</span><span class="s">&quot;frame01.png&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Podremos inicializar también el <em>sprite</em> a partir del fotograma anterior, en lugar de hacerlo directamente
a partir del nombre del fotograma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Sprite</span> <span class="o">*</span><span class="n">sprite</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrame</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<h3 id="animacion">Animación<a class="headerlink" href="#animacion" title="Permanent link">&para;</a></h3>
<p>Podremos definir determinadas secuencias de <em>frames</em> para crear animaciones. Las animaciones se
representan mediante la clase <code>Animation</code>, y se pueden crear a partir de la secuencia de
fotogramas que las definen. Los fotogramas deberán indicarse mediante objetos de la clase 
<code>SpriteFrame</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Animation</span> <span class="o">*</span><span class="n">animAndar</span> <span class="o">=</span> <span class="n">Animation</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
<span class="n">animAndar</span><span class="o">-&gt;</span><span class="n">addSpriteFrame</span><span class="p">(</span><span class="n">SpriteFrameCache</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="n">spriteFrameByName</span><span class="p">(</span><span class="s">&quot;frame01.png&quot;</span><span class="p">));</span>
<span class="n">animAndar</span><span class="o">-&gt;</span><span class="n">addSpriteFrame</span><span class="p">(</span><span class="n">SpriteFrameCache</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="n">spriteFrameByName</span><span class="p">(</span><span class="s">&quot;frame02.png&quot;</span><span class="p">));</span>
</pre></div>
</td></tr></table>

<p>Podemos ver que los fotogramas se pueden obtener de la caché de fotogramas definida anteriormente. Además
de proporcionar una lista de fotogramas a la animación, deberemos proporcionar su periodicidad, es decir, el
tiempo en segundos que tarda en cambiar al siguiente fotograma. Esto se hará mediante la propiedad
<code>delayPerUnit</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">animAndar</span><span class="o">-&gt;</span><span class="n">setDelayPerUnit</span><span class="p">(</span><span class="mf">0.25</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Una vez definida la animación, podemos añadirla a una caché de animaciones que, al igual que la caché
de texturas, también se define como <em>singleton</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">AnimationCache</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="n">addAnimation</span><span class="p">(</span><span class="n">animAndar</span><span class="p">,</span> <span class="s">&quot;animAndar&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>La animación se identifica mediante la cadena que proporcionamos como parámetro
<code>name</code>. Podemos cambiar el fotograma que muestra actualmente un <em>sprite</em> con su método:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">sprite</span><span class="o">-&gt;</span><span class="n">setDisplayFrameWithAnimationName</span><span class="p">(</span><span class="s">&quot;animAndar&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Con esto buscará en la caché de animaciones la animación especificada, y mostrará de ella
el fotograma cuyo índice proporcionemos. Más adelante cuando estudiemos el motor del juego veremos cómo 
reproducir animaciones de forma automática.</p>
<h3 id="sprite-batch"><em>Sprite batch</em><a class="headerlink" href="#sprite-batch" title="Permanent link">&para;</a></h3>
<p>En OpenGL los <em>sprites</em> se dibujan realmente en un contexto 3D. Es decir, son texturas que se 
mapean sobre polígonos 3D (concretamente con una geometría rectángular). Muchas veces encontramos en
pantalla varios <em>sprites</em> que utilizan la misma textura (o distintas regiones de la misma textura,
como hemos visto en el caso de los <em>sprite sheets</em>). Podemos optimizar el dibujado de estos <em>sprites</em> 
generando la geometría de todos ellos de forma conjunta en una única operación con la GPU. Esto será
posible sólo cuando el conjunto de <em>sprites</em> a dibujar estén contenidos en una misma textura. </p>
<p>Podemos crear un <em>batch</em> de <em>sprites</em> con Cocos2D utilizando la clase </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">SpriteBatchNode</span> <span class="o">*</span><span class="n">spriteBatch</span> <span class="o">=</span> 
    <span class="n">SpriteBatchNode</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;sheet.png&quot;</span><span class="p">);</span>
<span class="k">this</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">spriteBatch</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>El <em>sprite batch</em> es un tipo de nodo más que podemos añadir a nuestra capa como hemos visto, 
pero por si sólo no genera ningún contenido. Deberemos añadir como hijos los <em>sprites</em> que queremos 
que dibuje. Es imprescindible que los hijos sean de tipo <code>Sprite</code> (o subclases de ésta), y
que tengan como textura la misma textura que hemos utilizado al crear el <em>batch</em> (o regiones de 
la misma). No podremos añadir <em>sprites</em> con ninguna otra textura dentro de este <em>batch</em>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Sprite</span> <span class="o">*</span><span class="n">sprite1</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;frame01.png&quot;</span><span class="p">);</span>
<span class="n">sprite1</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">20</span><span class="p">));</span>
<span class="n">Sprite</span> <span class="o">*</span><span class="n">sprite2</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">::</span><span class="n">createWithSpriteFrameName</span><span class="p">(</span><span class="s">&quot;frame01.png&quot;</span><span class="p">);</span>
<span class="n">sprite2</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span><span class="mi">20</span><span class="p">));</span>

<span class="n">spriteBatch</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">sprite1</span><span class="p">);</span>
<span class="n">spriteBatch</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">sprite2</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>En el ejemplo anterior consideramos que el <em>frame</em> con nombre <code>"frame01.png"</code>
es un fotograma que se cargó en la caché de fotogramas a partir de la textura <code>sheet.png</code>.
De no pertenecer a dicha textura no podría cargarse dentro del <em>batch</em>.</p>
<h3 id="colisiones">Colisiones<a class="headerlink" href="#colisiones" title="Permanent link">&para;</a></h3>
<p>Otro aspecto de los <em>sprites</em> es la interacción entre ellos. 
  Nos interesará saber cuándo somos tocados por un enemigo o una bala para 
  disminuir la vida, o cuándo alcanzamos nosotros a nuestro enemigo. Para ello 
  deberemos detectar las colisiones entre <em>sprites</em>. La colisión 
  con <em>sprites</em> de formas complejas puede resultar costosa de calcular. 
  Por ello se suele realizar el cálculo de colisiones con una forma aproximada 
  de los <em>sprites</em> con la que esta operación resulte más 
  sencilla. Para ello solemos utilizar el <em>bounding box</em>, es decir, un 
  rectángulo que englobe el <em>sprite</em>. La intersección de 
  rectángulos es una operación muy sencilla. </p>
<p>La clase <code>Sprite</code> contiene un método <code>getBoundingBox</code> que
nos devuelve un objeto <code>Rect</code> que representa la caja en la que el
<em>sprite</em> está contenido. Con la función <code>intersectsRect</code> podemos
comprobar de forma sencilla y eficiente si dos rectángulos colisionan:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Rect</span> <span class="n">bbPersonaje</span> <span class="o">=</span> <span class="n">spritePersonaje</span><span class="o">-&gt;</span><span class="n">getBoundingBox</span><span class="p">();</span>
<span class="n">Rect</span> <span class="n">bbEnemigo</span> <span class="o">=</span> <span class="n">spriteEnemigo</span><span class="o">-&gt;</span><span class="n">getBoundingBox</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="n">bbPersonaje</span><span class="p">.</span><span class="n">intersectsRect</span><span class="p">(</span><span class="n">bbEnemigo</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Game over</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h2 id="motor-del-juego">Motor del juego<a class="headerlink" href="#motor-del-juego" title="Permanent link">&para;</a></h2>
<p>El componente básico del motor de un videojuego es lo que se conoce como ciclo del juego
(<em>game loop</em>). Vamos a ver a continuación en qué consiste este ciclo. </p>
<h3 id="ciclo-del-juego">Ciclo del juego<a class="headerlink" href="#ciclo-del-juego" title="Permanent link">&para;</a></h3>
<p>Se trata de un bucle infinito en el que tendremos el código 
  que implementa el funcionamiento del juego. Dentro de este bucle se efectúan 
  las siguientes tareas básicas:</p>
<ul>
<li>
<p><strong>Leer la entrada</strong>: Lee la entrada del usuario para conocer 
    si el usuario ha pulsado alguna tecla desde la última iteración.</p>
</li>
<li>
<p><strong>Actualizar escena</strong>: Actualiza las posiciones de los <em>sprites</em> 
    y su fotograma actual, en caso de que estén siendo animados, la posición 
    del fondo si se haya producido <em>scroll</em>, y cualquier otro elemento 
    del juego que deba cambiar. Para hacer esta actualización se pueden 
    tomar diferentes criterios. Podemos mover el personaje según la entrada 
    del usuario, la de los enemigos según su inteligencia artificial, o 
    según las interacciones producidas entre ellos y cualquier otro objeto 
    (por ejemplo al ser alcanzados por un disparo, colisionando el <em>sprite</em> 
    del disparo con el del enemigo), etc.</p>
</li>
<li>
<p><strong>Redibujar</strong>: Tras actualizar todos los elementos del juego, 
    deberemos redibujar la pantalla para mostrar la escena tal como ha quedado 
    en el instante actual. </p>
</li>
<li>
<p><strong>Dormir</strong>: Normalmente tras cada iteración dormiremos 
    un determinado número de milisegundos para controlar la velocidad a 
    la que se desarrolla el juego. De esta forma podemos establecer a cuantos 
    fotogramas por segundo (<em>fps</em>) queremos que funcione el juego, siempre 
    que la CPU sea capaz de funcionar a esta velocidad.</p>
</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">leeEntrada</span><span class="p">();</span>
    <span class="n">actualizaEscena</span><span class="p">();</span>
    <span class="n">dibujaGraficos</span><span class="p">();</span>   
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Este ciclo no siempre deberá comportarse siempre de la misma forma. 
  El juego podrá pasar por distintos estados, y en cada uno de ellos deberán 
  el comportamiento y los gráficos a mostrar serán distintos (por ejemplo, las pantallas
  de menú, selección de nivel, juego, <em>game over</em>, etc).
Podemos modelar esto como una máquina de estados, en la que en cada 
  momento, según el estado actual, se realicen unas funciones u otras, 
  y cuando suceda un determinado evento, se pasará a otro estado.</p>
<h3 id="actualizacion-de-la-escena">Actualización de la escena<a class="headerlink" href="#actualizacion-de-la-escena" title="Permanent link">&para;</a></h3>
<p>En Cocos2D no deberemos preocuparnos de implementar el ciclo del juego, ya que de esto
se encarga el <em>singleton</em> <code>Director</code>. Los estados del juego se
controlan mediante las escenas (<code>Scene</code>). En un momento dado, el ciclo de
juego sólo actualizará y mostrará los gráficos de la escena actual. Dicha escena dibujará
los gráficos a partir de los nodos que hayamos añadido a ella como hijos.</p>
<p>Ahora nos queda ver cómo actualizar dicha escena en cada iteración del ciclo del juego, 
por ejemplo, para ir actualizando la posición de cada personaje, o comprobar si existen
colisiones entre diferentes <em>sprites</em>. La escena tiene un método 
<code>schedule</code> que permite especificar un método al que
se llamará en cada iteración del ciclo. De esa forma, podremos especificar en dicho método la forma de actualizar la escena:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">scene</span><span class="o">-&gt;</span><span class="n">schedule</span><span class="p">(</span><span class="n">CC_SCHEDULE_SELECTOR</span><span class="p">(</span><span class="n">Game</span><span class="o">::</span><span class="n">update</span><span class="p">));</span>
</pre></div>
</td></tr></table>

<p>Tendremos que definir un método <code>update</code> donde introduciremos el código
que se encargará de actualizar la escena. Como parámetro recibe el tiempo transcurrido desde
la anterior actualización (desde la anterior iteración del ciclo del juego). Deberemos aprovechar
este dato para actualizar los movimientos a partir de él, y así conseguir un movimiento fluido
y constante:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">update</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_sprite</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">_sprite</span><span class="o">-&gt;</span><span class="n">getPosition</span><span class="p">()</span> <span class="o">+</span> <span class="n">Vec2</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En este caso estamos moviendo el <em>sprite</em> en <em>x</em> a una velocidad de 100 pixeles por
segundo (el tiempo transcurrido se proporciona en segundos). </p>
<blockquote>
<p>Es importante remarcar que tanto el dibujado como las actualizaciones sólo se 
llevarán a cabo cuando la escena en la que están sea la escena que está ejecutando actualmente
el <code>Director</code>. Así es como se controla el estado del juego.</p>
</blockquote>
<p>Existe otra versión del método <code>schedule</code> que nos permite proporcionar el método a llamar mediante una función lambda. En este caso deberemos indicar también un identificador para nuestra función, para así poder cancelar su planificación:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">scene</span><span class="o">-&gt;</span><span class="n">schedule</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>        
<span class="p">},</span> <span class="s">&quot;ia&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>A esta planificación le hemos dado el identificador <code>"ia"</code>. Podremos cancelarla llamando a <code>unschedule("ia")</code>. </p>
<p>Si no queremos tener que especificar la función de forma <em>inline</em>, también podemos especificarla de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">scene</span><span class="o">-&gt;</span><span class="n">schedule</span><span class="p">(</span><span class="n">CC_CALLBACK_1</span><span class="p">(</span><span class="n">Game</span><span class="o">::</span><span class="n">update</span><span class="p">,</span> <span class="k">this</span><span class="p">),</span> <span class="s">&quot;ia&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<h3 id="acciones">Acciones<a class="headerlink" href="#acciones" title="Permanent link">&para;</a></h3>
<p>En el punto anterior hemos visto cómo actualizar la escena de forma manual como se hace habitualmente
en el ciclo del juego. Sin embargo, con Cocos2D tenemos formas más sencillas de animar los nodos de 
la escena, son lo que se conoce como <strong>acciones</strong>. Estas acciones nos permiten definir
determinados comportamientos, como trasladarse a un determinado punto, y aplicarlos sobre un nodo
para que realice dicha acción de forma automática, sin tener que actualizar su posición manualmente
en cada iteración (<em>tick</em>) del juego.</p>
<p>Todas las acciones derivan de la clase <code>Action</code>. Encontramos acciones instantáneas 
(como por ejemplo situar un <em>sprite</em> en una posición determinada), o acciones con una duración
(mover al <em>sprite</em> hasta la posición destino gradualmente).</p>
<p>Por ejemplo, para mover un nodo a la posición <em>(200, 50)</em> en 3 segundos, podemos definir una 
acción como la siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">MoveTo</span> <span class="o">*</span><span class="n">actionMoveTo</span> <span class="o">=</span> <span class="n">MoveTo</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Vec2</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">50</span><span class="p">));</span>
</pre></div>
</td></tr></table>

<p>Para ejecutarla, deberemos aplicarla sobre el nodo que queremos mover:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">sprite</span><span class="o">-&gt;</span><span class="n">runAction</span><span class="p">(</span><span class="n">actionMoveTo</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Podemos ejecutar varias acciones de forma simultánea sobre un mismo nodo. Si queremos detener todas
las acciónes que pudiera haber en marcha hasta el momento, podremos hacerlo con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">sprite</span><span class="o">-&gt;</span><span class="n">stopAllActions</span><span class="p">();</span>
</pre></div>
</td></tr></table>

<p>Además, tenemos la posibilidad de encadenar varias acciones mediante el tipo especial de acción
<code>Sequence</code>. En el siguiente ejemplo primero situamos el <em>sprite</em> de forma
inmediata en <em>(0, 50)</em>, y después lo movermos a <em>(200, 50)</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Place</span> <span class="o">*</span><span class="n">actionPlace</span> <span class="o">=</span> <span class="n">Place</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">));</span>
<span class="n">MoveTo</span> <span class="o">*</span><span class="n">actionMoveTo</span> <span class="o">=</span> <span class="n">MoveTo</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Vec2</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">50</span><span class="p">));</span>

<span class="n">Sequence</span> <span class="o">*</span><span class="n">actionSequence</span> <span class="o">=</span> 
    <span class="n">Sequence</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">actionPlace</span><span class="p">,</span> <span class="n">actionMoveTo</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="n">sprite</span><span class="o">-&gt;</span><span class="n">runAction</span><span class="p">(</span><span class="n">actionSequence</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Incluso podemos hacer que una acción (o secuencia de acciones) se repita un determinado número
de veces, o de forma indefinida:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">RepeatForever</span> <span class="o">*</span><span class="n">actionRepeat</span> <span class="o">=</span> 
    <span class="n">RepeatForever</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">actionSequence</span><span class="p">);</span>
<span class="n">sprite</span><span class="o">-&gt;</span><span class="n">runAction</span><span class="p">(</span><span class="n">actionRepeat</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>De esta forma, el <em>sprite</em> estará continuamente moviéndose de <em>(0,50)</em> a <em>(200,50)</em>.
Cuando llegue a la posición final volverá a aparecer en la inicial y continuará la animación.</p>
<p>Podemos aprovechar este mecanismo de acciones para definir las animaciones de fotogramas de los
<em>sprites</em>, con una acción de tipo <code>Animate</code>. Crearemos la acción de animación
a partir de una animación de la caché de animaciones:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Animate</span> <span class="o">*</span><span class="n">animate</span> <span class="o">=</span> <span class="n">Animate</span><span class="o">::</span><span class="n">create</span><span class="p">(</span>
    <span class="n">AnimationCache</span><span class="o">::</span><span class="n">sharedAnimationCache</span><span class="p">()</span>
        <span class="o">-&gt;</span><span class="n">animationByName</span><span class="p">(</span><span class="s">&quot;animAndar&quot;</span><span class="p">));</span>

<span class="n">sprite</span><span class="o">-&gt;</span><span class="n">runAction</span><span class="p">(</span><span class="n">RepeatForever</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">animate</span><span class="p">));</span>
</pre></div>
</td></tr></table>

<p>Con esto estaremos reproduciendo continuamente la secuencia de fotogramas definida en la animación,
utilizando la periodicidad (<em>delayPerUnit</em>) que especificamos al crear dicha animación.</p>
<p>Encontramos también acciones que nos permiten realizar tareas personalizadas, proporcionando mediante una pareja
<em>target-selector</em> la función a la que queremos que se llame cuando se produzca la acción:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">CallFunc</span> <span class="o">*</span><span class="n">actionCall</span> <span class="o">=</span> 
    <span class="n">CallFunc</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">CC_CALLBACK_0</span><span class="p">(</span><span class="n">Game</span><span class="o">::</span><span class="n">accionCallback</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</pre></div>
</td></tr></table>

<p>Deberemos definir en nuestra clase el método de <em>callback</em> a llamar. En el caso del
ejemplo anterior sería:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">accionCallback</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Otra opción es pasar directamente una función <em>lambda</em> como parámetro:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">CallFunc</span><span class="o">::</span><span class="n">create</span><span class="p">([</span><span class="o">=</span><span class="p">]</span> <span class="p">{</span>
    <span class="p">...</span>            
<span class="p">});</span>
</pre></div>
</td></tr></table>

<p>También encontramos variantes de esta acción que nos permiten pasarle al <em>callback</em>
como parámetro datos propios o el nodo sobre el que se ha ejecutado la acción (<code>CallFuncN</code> recibe el nodo como parámetro, y <code>CallFundND</code> recibe el nodo y un puntero a datos genéricos). Cuanto tengamos que pasar un <em>callback</em> con parámetros utilizaremos <code>CC_CALLBACK_1</code>, <code>CC_CALLBACK_2</code> y <code>CC_CALLBACK_3</code>, para 1, 2 y 3 parámetros respectivamente.</p>
<p>Encontramos gran cantidad de acciones disponibles, que nos permitirán crear diferentes efectos (fundido, tinte,
rotación, escalado), e incluso podríamos crear nuestras propias acciones mediante subclases de <code>Action</code>.</p>
<h2 id="tilemaps"><em>Tilemaps</em><a class="headerlink" href="#tilemaps" title="Permanent link">&para;</a></h2>
<p>El motor Cocos2d-x soporta directamente los mapas creados con la herramienta <strong>Tiled</strong> (http://www.mapeditor.org). </p>
<p>Podemos leer los ficheros de tipo <code>.tmx</code> creados con esta herramienta mediante la clase <code>TMXTiledMap</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">TMXTiledMap</span> <span class="o">*</span><span class="n">fondo</span> <span class="o">=</span> <span class="n">TMXTiledMap</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;mapa.tmx&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Este objeto es un nodo (hereda de <code>Node</code>), por lo que podemos añadirlo a la escena (con <code>addChild</code>) y aplicar cualquier transformación de las vistas anterioremente.</p>
<h3 id="capas-de-patrones">Capas de patrones<a class="headerlink" href="#capas-de-patrones" title="Permanent link">&para;</a></h3>
<p>En un <em>tilemap</em> podemos tener varias capas de patrones, formadas por una matriz de <em>tiles</em>. Podemos obtener una capa a partir de su nombre con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">TMXLayer</span> <span class="o">*</span><span class="n">capa</span> <span class="o">=</span> <span class="n">fondo</span><span class="o">-&gt;</span><span class="n">layerNamed</span><span class="p">(</span><span class="s">&quot;muros&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Cada <em>tile</em> de la capa tendrá un tamaño determinado por el <em>tilemap</em> (por ejemplo, de <span><span class="MathJax_Preview">16 \times 16</span><script type="math/tex">16 \times 16</script></span> pixels), y estará ubicado en una coordenada determinada de la matriz (fila y columna), a la que nos referiremos como <em>tilecoord</em>, para no confundir con las coordenadas en píxeles de la escena. </p>
<p>Cada posición de la matriz de cada capa tendrá un número entero, que será el <em>gid</em> del <em>tile</em> que debe mostrar en dicha posición, o <code>0</code> en caso de estar vacía. Podemos obtener dicho <em>gid</em> de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Point</span> <span class="n">tileCoords</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">fila</span><span class="p">,</span><span class="n">columna</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">tileGid</span> <span class="o">=</span> <span class="n">capa</span><span class="o">-&gt;</span><span class="n">getTileGIDAt</span><span class="p">(</span><span class="n">tileCoords</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Por ejemplo, si como en el caso anterior estamos consultando la capa <code>"muros"</code>, viendo si el <em>tile</em> de cada posición está vacío o no podríamos comprobar si hay un muro en dicha posición.</p>
<p>También desde la herramienta <em>Tiled</em> se le puede dar una serie de propiedades a cada <em>tile</em> del <em>tileset</em>. Por ejemplo, podríamos crear una propiedad para indicar si los muros son colisionables o no, y leer dicha propiedad desde el código con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">tileGid</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">properties</span> <span class="o">=</span> <span class="n">fondo</span><span class="o">-&gt;</span><span class="n">getPropertiesForGID</span><span class="p">(</span><span class="n">tileGid</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">properties</span><span class="p">.</span><span class="n">isNull</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">collision</span> <span class="o">=</span>  <span class="n">properties</span><span class="p">.</span><span class="n">asValueMap</span><span class="p">()</span>
                                    <span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;colisionable&quot;</span><span class="p">)</span>
                                    <span class="p">.</span><span class="n">asBool</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">collision</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="conversion-entre-coordenadas-de-la-escena-y-tilecoords">Conversion entre coordenadas de la escena y <em>tilecoords</em><a class="headerlink" href="#conversion-entre-coordenadas-de-la-escena-y-tilecoords" title="Permanent link">&para;</a></h3>
<p>Hemos hablado anteriormente de que cada <em>tile</em> se encuentra dentro del mapa en una fila y columna (<em>tilecoord</em>), que son distintas al espacio de coordenadas de la escena. Por ello, normalmente será necesario convertir entre las coordenadas de la escena y las <em>tilecoords</em>.</p>
<p>A continuación mostramos algunos métodos auxiliares que nos pueden ser últiles para realizar esta tarea.</p>
<h4><em>Tilecoord</em> de una posición de la escena</h4>
<p>El primero de ellos nos devolverá las coordenadas de una celda a partir de las coordenadas de la escena (dividiendo entre
el tamaño de cada celda):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Point</span> <span class="n">Game</span><span class="o">::</span><span class="n">tileCoordForPosition</span><span class="p">(</span><span class="n">Vec</span> <span class="n">position</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Size</span> <span class="n">tileSize</span> <span class="o">=</span> <span class="n">_tileMap</span><span class="o">-&gt;</span><span class="n">getTileSize</span><span class="p">();</span>

    <span class="kt">float</span> <span class="n">totalHeight</span> <span class="o">=</span> <span class="n">_tileMap</span><span class="o">-&gt;</span><span class="n">getMapSize</span><span class="p">().</span><span class="n">height</span> <span class="o">*</span> 
                        <span class="n">tileSize</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">tileSize</span><span class="p">.</span><span class="n">width</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">floor</span><span class="p">((</span><span class="n">totalHeight</span> <span class="o">-</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> 
                    <span class="n">tileSize</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<blockquote>
<p>Hay que destacar que las coordenadas <em>y</em> del mapa están invertidas respecto a las de la escena. Por ese motivo es necesario calcular la altura total y hacer la resta.</p>
</blockquote>
<h4>Rectángulo que ocupa un <em>tile</em> en la escena</h4>
<p>También vamos a definir un método que nos devuelva el área (<code>Rect</code>) que ocupa en la escena un <em>tile</em> determinado:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Rect</span> <span class="n">Game</span><span class="o">::</span><span class="n">rectForTileAt</span><span class="p">(</span><span class="n">CCPoint</span> <span class="n">tileCoords</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Size</span> <span class="n">tileSize</span> <span class="o">=</span> <span class="n">_tileMap</span><span class="o">-&gt;</span><span class="n">getTileSize</span><span class="p">();</span>

    <span class="kt">float</span> <span class="n">totalHeight</span> <span class="o">=</span> <span class="n">_tileMap</span><span class="o">-&gt;</span><span class="n">getMapSize</span><span class="p">().</span><span class="n">height</span> <span class="o">*</span> 
                        <span class="n">tileSize</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
    <span class="n">Point</span> <span class="nf">origin</span><span class="p">(</span><span class="n">tileCoords</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">tileSize</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">totalHeight</span> <span class="o">-</span> 
                 <span class="p">((</span><span class="n">tileCoords</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">tileSize</span><span class="p">.</span><span class="n">height</span><span class="p">));</span>
    <span class="k">return</span> <span class="nf">Rect</span><span class="p">(</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> 
                <span class="n">tileSize</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">tileSize</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="modificacion-del-mapa">Modificación del mapa<a class="headerlink" href="#modificacion-del-mapa" title="Permanent link">&para;</a></h3>
<p>En muchos casos nos interesará tener en el mapa objetos que podamos modificar. Por ejemplo, monedas u otros <em>items</em> que podamos recolectar, u objetos que podemos destruir. Para conseguir esto podemos definir una capa con dichos objetos, de forma que cuando entremos en una celda ocupada de dicha capa, la modifiquemos para borrar o cambiar su contenido. Por ejemplo, podríamos cargar una capa con <em>"monedas"</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">TMXLayer</span> <span class="o">*</span><span class="n">monedas</span> <span class="o">=</span> <span class="n">fondo</span><span class="o">-&gt;</span><span class="n">getLayer</span><span class="p">(</span><span class="s">&quot;monedas&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>De esta capa podremos eliminar los <em>tiles</em> cuando nuestro personaje los "recoja". Para hacer esto podemos utilizar el siguiente método:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">monedas</span><span class="o">-&gt;</span><span class="n">removeTileAt</span><span class="p">(</span><span class="n">tileCoord</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>También podríamos cambiar el tipo de elemento que se muestra en una celda (por ejemplo para que al tocar una moneda cambie de color). Esto lo haremos especificando el nuevo <em>gid</em> que tendrá
la celda:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">monedas</span><span class="o">-&gt;</span><span class="n">setTileGID</span><span class="p">(</span><span class="n">GID_MONEDA_ROJA</span><span class="p">,</span> <span class="n">tileCoord</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Para cambiar o modificar los elementos recolectables primero deberemos comprobar si nuestro personaje  "colisiona" con la celda en la que se encuentran, para lo que nos podemos ayudar de los métodos definidos en el punto anterior:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Point</span> <span class="n">tileCoords</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">tileCoordForPosition</span><span class="p">(</span><span class="n">_sprite</span><span class="o">-&gt;</span><span class="n">getPosition</span><span class="p">());</span>

<span class="kt">int</span> <span class="n">tileGid</span> <span class="o">=</span> <span class="n">monedas</span><span class="o">-&gt;</span><span class="n">getTileGIDAt</span><span class="p">(</span><span class="n">tileCoords</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">tileGid</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">monedas</span><span class="o">-&gt;</span><span class="n">removeTileAt</span><span class="p">(</span><span class="n">tileCoords</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="capas-de-objetos">Capas de objetos<a class="headerlink" href="#capas-de-objetos" title="Permanent link">&para;</a></h3>
<p>Además de las capas de patrones, con <strong>Tiled</strong> podemos crear <strong>capas de objetos</strong> que contengan puntos, regiones, u otros objetos geométricos. Podremos acceder también a esta información desde Cocos2d-x.</p>
<h4>Lectura de la capa de objetos</h4>
<p>Cada capa de objetos y cada objeto es identificado mediante un nombre que le damos en Tiled. </p>
<p>Podemos acceder a una capa de objetos a partir de su nombre: </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">TMXObjectGroup</span> <span class="o">*</span><span class="n">objects</span> <span class="o">=</span> <span class="n">fondo</span><span class="o">-&gt;</span><span class="n">getObjectGroup</span><span class="p">(</span><span class="s">&quot;objetos&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Las capas de objetos están representadas en Cocos2d-x por la clase   <code>TMXObjectGroup</code>. Dentro de ella podremos acceder a cada objeto que contenga a partir de su nombre. Por ejemplo, si hemos creado
un objeto con nombre <code>inicio</code>, podremos obtenerlo de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">auto</span> <span class="n">inicio</span> <span class="o">=</span> <span class="n">objects</span><span class="o">-&gt;</span><span class="n">getObject</span><span class="p">(</span><span class="s">&quot;inicio&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>El objeto se obtiene como un diccionario. De él podemos obtener diferentes propiedades, como por ejemplo sus coordenadas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">inicio</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">).</span><span class="n">asInt</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">inicio</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">).</span><span class="n">asInt</span><span class="p">();</span>

<span class="n">_sprite</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
</pre></div>
</td></tr></table>

<p>De esta forma en el código obtenemos la posición que ocupa el objeto y podemos utilizar esta posición para el propósito para el que hubiésemos creado el objeto (por ejemplo para situar en ella inicialmente a nuestro personaje, o hacer que en ese punto aparezcan nuevos enemigos).</p>
<p>Además, a cada objeto podremos añadirle también propiedades personalizadas. Por ejemplo, si es un punto de generación (<em>spawn</em>) de enemigos, podríamos especificar cuántos enemigos saldrán y con qué frecuencia. </p>
<h4>Formas geométricas</h4>
<p>En la capa de objetos podemos incluir formas geométricas, como por ejemplo líneas o polilíneas. Esto puede ser especialmente útil para definir la geometría de colisión del escenario y posteriormente cargarla en el motor de físicas. </p>
<p>La capa de objetos geométricos se carga de forma similar a los objetos genéricos definidos por el usuario. </p>
<p>Por ejemplo, si nuestros objetos geométricos de la capa de objetos son todos ellos polilíneas, podemos cargarlos de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">TMXObjectGroup</span> <span class="o">*</span><span class="n">groupEdges</span> <span class="o">=</span> <span class="n">_tiledMap</span><span class="o">-&gt;</span><span class="n">getTiledMap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getObjectGroup</span><span class="p">(</span><span class="s">&quot;MyEdges&quot;</span><span class="p">);</span>

<span class="n">ValueVector</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">groupsEdges</span><span class="o">-&gt;</span><span class="n">getObjects</span><span class="p">();</span>

<span class="k">for</span><span class="p">(</span><span class="n">Value</span> <span class="nl">edge</span> <span class="p">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ValueVector</span> <span class="n">polyline</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="n">asValueMap</span><span class="p">()</span>
                               <span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;polylinePoints&quot;</span><span class="p">)</span>
                               <span class="p">.</span><span class="n">asValueVector</span><span class="p">();</span>

    <span class="c1">// Calculamos la coordenadas absolutas del objeto</span>
    <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="n">asValueMap</span><span class="p">().</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">).</span><span class="n">asFloat</span><span class="p">()</span> <span class="o">+</span> 
              <span class="n">_tiledMap</span><span class="o">-&gt;</span><span class="n">getTiledMap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getPositionX</span><span class="p">();</span>
    <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="n">asValueMap</span><span class="p">().</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">).</span><span class="n">asFloat</span><span class="p">()</span> <span class="o">+</span>             
              <span class="n">_tiledMap</span><span class="o">-&gt;</span><span class="n">getTiledMap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getPositionY</span><span class="p">();</span>

    <span class="k">for</span><span class="p">(</span><span class="n">Value</span> <span class="nl">point</span><span class="p">:</span> <span class="n">polyline</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">float</span> <span class="n">px</span> <span class="o">=</span> <span class="n">point</span><span class="p">.</span><span class="n">asValueMap</span><span class="p">().</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">).</span><span class="n">asFloat</span><span class="p">()</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">py</span> <span class="o">=</span> <span class="n">point</span><span class="p">.</span><span class="n">asValueMap</span><span class="p">().</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">).</span><span class="n">asFloat</span><span class="p">()</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>

        <span class="c1">// Hacemos algo con (px, py)    </span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<blockquote>
<p>Si no conocemos cómo está organizada la capa de objetos, podemos consultar el fuente XML del fichero <code>.tmx</code>. También tenemos la opción de imprimir en la consola el objeto que nos devuelve <code>getObjects</code>, y de esta forma veremos su estructura en JSON y podremos así escribir el código para leerlo.</p>
</blockquote>
<h2 id="scroll-del-escenario">Scroll del escenario<a class="headerlink" href="#scroll-del-escenario" title="Permanent link">&para;</a></h2>
<p>Cuando en el juego tenemos un mapa más extenso que el tamaño de la pantalla, tendremos que implementar <em>scroll</em> para movernos por él. Para hacer <em>scroll</em> podemos desplazar la capa principal del
juego, que contiene tanto el mapa de fondo como los <em>sprites</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">_escenario</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="n">scrollX</span><span class="p">,</span> <span class="n">scrollY</span><span class="p">));</span>
</pre></div>
</td></tr></table>

<p>En este ejemplo anterior, <code>_escenario</code> sería nuestra capa principal, que contendría el mapa de fondo y los personajes y elementos de la escena. </p>
<p>En este caso es importante resaltar que si queremos implementar un HUD (para mostrar puntuaciones, número de vidas, etc) la capa del HUD debería añadirse fuera de dicha capa, ya que de no ser así el HUD se movería con el <em>scroll</em>.</p>
<p>Normalmente el <em>scroll</em> deberá seguir la posición de nuestro personaje. Conforme movamos nuestro personaje deberemos centrar el mapa:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">centerViewport</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Size</span> <span class="n">screenSize</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getWinSize</span><span class="p">();</span>

    <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">screenSize</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">-</span> <span class="n">_sprite</span><span class="o">-&gt;</span><span class="n">getPosition</span><span class="p">().</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">screenSize</span><span class="p">.</span><span class="n">height</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">-</span> <span class="n">_sprite</span><span class="o">-&gt;</span><span class="n">getPosition</span><span class="p">().</span><span class="n">y</span><span class="p">;</span>

    <span class="n">_escenario_</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>El método anterior deberá invocarse cada vez que se cambie la posición del <em>sprite</em>. Lo que hará es desplazar todo el escenario del juego de forma que el <em>sprite</em> quede situado justo en el centro de la pantalla. </p>
<p>Podemos observar que se obtiene el tamaño de la pantalla a partir de <code>Director</code>,  y calculamos el desplazamiento <em>(x,y)</em> necesario para que el <em>sprite</em> quede situado justo en el punto central.</p>
<h3 id="limites-del-escenario">Límites del escenario<a class="headerlink" href="#limites-del-escenario" title="Permanent link">&para;</a></h3>
<p>El problema de la implementación anterior es que el escenario no es infinito, y cuando lleguemos a sus límites normalmente querremos no salirnos de ellos para no dejar en la pantalla espacio vacío. Deberemos
por lo tanto detener el <em>scroll</em> del fondo cuando hayamos llegado a su límite. Esto podemos resolverlo añadiendo algunos <code>if</code> al código anterior:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">centerViewport</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Size</span> <span class="n">screenSize</span> <span class="o">=</span> <span class="n">Director</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getWinSize</span><span class="p">();</span>
    <span class="n">Size</span> <span class="n">tileSize</span> <span class="o">=</span> <span class="n">_tileMap</span><span class="o">-&gt;</span><span class="n">getTileSize</span><span class="p">();</span>

    <span class="kt">float</span> <span class="n">offsetX</span> <span class="o">=</span>  <span class="n">screenSize</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> 
                     <span class="n">_sprite</span><span class="o">-&gt;</span><span class="n">getPosition</span><span class="p">().</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">offsetY</span> <span class="o">=</span>  <span class="n">screenSize</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> 
                     <span class="n">_sprite</span><span class="o">-&gt;</span><span class="n">getPosition</span><span class="p">().</span><span class="n">y</span><span class="p">;</span>

    <span class="c1">// Comprueba límites en la dimension x</span>
    <span class="k">if</span><span class="p">(</span><span class="n">offsetX</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">offsetX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">offsetX</span> <span class="o">&lt;</span> <span class="n">screenSize</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> 
                        <span class="n">tileSize</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> 
                        <span class="n">_tileMap</span><span class="o">-&gt;</span><span class="n">getMapSize</span><span class="p">().</span><span class="n">width</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">offsetX</span> <span class="o">=</span> <span class="n">screenSize</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> 
                  <span class="n">tileSize</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> 
                  <span class="n">_tileMap</span><span class="o">-&gt;</span><span class="n">getMapSize</span><span class="p">().</span><span class="n">width</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Comprueba límites en la dimension y</span>
    <span class="k">if</span><span class="p">(</span><span class="n">offsetY</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">offsetY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">offsetY</span> <span class="o">&lt;</span> <span class="n">screenSize</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> 
                        <span class="n">tileSize</span><span class="p">.</span><span class="n">height</span> <span class="o">*</span> 
                        <span class="n">_tileMap</span><span class="o">-&gt;</span><span class="n">getMapSize</span><span class="p">().</span><span class="n">height</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">offsetY</span> <span class="o">=</span> <span class="n">screenSize</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> 
                  <span class="n">tileSize</span><span class="p">.</span><span class="n">height</span> <span class="o">*</span> 
                  <span class="n">_tileMap</span><span class="o">-&gt;</span><span class="n">getMapSize</span><span class="p">().</span><span class="n">height</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">_escenario</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">Vec2</span><span class="p">(</span><span class="n">offsetX</span><span class="p">,</span> <span class="n">offsetY</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Con este código evitaremos que en el visor veamos zonas fuera de los límites del mapa. La posición  mínima que se mostrará será <code>0</code>, y la máxima el tamaño del mapa (se calcula como el número de celdas <code>mapSize</code> por el tamaño de cada celda <code>tileSize</code>).</p>
<p>Cuando lleguemos a estos límites nuestro personaje seguirá moviéndose, pero ya no estará centrado en la pantalla, el mapa permanecerá fijo y el personaje se moverá sobre él.</p>
<h3 id="scroll-parallax">Scroll parallax<a class="headerlink" href="#scroll-parallax" title="Permanent link">&para;</a></h3>
<p>En juegos 2D podemos crear una ilusión de profundidad creando varias capas de fondo y haciendo que las capas más lejanas se muevan a velocidad más lenta que las más cercanas al hacer <em>scroll</em>. Esto
es lo que se conoce como <em>scroll parallax</em>.</p>
<p>En Cocos2D es sencillo implementar este tipo de <em>scroll</em>, ya que contamos con el tipo de nodo <code>ParallaxNode</code> que define este comportamiento. Este nodo nos permite añadir varios hijos, y 
hacer que cada uno de ellos se desplace a una velocidad distinta.  </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">ParallaxNode</span> <span class="o">*</span><span class="n">parallax</span> <span class="o">=</span> <span class="n">ParallaxNode</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>

<span class="n">parallax</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Vec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="n">parallax</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">mountains</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Vec2</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="n">parallax</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">sky</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Vec2</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>

<span class="k">this</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="n">parallax</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Podemos añadir cualquier nodo como capa al <em>scroll parallax</em>, como por ejemplo <em>sprites</em> o <em>tilemaps</em>. Con <em>parallax ratio</em> especificamos la velocidad a la que se mueve la capa. Si ponemos un <em>ratio</em> de 1 hacemos que se mueva a la velocidad real que estemos moviendo la capa
principal de nuestra escena. Si ponemos <code>0.5</code>, se moverá a mitad de la velocidad.</p>
<h2 id="reproduccion-de-audio">Reproducción de audio<a class="headerlink" href="#reproduccion-de-audio" title="Permanent link">&para;</a></h2>
<p>En un videojuego habitualmente reproduciremos una música de fondo, normalmente de forma cíclica, y una serie de efectos de sonido (disparos, explosiones, etc). En Cocos2D-x tenemos la clase  <code>AudioEngine</code> que nos permite realizar todo esto. En primer lugar debemos importar la librería:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;audio/include/AudioEngine.h&quot;</span><span class="cp"></span>
</pre></div>
</td></tr></table>

<h3 id="musica-de-fondo">Música de fondo<a class="headerlink" href="#musica-de-fondo" title="Permanent link">&para;</a></h3>
<p>Podemos reproducir como música de fondo cualquier formato soportado por el dispositivo (MP3, M4A, etc). Para ello utilizaremos el método estático <code>play2d</code>: </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">_id_music</span> <span class="o">=</span> <span class="n">AudioEngine</span><span class="o">::</span><span class="n">play2d</span><span class="p">(</span><span class="err">“</span><span class="n">musica</span><span class="p">.</span><span class="n">mp3</span><span class="s">&quot;, true);</span>
</pre></div>
</td></tr></table>

<p>Lo habitual será reproducir la música en bucle (esto lo indicamos poniendo a <code>true</code> el segundo parámetro del método anterior), por ejemplo mientras estamos en un menú o en un nivel del juego. </p>
<p>Este método anterior nos proporciona un <em>identificador</em> del audio que ponemos a reproducir, para así poder detenerlo o modificar la forma en la que se reproduce.</p>
<p>Podemos deterner la reproducción de la música de fondo a partir de su <em>id</em> en cualquier momento con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">AudioEngine</span><span class="o">::</span><span class="n">stop</span><span class="p">(</span><span class="n">_id_music</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>También podemos detener cualquier audio que hubiese reproduciéndose:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">AudioEngine</span><span class="o">::</span><span class="n">stopAll</span><span class="p">();</span>
</pre></div>
</td></tr></table>

<p>Otra cosa que podemos hacer a partir del <em>id</em> es cambiar el volumen de la música de fondo (se debe espeficiar un valor de <code>0</code> a <code>1</code>):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">AudioEngine</span><span class="o">::</span><span class="n">setVolume</span><span class="p">(</span><span class="n">_id_music</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<h3 id="efectos-de-sonido">Efectos de sonido<a class="headerlink" href="#efectos-de-sonido" title="Permanent link">&para;</a></h3>
<p>Los efectos de sonido sonarán cuando suceda un determinado evento (disparo, explosión, pulsación de un botón), y será normalmente una reproducción de corta duración. Una característica de estos efectos es
que deben sonar de forma inmediata al suceder el evento que los produce. Causaría un mal efecto que un disparo sonase con un retardo respecto al momento en el que se produjo. Sin embargo, la reproducción
de audio normalmente suele causar un retardo, ya que implica cargar las muestras del audio del fichero y preparar los <em>bufferes</em> de memoria necesarios para su reproducción. Por ello, en un videojuego
es importante que todos estos efectos se encuentren de antemano preparados para su reproducción, para evitar estos retardos.</p>
<p>Con Cocos2d-x podremos precargar un fichero de audio de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">AudioEngine</span><span class="o">::</span><span class="n">preload</span><span class="p">(</span><span class="s">&quot;explosion.aif&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Esto deberemos hacerlo una única vez antes de comenzar el juego (un buen lugar puede ser el método <code>init</code> de nuestra escena del juego). Una vez cargados, podremos reproducirlos de forma inmediata
con <code>play2d</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">AudioEngine</span><span class="o">::</span><span class="n">play2d</span><span class="p">(</span><span class="s">&quot;explosion.aif&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Una vez no vayamos a utilizar estos efectos de sonido, deberemos liberarlos de memoria:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">AudioEngine</span><span class="o">::</span><span class="n">uncacheAll</span><span class="p">();</span>
</pre></div>
</td></tr></table>

<p>Esto se puede hacer cuando vayamos a pasar a otra escena en la que no se vayan a necesitar estos efectos.</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="scenekit.html" title="SceneKit" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Anterior
                </span>
                SceneKit
              </span>
            </div>
          </a>
        
        
          <a href="unity.html" title="Unity" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Siguiente
                </span>
                Unity
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="assets/javascripts/application.245445c6.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>