



<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copiar al portapapeles">
      
        <meta name="lang:clipboard.copied" content="Copiado al portapapeles">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No se encontraron documentos">
      
        <meta name="lang:search.result.one" content="1 documento encontrado">
      
        <meta name="lang:search.result.other" content="# documentos encontrados">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.4.0">
    
    
      
        <title>SceneKit - Videojuegos para Dispositivos Móviles</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/application.0284f74d.css">
      
        <link rel="stylesheet" href="assets/stylesheets/application-palette.01803549.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
      <script src="assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#scenekit" tabindex="1" class="md-skip">
        Saltar a contenido
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="index.html" title="Videojuegos para Dispositivos Móviles" class="md-header-nav__button md-logo">
          
            <img src="imagenes/logo.png" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              Videojuegos para Dispositivos Móviles
            </span>
            <span class="md-header-nav__topic">
              
                SceneKit
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Teclee para comenzar búsqueda
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="index.html" title="Videojuegos para Dispositivos Móviles" class="md-nav__button md-logo">
      
        <img src="imagenes/logo.png" width="48" height="48">
      
    </a>
    Videojuegos para Dispositivos Móviles
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="index.html" title="Presentación" class="md-nav__link">
      Presentación
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="videojuegos_para_moviles.html" title="Introducción a los videojuegos móviles" class="md-nav__link">
      Introducción a los videojuegos móviles
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Fundamentos de los motores
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Fundamentos de los motores
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="fundamentos-motores.html" title="Escena y nodos" class="md-nav__link">
      Escena y nodos
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="motor_de_fisicas.html" title="Físicas" class="md-nav__link">
      Físicas
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="sprites_e_interaccion.html" title="Sprites" class="md-nav__link">
      Sprites
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="escenario_y_fondos.html" title="Fondo y scroll" class="md-nav__link">
      Fondo y scroll
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    
    <label class="md-nav__link" for="nav-4">
      Motores para  móviles
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Motores para  móviles
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="spritekit.html" title="SpriteKit" class="md-nav__link">
      SpriteKit
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        SceneKit
      </label>
    
    <a href="scenekit.html" title="SceneKit" class="md-nav__link md-nav__link--active">
      SceneKit
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#creacion-de-un-proyecto-de-scenekit" title="Creación de un proyecto de SceneKit" class="md-nav__link">
    Creación de un proyecto de SceneKit
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#elementos-de-scenekit" title="Elementos de SceneKit" class="md-nav__link">
    Elementos de SceneKit
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#componentes-de-los-nodos" title="Componentes de los nodos" class="md-nav__link">
    Componentes de los nodos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geometria-de-los-nodos" title="Geometría de los nodos" class="md-nav__link">
    Geometría de los nodos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#la-escena" title="La escena" class="md-nav__link">
    La escena
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#editor-visual-de-la-escena" title="Editor visual de la escena" class="md-nav__link">
    Editor visual de la escena
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inspectores-de-la-escena" title="Inspectores de la escena" class="md-nav__link">
    Inspectores de la escena
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#carga-de-la-escena" title="Carga de la escena" class="md-nav__link">
    Carga de la escena
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#manipulacion-del-arbol-de-la-escena" title="Manipulación del árbol de la escena" class="md-nav__link">
    Manipulación del árbol de la escena
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#propiedades-de-los-nodos" title="Propiedades de los nodos" class="md-nav__link">
    Propiedades de los nodos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#luces" title="Luces" class="md-nav__link">
    Luces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#camaras" title="Cámaras" class="md-nav__link">
    Cámaras
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geometria-y-material" title="Geometría y material" class="md-nav__link">
    Geometría y material
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#renderer-de-la-escena" title="Renderer de la escena" class="md-nav__link">
    Renderer de la escena
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ciclo-de-vida-de-la-escena" title="Ciclo de vida de la escena" class="md-nav__link">
    Ciclo de vida de la escena
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fisicas" title="Físicas" class="md-nav__link">
    Físicas
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#el-mundo-fisico" title="El mundo físico" class="md-nav__link">
    El mundo físico
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#creacion-de-un-cuerpo-fisico" title="Creación de un cuerpo físico" class="md-nav__link">
    Creación de un cuerpo físico
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#forma-de-los-cuerpos-fisicos" title="Forma de los cuerpos físicos" class="md-nav__link">
    Forma de los cuerpos físicos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#propiedades-de-los-cuerpos-fisicos" title="Propiedades de los cuerpos físicos" class="md-nav__link">
    Propiedades de los cuerpos físicos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busqueda-de-cuerpos" title="Búsqueda de cuerpos" class="md-nav__link">
    Búsqueda de cuerpos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#colisiones" title="Colisiones" class="md-nav__link">
    Colisiones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#layering" title="Layering" class="md-nav__link">
    Layering
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#uniones" title="Uniones" class="md-nav__link">
    Uniones
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#acciones-y-animaciones" title="Acciones y animaciones" class="md-nav__link">
    Acciones y animaciones
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#acciones" title="Acciones" class="md-nav__link">
    Acciones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tipos-de-acciones" title="Tipos de acciones" class="md-nav__link">
    Tipos de acciones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#composicion-de-acciones" title="Composición de acciones" class="md-nav__link">
    Composición de acciones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#animaciones" title="Animaciones" class="md-nav__link">
    Animaciones
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="cocos2d-x.html" title="Cocos2d-x" class="md-nav__link">
      Cocos2d-x
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="unity.html" title="Unity" class="md-nav__link">
      Unity
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="box2d.html" title="Box2D" class="md-nav__link">
      Box2D
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="mandos.html" title="Controles del videojuego" class="md-nav__link">
      Controles del videojuego
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="adaptacion_a_moviles.html" title="Adaptación a diferentes dispositivos" class="md-nav__link">
      Adaptación a diferentes dispositivos
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="redes_sociales.html" title="Logros y marcadores" class="md-nav__link">
      Logros y marcadores
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#creacion-de-un-proyecto-de-scenekit" title="Creación de un proyecto de SceneKit" class="md-nav__link">
    Creación de un proyecto de SceneKit
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#elementos-de-scenekit" title="Elementos de SceneKit" class="md-nav__link">
    Elementos de SceneKit
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#componentes-de-los-nodos" title="Componentes de los nodos" class="md-nav__link">
    Componentes de los nodos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geometria-de-los-nodos" title="Geometría de los nodos" class="md-nav__link">
    Geometría de los nodos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#la-escena" title="La escena" class="md-nav__link">
    La escena
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#editor-visual-de-la-escena" title="Editor visual de la escena" class="md-nav__link">
    Editor visual de la escena
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inspectores-de-la-escena" title="Inspectores de la escena" class="md-nav__link">
    Inspectores de la escena
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#carga-de-la-escena" title="Carga de la escena" class="md-nav__link">
    Carga de la escena
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#manipulacion-del-arbol-de-la-escena" title="Manipulación del árbol de la escena" class="md-nav__link">
    Manipulación del árbol de la escena
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#propiedades-de-los-nodos" title="Propiedades de los nodos" class="md-nav__link">
    Propiedades de los nodos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#luces" title="Luces" class="md-nav__link">
    Luces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#camaras" title="Cámaras" class="md-nav__link">
    Cámaras
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#geometria-y-material" title="Geometría y material" class="md-nav__link">
    Geometría y material
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#renderer-de-la-escena" title="Renderer de la escena" class="md-nav__link">
    Renderer de la escena
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ciclo-de-vida-de-la-escena" title="Ciclo de vida de la escena" class="md-nav__link">
    Ciclo de vida de la escena
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fisicas" title="Físicas" class="md-nav__link">
    Físicas
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#el-mundo-fisico" title="El mundo físico" class="md-nav__link">
    El mundo físico
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#creacion-de-un-cuerpo-fisico" title="Creación de un cuerpo físico" class="md-nav__link">
    Creación de un cuerpo físico
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#forma-de-los-cuerpos-fisicos" title="Forma de los cuerpos físicos" class="md-nav__link">
    Forma de los cuerpos físicos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#propiedades-de-los-cuerpos-fisicos" title="Propiedades de los cuerpos físicos" class="md-nav__link">
    Propiedades de los cuerpos físicos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busqueda-de-cuerpos" title="Búsqueda de cuerpos" class="md-nav__link">
    Búsqueda de cuerpos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#colisiones" title="Colisiones" class="md-nav__link">
    Colisiones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#layering" title="Layering" class="md-nav__link">
    Layering
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#uniones" title="Uniones" class="md-nav__link">
    Uniones
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#acciones-y-animaciones" title="Acciones y animaciones" class="md-nav__link">
    Acciones y animaciones
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#acciones" title="Acciones" class="md-nav__link">
    Acciones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tipos-de-acciones" title="Tipos de acciones" class="md-nav__link">
    Tipos de acciones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#composicion-de-acciones" title="Composición de acciones" class="md-nav__link">
    Composición de acciones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#animaciones" title="Animaciones" class="md-nav__link">
    Animaciones
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="scenekit">SceneKit<a class="headerlink" href="#scenekit" title="Permanent link">&para;</a></h1>
<h2 id="creacion-de-un-proyecto-de-scenekit">Creación de un proyecto de SceneKit<a class="headerlink" href="#creacion-de-un-proyecto-de-scenekit" title="Permanent link">&para;</a></h2>
<p>Al igual que en el caso de SpriteKit, desde Xcode podemos crear un proyecto de tipo <em>Game</em>, y nos preguntará cuál de las librerías nativas queremos utilizar como base. </p>
<p><img alt="&quot;Creacion de un proyecto de tipo _Game_" src="imagenes/nativo/scenekit_game.png" />
<img alt="&quot;Selección de librería para videojuegos&quot;" src="imagenes/nativo/scenekit_framework.png" /></p>
<p>En este caso utilizaremos <strong>SceneKit</strong>, el <em>framework</em> nativo de alto nivel de la plataforma iOS para el desarrollo de aplicaciones basadas en gráficos 3D, destacando entre ellas el caso de los videojuegos 3D. Dentro de Xcode tendremos además <strong>un editor visual</strong> de la escena 3D. </p>
<p>La librería de clase de SceneKit es muy similar a SpriteKit, pero en este caso todas las clases tendrán el prefijo <code>SCN</code>. A continuación veremos todos los elementos de esta librería, haciendo especial hincapié en lo que la diferencia de SpriteKit.</p>
<h2 id="elementos-de-scenekit">Elementos de SceneKit<a class="headerlink" href="#elementos-de-scenekit" title="Permanent link">&para;</a></h2>
<p>En la siguiente tabla se muestran los principales elementos que encontramos dentro de la librería de SceneKit:</p>
<table>
<thead>
<tr>
<th>Clase</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SCNView</code></td>
<td>Vista de <code>UIKit</code> que podemos incluir en nuestro controlador (<code>UIViewController</code>) y que contendrá una escena de SceneKit.</td>
</tr>
<tr>
<td><code>SCNScene</code></td>
<td>Define cada pantalla (estado) del juego. Contiene un árbol de nodos, pero en este caso no es un nodo, sino que contiene un nodo raíz al que podremos añadir hijos.</td>
</tr>
<tr>
<td><code>SCNNode</code></td>
<td>Nodos que pueden formar parte del árbol de la escena de SceneKit. En este caso no tendremos distintos tipos de nodo como ocurría en SpriteKit, sino que el comportamiento y apariencia de cada nodo vendrá determinado por los componentes que le añadamos. Es decir, la personalización de los nodos no la haremos por herencia, sino mediante la agregación de componentes (luz, cámara, geometría, físicas, etc).</td>
</tr>
<tr>
<td><code>SCNAction</code></td>
<td>Acciones que podemos ejecutar sobre los nodos de la escena para por ejemplo animarlos o moverlos.</td>
</tr>
</tbody>
</table>
<h3 id="componentes-de-los-nodos">Componentes de los nodos<a class="headerlink" href="#componentes-de-los-nodos" title="Permanent link">&para;</a></h3>
<p>Como se ha comentado en el punto anterior, la forma de definir las propiedades de cada nodo es mediante la agregación de una serie de componentes a los mismos. Estos componentes se añaden a una serie de propiedades de la clase <code>SCNNode</code> que se muestran en la siguiente tabla:</p>
<table>
<thead>
<tr>
<th>Propiedad</th>
<th>Clase del componente</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>camera</code></td>
<td><code>SCNCamera</code></td>
<td>Hace que el nodo se comporte como una cámara</td>
</tr>
<tr>
<td><code>light</code></td>
<td><code>SCNLight</code></td>
<td>Hace que el nodo se comporte como una luz</td>
</tr>
<tr>
<td><code>geometry</code></td>
<td><code>CNGeometry</code></td>
<td>Hace que el nodo muestre una geometría 3D</td>
</tr>
<tr>
<td><code>physicsBody</code></td>
<td><code>SCNPhysicsBody</code></td>
<td>Hace que el nodo se someta a simulación física</td>
</tr>
<tr>
<td><code>particleSystems</code></td>
<td><code>SCNParticleSystem</code></td>
<td>Muestra un sistema de partículas (fuego, explosión, etc)</td>
</tr>
<tr>
<td><code>audioPlayers</code></td>
<td><code>SCNAudioPlayer</code></td>
<td>Reproduce audio en la posición del nodo</td>
</tr>
</tbody>
</table>
<h3 id="geometria-de-los-nodos">Geometría de los nodos<a class="headerlink" href="#geometria-de-los-nodos" title="Permanent link">&para;</a></h3>
<p>Uno de los principales componentes es el que nos permite definir la geometría del nodo, es decir, la forma con la que se renderizará y se visualizará en la escena. La geometría se especifica mediante una clase de tipo <code>SCNGeometry</code>, y podemos definirla de tres formas distintas:</p>
<ul>
<li>Utilizar alguno de los <strong>tipos básicos</strong> de geometría predefinidos (subclases de <code>SCNGeometry</code>)</li>
</ul>
<table>
<thead>
<tr>
<th>Clase</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SCNSphere</code></td>
<td>Forma de esfera</td>
</tr>
<tr>
<td><code>SCNBox</code></td>
<td>Forma de caja</td>
</tr>
<tr>
<td><code>SCNCapsule</code></td>
<td>Forma de cápsula</td>
</tr>
<tr>
<td><code>SCNText</code></td>
<td>Muestra una etiqueta de texto 3D</td>
</tr>
<tr>
<td><code>SCNShape</code></td>
<td>Forma 2D extruída</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>Crear la geometría <strong>manualmente</strong> mediante las clases <code>SCNGeometrySource</code> y <code>SCNGeometryElement</code>. Con estas clases podemos especificar los vértices y las caras de las formas geométricas a mostrar manualmente, lo cual es útil si queremos generar formas de manera dinámica, por ejemplo, para generar gráficas 3D a partir de datos que se hayan obtenido. </p>
</li>
<li>
<p>Importar la geometría de alguna <strong>herramienta de <em>authoring</em></strong> (como por ejemplo Blender o Maya). Uno de los formatos preferidos de importación es el formato <code>.dae</code>.</p>
</li>
</ul>
<h2 id="la-escena">La escena<a class="headerlink" href="#la-escena" title="Permanent link">&para;</a></h2>
<p>Para crear una escena, lo habitual será utilizar el editor visual de la escena de Xcode y posteriormente cargar dicha escena desde el código. Vamos a ver en primer lugar cómo podemos crear la escena con el editor, y posteriormente cómo cargarla y manipularla desde el código.</p>
<h3 id="editor-visual-de-la-escena">Editor visual de la escena<a class="headerlink" href="#editor-visual-de-la-escena" title="Permanent link">&para;</a></h3>
<p>El entorno Xcode integra un editor visual de la escena 3D. Dicho editor guarda la escena en formato <code>.scn</code>. </p>
<p><img alt="&quot;Editor de la escena 3D&quot;" src="imagenes/nativo/scenekit_editor.png" /></p>
<p>Podemos importar en este editor modelos en otros formatos (como por ejemplo el formato <code>.dae</code>), que podamos haber creado con otras herramientas como Blender o Autodesk Maya. </p>
<p>Se recomienda que las escenas se guarden en una carpeta <code>art.scnassets</code>, para que Xcode pueda optimizar estos ficheros al construir el proyecto.</p>
<h3 id="inspectores-de-la-escena">Inspectores de la escena<a class="headerlink" href="#inspectores-de-la-escena" title="Permanent link">&para;</a></h3>
<p>Dentro del editor, al seleccionar un elemento de la escena podremos modificar gran parte de sus propiedades utilizando los diferentes inspectores disponibles en el lateral derecho:</p>
<p><img alt="&quot;Inspectores del editor&quot;" src="imagenes/nativo/scenekit_inspectores.png" /></p>
<p>Encontramos los siguientes inspectores:</p>
<ul>
<li><strong>Nodo</strong>: Propiedades generales del nodo seleccionado, independientemente de los componentes que incluya. Por ejemplo, su posición, rotación y escala en la escena, o su nombre. El nombre (<code>name</code>) es una propiedad importante, ya que nos permitirá hacer referencia a los nodos desde el código.</li>
<li><strong>Atributos</strong>: Propiedades de los componentes incluidos en el nodo seleccionado. Variará dependiendo de qué componentes incluya (por ejemplo, podrá mostrar las propiedades de la cámara, de una luz, o de la geometría de un nodo, en caso de incluir alguno de estos componentes).</li>
<li><strong>Material</strong>: Propiedades del material con el que se renderizará el nodo. Por ejemplo, podremos indicar el color o la textura, y si el objeto presentará brillos o si será mate. </li>
<li><strong>Física</strong>: Nos permite establecer las propiedades físicas de los nodos, para que sean gestionados por el motor de físicas de SceneKit (tipo de cuerpo, forma, y otras propiedades físicas).</li>
<li><strong>Escena</strong>: Propiedades generales de la escena. Son independientes del nodo seleccionado. Nos permite por ejemplo poner una imagen o color de fondo, o un <em>skybox</em>. </li>
</ul>
<p>Si queremos cambiar las propiedades anteriores en un fichero importado desde otra herramienta, SceneKit lo transformará previamente al formato <code>.scn</code>. </p>
<h3 id="carga-de-la-escena">Carga de la escena<a class="headerlink" href="#carga-de-la-escena" title="Permanent link">&para;</a></h3>
<p>Una vez definida la escena de forma visual, podemos cargarla desde el código de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kr">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="kc">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>

    <span class="kd">let</span> <span class="nv">scene</span> <span class="p">=</span> <span class="bp">SCNScene</span><span class="p">(</span><span class="n">named</span><span class="p">:</span> <span class="s">&quot;art.scnassets/miescena.scn&quot;</span><span class="p">)</span><span class="o">!</span>      

    <span class="kd">let</span> <span class="nv">scnView</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">view</span> <span class="k">as</span><span class="p">!</span> <span class="bp">SCNView</span>        
    <span class="n">scnView</span><span class="p">.</span><span class="n">scene</span> <span class="p">=</span> <span class="n">scene</span>    
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En el ejemplo anterior cargamos la escena y la asignamos como escena activa en la vista <code>SCNView</code>. Esta vista actuará como <em>renderer</em> de la escena, como veremos más adelante, siendo la encargada de dibujar su contenido en pantalla. Podemos cambiar en ella una serie de propiedades, por ejemplo para poner un color de fondo, permitir girar la cámara mediante gestos de <em>arrastrar</em>, o mostrar estadísticas de rendimiento del motor:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">scnView</span><span class="p">.</span><span class="n">allowsCameraControl</span> <span class="p">=</span> <span class="kc">false</span>        
<span class="n">scnView</span><span class="p">.</span><span class="n">showsStatistics</span> <span class="p">=</span> <span class="kc">true</span>        
<span class="n">scnView</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">.</span><span class="n">black</span>        
</pre></div>
</td></tr></table>

<h3 id="manipulacion-del-arbol-de-la-escena">Manipulación del árbol de la escena<a class="headerlink" href="#manipulacion-del-arbol-de-la-escena" title="Permanent link">&para;</a></h3>
<p>Una vez cargada la escena, vamos a ver cómo podríamos obtener y manipular su contenido desde código. Como se ha comentado, la escena contiene un árbol de nodos. Contamos con la propiedad <code>rootNode</code> que representa el nodo raíz de dicho árbol, y a partir del cual podremos buscar nodos o añadir nuevos nodos. </p>
<p>Una de las primeras cosas que haremos será obtener los nodos que hayamos creado de forma visual en el editor de la escena. Para ello, podemos hacer desde el nodo raíz una búsqueda a partir de su nombre con <code>childNode(withName:, recursively:)</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">nave</span> <span class="p">=</span> <span class="n">scene</span><span class="p">.</span><span class="n">rootNode</span><span class="p">.</span><span class="n">childNode</span><span class="p">(</span><span class="n">withName</span><span class="p">:</span> <span class="s">&quot;ship&quot;</span><span class="p">,</span> <span class="n">recursively</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span><span class="o">!</span>
</pre></div>
</td></tr></table>

<p>Podríamos también crear un nuevo nodo y añadirlo a la escena con <code>addChildNode(_:)</code>. Deberemos añadirlo como hijo al nodo que queremos que sea su padre. Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">escudo</span> <span class="p">=</span> <span class="bp">SCNNode</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">asteroide</span> <span class="p">=</span> <span class="bp">SCNNode</span><span class="p">()</span>

<span class="n">scene</span><span class="p">.</span><span class="n">rootNode</span><span class="p">.</span><span class="n">addChildNode</span><span class="p">(</span><span class="n">asteroide</span><span class="p">)</span>
<span class="n">nave</span><span class="p">.</span><span class="n">addChildNode</span><span class="p">(</span><span class="n">escudo</span><span class="p">)</span>
<span class="p">````</span>

<span class="n">En</span> <span class="n">este</span> <span class="n">ejemplo</span><span class="p">,</span> <span class="n">añadimos</span> <span class="n">un</span> <span class="n">_asteroide_</span> <span class="n">al</span> <span class="n">nodo</span> <span class="n">raíz</span> <span class="n">de</span> <span class="n">la</span> <span class="n">escena</span><span class="p">,</span> <span class="n">para</span> <span class="n">que</span> <span class="n">sea</span> <span class="n">independiente</span> <span class="n">de</span> <span class="n">la</span> <span class="n">_nave_</span><span class="p">,</span> <span class="n">pero</span> <span class="n">añadimos</span> <span class="n">un</span> <span class="n">_escudo_</span> <span class="n">como</span> <span class="n">hijo</span> <span class="n">de</span> <span class="n">la</span> <span class="n">_nave_</span> <span class="n">para</span> <span class="n">que</span> <span class="n">forme</span> <span class="n">parte</span> <span class="n">del</span> <span class="n">mismo</span> <span class="n">bloque</span><span class="p">.</span>

<span class="n">Si</span> <span class="n">queremos</span> <span class="n">eliminar</span> <span class="n">un</span> <span class="n">nodo</span><span class="p">,</span> <span class="n">simplemente</span> <span class="n">deberemos</span> <span class="n">eliminarlo</span> <span class="n">de</span> <span class="n">su</span> <span class="n">padre</span><span class="p">.</span> <span class="n">Por</span> <span class="n">ejemplo</span><span class="p">,</span> <span class="n">si</span> <span class="n">destruimos</span> <span class="n">el</span> <span class="n">asteroide</span> <span class="n">podemos</span> <span class="n">eliminarlo</span> <span class="n">con</span> <span class="p">`</span><span class="n">removeFromParentNode</span><span class="p">()`:</span>

<span class="p">```</span><span class="n">swift</span>
<span class="n">asteroide</span><span class="p">.</span><span class="n">removeFromParentNode</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>No hace falta especificar quién es su padre. Además, contaremos también con métodos adicionales, por ejemplo para listar todos los hijos de un nodo.</p>
<h2 id="propiedades-de-los-nodos">Propiedades de los nodos<a class="headerlink" href="#propiedades-de-los-nodos" title="Permanent link">&para;</a></h2>
<p>Todos los nodos tienen una serie de propiedades comunes, especialmente para su posicionamiento en la escena, tal como se muestra en la siguiente tabla:</p>
<table>
<thead>
<tr>
<th>Propiedad</th>
<th>Tipo</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td><code>String</code></td>
<td>Nombre que nos permite identificar al nodo y buscarlo en la escena.</td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>SCNMatrix4</code></td>
<td>Combina traslación, rotación y escala en una única matriz de transformación <code>4x4</code>.</td>
</tr>
<tr>
<td><code>position</code></td>
<td><code>SCNVector3</code></td>
<td>Posición del objeto en la escena (coordenadas <code>x</code>, <code>y</code>, <code>z</code>).</td>
</tr>
<tr>
<td><code>rotation</code></td>
<td><code>SCNVector4</code></td>
<td>La rotación es especifica mediante un vector de 4 componentes, que incluye: un eje (x, y, z) y un ángulo de rotación alrededor de dicho eje.</td>
</tr>
<tr>
<td><code>eulerAngles</code></td>
<td><code>SCNVector3</code></td>
<td>La rotación se establece mediante 3 componentes: rotación alrededor de <code>x</code>, de <code>y</code>, y de <code>z</code>.</td>
</tr>
<tr>
<td><code>scale</code></td>
<td><code>SCNVector3</code></td>
<td>Escala del objeto en las 3 dimensiones (<code>x</code>, <code>y</code>, <code>z</code>).</td>
</tr>
<tr>
<td><code>isHidden</code></td>
<td><code>Bool</code></td>
<td>Permite ocultar el objeto (no se renderizará)</td>
</tr>
<tr>
<td><code>opacity</code></td>
<td><code>CGFloat</code></td>
<td>Permite añadir un grado de transparencia al objeto.</td>
</tr>
</tbody>
</table>
<p>Una de las operaciones más habituales será modificar la posición de un nodo. Esto podremos hacerlo con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">nave</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="bp">SCNVector3</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Además, podremos también cambiar las propiedades de los componentes que incorporan los nodos.</p>
<h3 id="luces">Luces<a class="headerlink" href="#luces" title="Permanent link">&para;</a></h3>
<p>Podemos añadir un componente de tipo luz a un nodo con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">lightNode</span> <span class="p">=</span> <span class="bp">SCNNode</span><span class="p">()</span>
<span class="n">lightNode</span><span class="p">.</span><span class="n">light</span> <span class="p">=</span> <span class="bp">SCNLight</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>La principal propiedad de este componente es el <strong>tipo de luz</strong>. En función del tipo, tendremos otras propiedades para configurar la fuente de luz. Encontramos los siguientes tipos:</p>
<ul>
<li><em>Ambiente</em>: Luz que afecta por igual a todos los objetos en todas sus caras. Simula la luz general que hay en el ambiente, debida a la reflexión de la luz en todos los objetos de la estancia. Normalmente se da una luz ambiente como un valor mínimo para que ninguna zona esté totalmente oscura.</li>
<li><em>Área</em>: Similar a la anterior, pero en lugar de afectar a toda la escena se aplica sólo a una determinada área de la misma.</li>
<li><em>Direccional</em>: La luz incide en todos los objetos en una misma dirección. Por ejemplo, nos permitiría simular la luz del sol (una fuente de luz que se encuentra a distancia infinita). </li>
<li><em>Omnidireccional</em>: Se trata de un punto que emite luz en todas las direcciones. Por ejemplo útil para simular una bombilla.</li>
<li><em>Foco</em>: Un foco emite un haz de luz cónico, como por ejemplo podrían ser los faros de un coche.</li>
</ul>
<p>Si utilizamos el editor de la escena, añadiendo un objeto de tipo <em>Light</em> tendremos un nodo que ya incorporará dicho componente. Encontramos distintos tipos de objetos <em>Light</em>, según el tipo de luz que queramos crear: <em>Ambiente Light</em>, <em>Area Light</em>, <em>Directional Light</em>, <em>Omni Light</em> y <em>Spot Light</em>.</p>
<p>Todas las luces tienen algunas propiedades comunes, como el <strong>color</strong> o la <strong>intensidad</strong> de la luz. En las fuentes que emiten luz desde una posición determinada, se define también una <strong>atenuación</strong> en función de la distancia, y de forma más específica, en las fuentes de tipo foco, se define la <strong>amplitud</strong> del foco de luz.</p>
<p>Además, podemos también indicar si una luz proyecta <strong>sombras</strong> o no. Tener más de una luz proyectando sombras produce un incremento notable del coste computacional del <em>render</em>, por lo que sólo se deberá hacer si lo consideramos importante en el videojuego.</p>
<h3 id="camaras">Cámaras<a class="headerlink" href="#camaras" title="Permanent link">&para;</a></h3>
<p>Podemos añadir un componente de tipo cámara a un nodo con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">cameraNode</span> <span class="p">=</span> <span class="bp">SCNNode</span><span class="p">()</span>
<span class="n">cameraNode</span><span class="p">.</span><span class="n">camera</span> <span class="p">=</span> <span class="bp">SCNCamera</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>Si utilizamos el editor de la escena, añadiendo un objeto de tipo <em>Camera</em> tendremos un nodo que ya incorporará dicho componente.</p>
<p>Una propiedad importante de la cámara son los <strong>planos de recorte cercano y lejano</strong>. En ellos determinaremos en que rango de profundida (coordenada <code>z</code>) se renderizarán los objetos. Es decir, sólo se rendizarán los objetos que estén más lejos de la cámara de lo que marque el plano cercano, pero que estén más cerca del plano lejano. Cuando mayor sea el plano lejano, se mostrarán objetos más distantes, pero el coste del <em>render</em> será mayor.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">cameraNode</span><span class="p">.</span><span class="n">camera</span><span class="p">?.</span><span class="n">zNear</span> <span class="p">=</span> <span class="mf">1.0</span>
<span class="n">cameraNode</span><span class="p">.</span><span class="n">camera</span><span class="p">?.</span><span class="n">zFar</span> <span class="p">=</span> <span class="mf">100.0</span>
</pre></div>
</td></tr></table>

<p>Otra propiedades de la cámara son las que nos permiten configurar los parámetros de cámara, como la <strong>distancia focal</strong> o el <strong>campo visual</strong>. El campo visual (ángulo que abarca la cámara) es lo que determinará qué elementos quedan dentro o fuera de la proyección en pantalla. Por defecto se especificará el vertical, aunque podemos modificarlo para que sea el campo horizontal el que se tome como referencia. Esto tiene importancia para la adaptación a diferentes dispositivos, ya que independientemente del tamaño de pantalla, el campo visual será siempre el mismo, por lo que el contenido que veremos en pantalla, a lo largo de la vertical, será el mismo también. En cuanto a la horizontal, dependiendo de la relación de aspecto de la pantalla veremos un campo menor o mayor. </p>
<p>También encontramos propiedades para añadir efectos avanzados de imagen a la cámara, como HDR, <em>depth of field</em> (sólo aparecerán enfocados los objetos en un rango de distancia determinado), o <em>motion blur</em> (los objetos se desenfocarán al moverse).</p>
<h3 id="geometria-y-material">Geometría y material<a class="headerlink" href="#geometria-y-material" title="Permanent link">&para;</a></h3>
<p>Podemos establecer la geometría de un nodo mediante su propiedad <code>geometry</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">node</span> <span class="p">=</span> <span class="bp">SCNNode</span><span class="p">()</span>
<span class="n">node</span><span class="p">.</span><span class="n">geometry</span> <span class="p">=</span> <span class="bp">SCNBox</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> 
                       <span class="n">length</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">chamferRadius</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Utilizando el editor de la escena, encontramos diferentes tipos de nodos para geometrías predefinidas: <em>Plane</em>, <em>Sphere</em>, <em>Box</em>, <em>Cyclinder</em>, <em>Cone</em>, <em>Capsule</em>, <em>3D Text</em>, etc. Si queremos incluir una maya 3D compleja, podremos crearla con otras herramientas (Blender, Maya, etc) e importarlas desde Xcode. </p>
<p>Una vez tenemos establecida la geometría, podemos asignarle el material con el que se renderizará. Podemos añadir varios materiales, aunque lo habitual será acceder al primero de ellos (propiedad <code>firstMaterial</code>). Dentro del material podemos encontrar diferentes propiedades que nos permitirán definir cómo responde el objeto a la luz. Algunas de ellas son:</p>
<ul>
<li><code>diffuse</code>: El contenido que pongamos en esta propiedad se mostrará como material <em>mate</em>. Es decir, su aspecto viene determinado por la luz que recibe, pero no del ángulo desde el que nosotros lo miremos (no aparecen <em>brillos</em>)</li>
<li><code>specular</code>: En este caso el contenido podrá mostrarse con <em>brillos</em>. La forma en la que lo veremos dependerá de la posición de la fuente de luz y del observador, pudiendo generarse brillos.</li>
<li><code>emission</code>: Esta propiedad nos permitirá que el material sea <em>emisivo</em>. Es decir, para mostrarse el contenido no hará falta que incida luz en el objeto, el propio objeto ya emite luz (pero no ilumina otros objetos de la escena). Esto nos puede servir por ejemplo para crear un monitor o una luz LED, que deberán verse aunque la escena esté en completa oscuridad.</li>
</ul>
<p>Por ejemplo, podríamos dar un color <em>rojo mate</em> a un objeto con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">node</span><span class="p">.</span><span class="n">geometry</span><span class="p">?.</span><span class="n">firstMaterial</span><span class="p">?.</span><span class="n">diffuse</span><span class="p">.</span><span class="n">contents</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">.</span><span class="n">red</span>
</pre></div>
</td></tr></table>

<p>La propiedad <code>contents</code> anterior puede recibir distintos tipos de objetos, entre los que se encuentran:</p>
<ul>
<li>Colores básicos (<code>UIColor</code>)</li>
<li>Una imagen o texture</li>
<li>Un vídeo</li>
<li>Una capa de <em>Core Animation</em> (<code>CALayer</code>)</li>
<li>Una escena de <em>SpriteKit</em> (<code>SKScene</code>)</li>
</ul>
<h2 id="renderer-de-la-escena"><em>Renderer</em> de la escena<a class="headerlink" href="#renderer-de-la-escena" title="Permanent link">&para;</a></h2>
<p>En SceneKit tenemos dos objetos: </p>
<ul>
<li>La escena (<code>SCNScene</code>). Define el contenido de la escena mediante un árbol de nodos.</li>
<li><em>Renderer</em> de la escena (<code>SCNSceneRenderer</code>): Es el encargado de dibujar (<em>renderizar</em>) la escena en pantalla.</li>
</ul>
<p>Encontramos diferentes tipos de <em>renderers</em> (clases que implementan el protocolo <code>SCNSceneRenderer</code>), según el contexto en el que queramos que se dibuje el contenido de la escena:</p>
<ul>
<li><code>SCNView</code>: Se <em>renderiza</em> en una vista de UIKit (subclases de <code>UIView</code>). Será el caso más habitual.</li>
<li><code>SCNLayer</code>: Se <em>renderiza</em> en una capa de <em>Core Animation</em> (subclase de <code>CALayer</code>).</li>
<li><code>SCNRenderer</code>: Se <em>renderiza</em> en un contexto OpenGL o Metal.</li>
</ul>
<p>El <em>renderer</em> de la escena permite definir un delegado de tipo <code>SCNSceneRendererDelegate</code>, donde podremos responder a los diferentes eventos del ciclo de vida de la escena.</p>
<p><img alt="Escena y _renderer" src="imagenes/nativo/scenekit_renderer.png" /></p>
<h3 id="ciclo-de-vida-de-la-escena">Ciclo de vida de la escena<a class="headerlink" href="#ciclo-de-vida-de-la-escena" title="Permanent link">&para;</a></h3>
<p>Mediante el delegado del <em>renderer</em> de la escena podremos introducir código en las distintas fases del ciclo de vida de la escena, tal como se muestra en la siguiente figura:</p>
<p><img alt="Ciclo de vida del _renderer_ de la escena" src="imagenes/nativo/scenekit_ciclo.png" /></p>
<p>Vemos que hay una serie de métodos que podemos utilizar para actualizar el contenido de la escena, mientras que hay otros que pueden ser útiles para alterar la forma en la que se hace el <em>render</em> (por ejemplo para dibujar contenido por debajo o por encima de la escena).</p>
<p>Para utilizar este delegado deberemos:</p>
<ol>
<li>Implementar el protocolo `SCNSceneRendererDelegate``</li>
<li>Asignar la clase en la que hayamos implementado el protocolo a la propiedad <code>delegate</code> del <code>SCNSceneRenderer</code>.</li>
<li>Implementar los métodos del protocolo que necesitemos.</li>
</ol>
<p>Lo más habitual será definir el método <code>renderer(_:, updateAtTime:)</code> para actualizar la escena en cada ciclo de reloj. Podemos utilizar el propio <code>UIViewController</code> como delegado, tal como vemos en el siguiente ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">GameViewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> 
                          <span class="bp">SCNSceneRendererDelegate</span> <span class="p">{</span>

    <span class="kd">var</span> <span class="nv">previousUpdateTime</span> <span class="p">:</span> <span class="n">TimeInterval</span><span class="p">?</span>

    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="kc">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>

        <span class="kd">let</span> <span class="nv">scnView</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">view</span> <span class="k">as</span><span class="p">!</span> <span class="bp">SCNView</span>        

        <span class="err">…</span>

        <span class="n">scnView</span><span class="p">.</span><span class="n">delegate</span> <span class="p">=</span> <span class="kc">self</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">renderer</span><span class="p">(</span><span class="kc">_</span> <span class="n">renderer</span><span class="p">:</span> <span class="bp">SCNSceneRenderer</span><span class="p">,</span> 
                  <span class="n">updateAtTime</span> <span class="n">time</span><span class="p">:</span> <span class="n">TimeInterval</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">deltaTime</span> <span class="p">=</span> <span class="n">time</span> <span class="o">-</span> <span class="p">(</span><span class="n">previousUpdateTime</span> <span class="p">??</span> <span class="n">time</span><span class="p">)</span>
        <span class="n">previousUpdateTime</span> <span class="p">=</span> <span class="n">time</span>
                  <span class="err">…</span>
    <span class="p">}</span> 

    <span class="err">…</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Del código anterior, destacamos que los métodos del delegado reciben el tiempo del sistema en cada iteración. Será responsabilidad nuestra calcular el <em>delta time</em> (tiempo transcurrido desde la última iteración). En el ejemplo anterior podemos ver una forma de hacerlo, controlando que en la primera iteración el <em>delta time</em> sea <code>0</code>. </p>
<h2 id="fisicas">Físicas<a class="headerlink" href="#fisicas" title="Permanent link">&para;</a></h2>
<p>La librería SceneKit, al igual que SpriteKit, integra su propio motor de físicas, pero en este caso en 3D. Los distintos elementos de este motor de físicas son muy parecidos a los que encontrábamos en el caso 2D:</p>
<table>
<thead>
<tr>
<th>Clase</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SCNPhysicsWorld</code></td>
<td>El mundo físico en el que se producirá la simulación, que estará contenido dentro de la escena (<code>SCNScene</code>), en su propiedad <code>physicsWorld</code></td>
</tr>
<tr>
<td><code>SCNPhysicsBody</code></td>
<td>Los cuerpos físicos estarán vinculados a cada nodo (<code>SCNNode</code>), como componente en su propiedad <code>physicsBody</code>.</td>
</tr>
<tr>
<td><code>SCNPhysicsShape</code></td>
<td>En este caso, se define este tipo para representar la forma geométrica de los cuerpos físicos. Cada cuerpo definirá su forma mediante un objeto de este tipo.</td>
</tr>
<tr>
<td><code>SCNPhysicsBehavior</code></td>
<td>Similar a los <em>joints</em> del caso 2D, pero en este caso además de uniones entre cuerpos, nos permitirá definir otro tipo de comportamientos, como por ejemplo vehículos</td>
</tr>
</tbody>
</table>
<p>Como podemos ver, el motor físico está totalmente integrado dentro de los elementos básicos de SceneKit: <code>SCNScene</code> y <code>SCNNode</code>. </p>
<ul>
<li>Para que un nodo pase a estar controlado por el motor de físicas, simplemente deberemos añadir un objeto <code>SCNPhysicsBody</code> a su propiedad <code>physicsBody</code>.</li>
<li>Si queremos modificar propiedades generales del mundo físico, podemos acceder a él en la propiedad <code>physicsWorld</code> de nuestra escena.</li>
</ul>
<p>Vamos a ver con más detalle como utilizar el motor de físicas de SceneKit.</p>
<h3 id="el-mundo-fisico">El mundo físico<a class="headerlink" href="#el-mundo-fisico" title="Permanent link">&para;</a></h3>
<p>Desde la clase de nuestra escena, podemos acceder al mundo físico con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">scene</span><span class="p">.</span><span class="n">physicsWorld</span>
</pre></div>
</td></tr></table>

<p>Una de las propiedades del mundo físico que podemos modificar es la <strong>gravedad</strong>, que se aplicará sobre todos los cuerpos del mundo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">scene</span><span class="p">.</span><span class="n">physicsWorld</span><span class="p">.</span><span class="n">gravity</span> <span class="p">=</span> <span class="bp">SCNVector3</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>En este objeto <code>physicsWorld</code>, podemos también establecer la velocidad (<code>speed</code>) de la simulación, y la tasa de actualización de las físicas (<code>timeStep</code>). Además, podremos añadir uniones entre cuerpos o comprobar colisiones como veremos más adelante.</p>
<h3 id="creacion-de-un-cuerpo-fisico">Creación de un cuerpo físico<a class="headerlink" href="#creacion-de-un-cuerpo-fisico" title="Permanent link">&para;</a></h3>
<p>Para utilizar el motor de físicas, lo primero que deberemos hacer es crear un cuerpo físico. Por ejemplo, podemos añadir un cuerpo físico a un nodo de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">nodo</span><span class="p">.</span><span class="n">physicsBody</span> <span class="p">=</span> <span class="bp">SCNPhysicsBody</span><span class="p">(</span>
     <span class="n">type</span><span class="p">:</span> <span class="n">SCNPhysicsBodyType</span><span class="p">.</span><span class="kr">dynamic</span><span class="p">,</span> 
     <span class="n">shape</span><span class="p">:</span> <span class="bp">SCNPhysicsShape</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="bp">SCNSphere</span><span class="p">(</span><span class="n">radius</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>En este caso, el cuerpo podrá ser de cualquiera de los tipos habituales en los motores de físicas:</p>
<ul>
<li><code>.static</code>: El objeto no se mueve ni le afectan las fuerzas</li>
<li><code>.kinematic</code>: El objeto puede moverse, pero no le afectan las fuerzas</li>
<li><code>.dynamic</code>: Al objeto le afectan las fuerzas del ,mundo físico.</li>
</ul>
<p>Podemos observar que al definir el cuerpo físico, debemos especificar también su geometría de colisión en el constructor mediante un objeto de tipo <code>SCNPhysicsShape</code>. Como vemos, el objeto <code>SCNPhysicsShape</code> se puede construir a partir de un objeto de tipo <code>SCNGeometry</code>, por lo que podríamos utilizar la misma geometría que se utilizó para la maya gráfica, pero tenemos otras opciones. Recordemos que deberemos buscar una geometría <strong>lo más sencilla posible</strong>, que <strong>se adapte de la mejor forma posible a la geometría gráfica del nodo</strong>. </p>
<h3 id="forma-de-los-cuerpos-fisicos">Forma de los cuerpos físicos<a class="headerlink" href="#forma-de-los-cuerpos-fisicos" title="Permanent link">&para;</a></h3>
<p>Podemos construir el objeto <code>SCNPhysicsShape</code> a partir de:</p>
<ul>
<li>Un objeto <code>SCNGeometry</code>. Podemos crearlo a partir de las formas predefinidas, o bien a partir de mayas más complejas.</li>
<li>Un nodo <code>SCNNode</code>. Se tomará la geometría del nodo proporcionado, y en caso de tener hijos combinará la geometría de los mismos.</li>
<li>Un lista de <code>[SCNPhysicsShape]</code>. Nos permitirá crear un <strong>cuerpo compuesto</strong> por varias geometrías. A efectos de coste computacional, es preferible crear un cuerpo compuesto por varias geometrías convexas, a crearlo a partir de una única geometría cóncava.</li>
</ul>
<p>En cualquiera de los casos anteriores, podemos encontrarnos con los siguientes casos:</p>
<ul>
<li>La geometría es un <strong>tipo predefinido</strong>. El cálculo de colisiones está optimizado para estas geometrías, siendo el orden de menos a más complejas el siguiente: <code>SCNSphere</code>, <code>SCNBox</code>, <code>SCNCapsule</code>, otras formas geométricas.</li>
<li><strong>Maya personalizada</strong>. En este caso, en el parámetro <code>options</code> tenemos una propiedad <code>type</code> con la que podemos especificar la manera en que se adaptará la <em>forma gráfica</em> del objeto para obtener la forma física. Estas opciones pueden ser:<ul>
<li><code>boundingBox</code>: Simplemente calcula una forma de tipo <em>caja</em> que engloba toda la geometría del objeto. Es la simplificación más básica y eficiente, pero puede adaptarse mal a la geometría del objeto.</li>
<li><code>convexHull</code>: Recubrimiento convexo de la maya. Se crea una maya que envuelva toda la geometría del objeto eliminando concavidades. Esta será la forma de adaptación <em>por defecto</em>. </li>
<li><code>concavePolyhedron</code>: Se adapta completamente a la geometría del objeto, respetando las concavidades. Debemos evitar el uso de este tipo de formas en cuerpos dinámicos. Si las concavidades son importantes, debemos plantearnos aproximarlas mediante el uso de formas compuestas en lugar de utilizar formas cóncavas. </li>
</ul>
</li>
</ul>
<h3 id="propiedades-de-los-cuerpos-fisicos">Propiedades de los cuerpos físicos<a class="headerlink" href="#propiedades-de-los-cuerpos-fisicos" title="Permanent link">&para;</a></h3>
<p>Los cuerpos físicos tienen una serie de propiedades que podemos configurar:</p>
<table>
<thead>
<tr>
<th>Propiedad</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>type</code></td>
<td>Establece si es <strong>dinámico</strong>, <strong>cinemático</strong> o <strong>estático</strong></td>
</tr>
<tr>
<td><code>physicsShape</code></td>
<td>Establece la forma del cuerpo físico</td>
</tr>
<tr>
<td><code>mass</code></td>
<td>Masa del cuerpo (en <span><span class="MathJax_Preview">kg</span><script type="math/tex">kg</script></span>).</td>
</tr>
<tr>
<td><code>momentOfInertia</code></td>
<td>Momento de inercia</td>
</tr>
<tr>
<td><code>centerOfMassOffset</code></td>
<td>Desplazamiento del centro de masas del cuerpo</td>
</tr>
<tr>
<td><code>damping</code></td>
<td>Resistencia al aire lineal</td>
</tr>
<tr>
<td><code>angularDamping</code></td>
<td>Resistencia al aire angular</td>
</tr>
<tr>
<td><code>friction</code></td>
<td>Coeficiente de fricción de la superficie. Regulará la fuerza que se opone al desplazamiento del objeto cuando éste se desliza sobre una superficie rugosa.</td>
</tr>
<tr>
<td><code>rollingFriction</code></td>
<td>Coeficiente de fricción en el rodamiento, se aplica cuando en lugar de deslizarse sobre una superficie, el cuerpo ruede sobre ella.</td>
</tr>
<tr>
<td><code>restitution</code></td>
<td>Coeficiente de restitución (rebote)</td>
</tr>
<tr>
<td><code>velocityFactor</code></td>
<td>Factor multiplicativo que se le aplicará a la velocidad del cuerpo. El factor se especifica mediante un <code>SCNVector3</code>, de forma que podemos especificar un factor diferente para la velocidad en <code>x</code>, <code>y</code>, <code>z</code>. Si ponemos un factor <code>0</code> en alguno de los ejes, evitaremos que el objeto se mueva en dicho eje, limitando así sus grados de libertad. Por ejemplo, se podría conseguir que un objeto se mueva sólo en un determinado plano.</td>
</tr>
<tr>
<td><code>angularVelocityFactor</code></td>
<td>Similar a la propiedad anterior, pero aplicada a la velocidad angular aplicada en cada eje. Con esta propiedad podremos hacer por ejemplo que el objeto pueda rotar únicamente alrededor de un determinado eje.</td>
</tr>
<tr>
<td><code>isAffectedToGravity</code></td>
<td>Determina si al objeto le afecta la gravedad del mundo.</td>
</tr>
</tbody>
</table>
<h3 id="busqueda-de-cuerpos">Búsqueda de cuerpos<a class="headerlink" href="#busqueda-de-cuerpos" title="Permanent link">&para;</a></h3>
<p>Existe diferentes formas de buscar cuerpos en determinadas regiones del mundo.</p>
<ul>
<li>
<p><strong>Búsqueda por área</strong>: Con <code>convexSwepTest(with:from:to:options:)</code> podemos hacer un barrido por una zona determinada del mundo, para detectar qué cuerpos han en esa zona. </p>
</li>
<li>
<p><strong>Trazado de rayos</strong>. Podemos lanzar un rayo 3D con <code>rayTestWithSegment(from:to:options:)</code> para detectar los cuerpos que se encuentren en su camino. Tendremos que indicar un punto inicial y un punto final del rayo.</p>
</li>
</ul>
<h3 id="colisiones">Colisiones<a class="headerlink" href="#colisiones" title="Permanent link">&para;</a></h3>
<p>En SceneKit podemos comprobar directamente si dos cuerpos colisionan entre si, o consultar qué cuerpos están en contacto con un determinado cuerpo. Para ello contamos con los siguientes métodos:</p>
<ul>
<li><code>contactTestBetween(:,:,options:)</code></li>
<li><code>contactTest(with:,options:)</code></li>
</ul>
<p>Puede interesarnos también recibir notificaciones de los contactos entre cuerpos. Para ello deberemos implementar un <em>delegado de contactos</em> que adopte el protocolo <code>SCNPhysicsContactDelegate</code>. Podemos adoptar dicho delegado en nuestro propio controlador. Para crear dicho delegado deberemos:</p>
<ol>
<li>Adoptar el protocolo <code>SCNPhysicsContactDelegate</code> en nuestra clase.
    <table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">GameViewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> 
                          <span class="bp">SCNPhysicsContactDelegate</span> 
</pre></div>
</td></tr></table></li>
<li>Asignar dicha clase como <code>contactDelegate</code> del <code>physicsWorld</code>
    <table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">scene</span><span class="p">.</span><span class="n">physicsWorld</span><span class="p">.</span><span class="n">contactDelegate</span> <span class="p">=</span> <span class="kc">self</span>
</pre></div>
</td></tr></table></li>
<li>Implementar los métodos que nos interesen del delegado:<ul>
<li><code>physicsWorld(:,didBegin:)</code></li>
<li><code>physicsWorld(:,didUpdate:)</code></li>
<li><code>physicsWorld(:,didEnd:)</code></li>
</ul>
</li>
</ol>
<p>Por ejemplo, podemos comprobar si un proyectil entra en contacto con otro cuerpo, y a partir del impulso de la colisión calcular el daño producido de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">physicsWorld</span><span class="p">(</span><span class="kc">_</span> <span class="n">world</span><span class="p">:</span> <span class="bp">SCNPhysicsWorld</span><span class="p">,</span> 
                  <span class="n">didBegin</span> <span class="n">contact</span><span class="p">:</span> <span class="bp">SCNPhysicsContact</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">contact</span><span class="p">.</span><span class="n">nodeA</span><span class="p">.</span><span class="n">name</span><span class="p">==</span><span class="s">&quot;proyectil&quot;</span> <span class="o">||</span> 
       <span class="n">contact</span><span class="p">.</span><span class="n">nodeB</span><span class="p">.</span><span class="n">name</span><span class="p">==</span><span class="s">&quot;proyectil&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">damage</span> <span class="p">=</span> <span class="n">contact</span><span class="p">.</span><span class="n">collisionImpulse</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Hay que destacar que en la colisión siempre intervendrán dos nodos: <code>nodeA</code> y <code>nodoB</code>, y que el orden en el que pueden venir es arbitrario, por lo que habrá que tener en cuenta cualquier posibilidad. </p>
<h3 id="layering">Layering<a class="headerlink" href="#layering" title="Permanent link">&para;</a></h3>
<p>SceneKit, al igual que SpriteKit,  nos permite filtrar qué cuerpos colisionan con otros mediante una serie de máscaras binarias:</p>
<ul>
<li><code>categoryBitMask</code> nos permite definir diferentes categorías de objetos. Cada bit de la máscara representa una categoría, por ejemplo:
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">naveCategoryMask</span> <span class="p">:</span> <span class="nb">UInt32</span> <span class="p">=</span> <span class="mb">0b0001</span> <span class="c1">// 1 </span>
<span class="kd">let</span> <span class="nv">asteroideCategoryMask</span> <span class="p">:</span> <span class="nb">UInt32</span> <span class="p">=</span>  <span class="mb">0b0010</span> <span class="c1">// 2 </span>
<span class="kd">let</span> <span class="nv">balaCategoryMask</span> <span class="p">:</span> <span class="nb">UInt32</span> <span class="p">=</span>     <span class="mb">0b0100</span> <span class="c1">// 4</span>
</pre></div>
</td></tr></table></li>
<li><code>collisionBitMask</code> nos indica con qué categorías de cuerpos podremos colisionar. Por ejemplo, si a los asteroides les damos un valor de <code>0b0011</code>, el asteroide colisionará con nuestra nave y otros asteroides, pero será atravesado por las balas. Si a las balas les damos un valor <code>0b0000</code> atravesarán tanto a la nave y a los asteroides como otras balas. </li>
<li><code>contactTestBitMask</code> nos indica con qué categorías de cuerpos nos notificará los contactos en el <em>listener de contactos</em>. Por ejemplo, si a los asteroides les damos un valor <code>0b0101</code> nos notificará cuando <em>toquen</em> una bala o a nuestra nave. Si a la nave le damos un valor <code>0b0010</code>, nos avisará únicamente cuando nos toque un asteroide.</li>
</ul>
<p><img alt="Layering con SceneKit" src="imagenes/nativo/scenekit_layering.png" /></p>
<h3 id="uniones">Uniones<a class="headerlink" href="#uniones" title="Permanent link">&para;</a></h3>
<p>Podemos establecer uniones entre cuerpos con diferentes subclases de <code>SCNPhysicsBehaviour</code>:</p>
<ul>
<li><code>SCNPhysicsSliderJoint</code>: Unión de tipo <strong>"rail"</strong>. Los dos cuerpos pueden deslizarse a lo largo de un eje determinado.</li>
<li><code>SCNPhysicsHingeJoint</code>: Union de tipo <strong>"bisagra"</strong>. Permite la rotación alrededor de determinado eje. Útil por ejemplo para puertas.</li>
<li><code>SCNPhysicsConeTwistJoint</code>: Unión tipo <strong>"articulación"</strong>. </li>
<li><code>SCNPhysicsBallSocketJoint</code>: Unión tipo <strong>"varilla"</strong>. Los objetos se mantienen a una distancia fija, anclados a dos puntos alrededor de los cuales pueden rotar.</li>
</ul>
<p>Además, contamos con los comportamientos <code>SCNPhysicsVehicle</code> y <code>SCNPhysicsVehicleWheel</code> que implementan el comportamiento de un vehículos y sus ruedas, respectivamente.</p>
<p>Por ejemplo, podemos crear una unión de tipo <em>bisagra</em> de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">hinge</span> <span class="p">=</span> <span class="bp">SCNPhysicsHingeJoint</span><span class="p">(</span><span class="n">body</span><span class="p">:</span> <span class="n">body</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="bp">SCNVector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">anchor</span><span class="p">:</span> <span class="bp">SCNVector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Una vez definida la unión e indicados los cuerpos que unirá, debemos añadirla al mundo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">scene</span><span class="p">.</span><span class="n">physicsWorld</span><span class="p">.</span><span class="n">addBehavior</span><span class="p">(</span><span class="n">hinge</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>De la misma forma, podemos <em>desconectar</em> los cuerpos eliminando la unión del mundo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">scene</span><span class="p">.</span><span class="n">physicsWorld</span><span class="p">.</span><span class="n">removeBehavior</span><span class="p">(</span><span class="n">hinge</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<h2 id="acciones-y-animaciones">Acciones y animaciones<a class="headerlink" href="#acciones-y-animaciones" title="Permanent link">&para;</a></h2>
<p>En SceneKit contamos con el mismo mecanismo de acciones que SpriteKit, que nos permite programar el comportamiento de los nodos de la escena. </p>
<h3 id="acciones">Acciones<a class="headerlink" href="#acciones" title="Permanent link">&para;</a></h3>
<p>En este caso, todas las acciones se crean mediante métodos de <code>SCNAction</code>, y en casi todas ellas deberemos especificar el tiempo que durará la acción. Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">accion</span> <span class="p">=</span> <span class="bp">SCNAction</span><span class="p">.</span><span class="n">fadeIn</span><span class="p">(</span><span class="n">withDuration</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="p">````</span>

<span class="n">Esta</span> <span class="n">acción</span> <span class="n">hará</span> <span class="n">un</span> <span class="n">fundido</span> <span class="n">de</span> <span class="n">entrada</span> <span class="p">(</span><span class="n">desde</span> <span class="n">transparente</span> <span class="n">hasta</span> <span class="n">opaco</span><span class="p">)</span> <span class="n">durante</span> <span class="mi">1</span> <span class="n">segundo</span> <span class="n">en</span> <span class="n">el</span> <span class="n">nodo</span> <span class="n">en</span> <span class="n">el</span> <span class="n">que</span> <span class="n">la</span> <span class="n">ejecutemos</span><span class="p">.</span> <span class="n">Ejecutaremos</span> <span class="n">la</span> <span class="n">acción</span> <span class="n">sobre</span> <span class="n">un</span> <span class="n">nodo</span> <span class="n">con</span><span class="p">:</span>

<span class="p">```</span><span class="n">swift</span>
<span class="n">node</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">accion</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Podemos también detener todas las acciones que esté ejecutando un nodo con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span> <span class="n">node</span><span class="p">.</span><span class="n">removeAllActions</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>Si queremos detener una acción concreta, deberemos ejecutarla con una clave que nos permita identificarla, y posteriormente detenerla a partir de dicha clave:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">node</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">accion</span><span class="p">,</span> <span class="n">withKey</span><span class="p">:</span> <span class="s">&quot;fundido&quot;</span><span class="p">)</span>

<span class="p">...</span>

<span class="n">node</span><span class="p">.</span><span class="n">removeAction</span><span class="p">(</span><span class="n">forKey</span><span class="p">:</span> <span class="s">&quot;fundido&quot;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<h3 id="tipos-de-acciones">Tipos de acciones<a class="headerlink" href="#tipos-de-acciones" title="Permanent link">&para;</a></h3>
<p>Dentro de <code>SCNAction</code> encontramos númerosos métodos factoría para crear diferentes tipos de acciones. Destacamos por ejemplo las acciones dedicadas a trasladar un nodo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">accion1</span> <span class="p">=</span> <span class="bp">SCNAction</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">SCNVector3Make</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> 
                             <span class="n">duration</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">accion2</span> <span class="p">=</span> <span class="bp">SCNAction</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="n">SCNVector3Make</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> 
                             <span class="n">duration</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">accion3</span> <span class="p">=</span> <span class="bp">SCNAction</span><span class="p">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">.</span><span class="n">pi</span><span class="p">,</span> 
                               <span class="n">around</span><span class="p">:</span> <span class="n">SCNVector3Make</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> 
                               <span class="n">duration</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>En todas estas acciones se indica la posición o ángulo al que se moverá el nodo, y el tiempo que tardará en hacerlo (en segundos).</p>
<h3 id="composicion-de-acciones">Composición de acciones<a class="headerlink" href="#composicion-de-acciones" title="Permanent link">&para;</a></h3>
<p>Podemos crear acciones que se creen a partir de la combinación de varias acciones:</p>
<ul>
<li><code>sequence</code>. Combina varias acciones en secuencia. La duración de la escena resultante será la suma de la duración de todas las acciones contenidas.</li>
<li><code>group</code>. Combina varias acciones en paralelo. La acción resultante terminará cuando termine la más larga de las acciones que contenga.</li>
</ul>
<p>Por ejemplo, podemos crear una secuencia con las acciones anteriores:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">accion</span> <span class="p">=</span> <span class="bp">SCNAction</span><span class="p">.</span><span class="n">sequence</span><span class="p">([</span><span class="n">accion1</span><span class="p">,</span> <span class="n">accion2</span><span class="p">,</span> <span class="n">accion3</span><span class="p">])</span>
</pre></div>
</td></tr></table>

<p>Además, contamos con podemos hacer que una acción se repita un número determinado de veces con <code>SCNAction.repeat</code> o de forma indefinida por <code>SCNAction.repeatForever</code>. Por ejemplo, podríamos repetir continuamente la secuencia anterior con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">accionRepite</span> <span class="p">=</span> <span class="bp">SKAction</span><span class="p">.</span><span class="n">repeatForever</span><span class="p">(</span><span class="n">accion</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Hay algunas acciones que serán especialmente útiles para integrar dentro de una secuencia, como por ejemplo <code>SCNAction.removeFromParentNode</code>, que eliminará del árbol de la escena el nodo sobre el que se ejecute, y la acción <code>SCNAction.run</code> que nos permite ejecutar nuestro propio bloque de código:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">accionRun</span> <span class="p">=</span> <span class="bp">SCNAction</span><span class="p">.</span><span class="n">run</span> <span class="p">{</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">in</span>
    <span class="n">mostrarResultados</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Esto nos permitirá ejecutar código propio en cualquier paso intermedio o final de la secuencia de acciones.</p>
<h3 id="animaciones">Animaciones<a class="headerlink" href="#animaciones" title="Permanent link">&para;</a></h3>
<p>Además de las acciones, en SceneKit podemos también implementar animaciones mediante transacciones, de forma similar a como se hace con Core Animation. </p>
<p>Para realizar una animación de esta forma, deberemos abrir una transacción de animación (<code>SCNTransaction</code>), establecer su duración (<code>animationDuration</code>) y cambiar las propiedades de los objetos que queramos que sean modificadas de forma gradual durante el tiempo de la animación. </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="bp">SCNTransaction</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span>
<span class="bp">SCNTransaction</span><span class="p">.</span><span class="n">animationDuration</span> <span class="p">=</span> <span class="mf">0.5</span>

<span class="bp">SCNTransaction</span><span class="p">.</span><span class="n">completionBlock</span> <span class="p">=</span> <span class="p">{</span>
                <span class="bp">SCNTransaction</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span>
                <span class="bp">SCNTransaction</span><span class="p">.</span><span class="n">animationDuration</span> <span class="p">=</span> <span class="mf">0.5</span>

                <span class="n">material</span><span class="p">.</span><span class="n">emission</span><span class="p">.</span><span class="n">contents</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">.</span><span class="n">black</span>

                <span class="bp">SCNTransaction</span><span class="p">.</span><span class="n">commit</span><span class="p">()</span>
            <span class="p">}</span>

<span class="n">material</span><span class="p">.</span><span class="n">emission</span><span class="p">.</span><span class="n">contents</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">.</span><span class="n">red</span>

<span class="bp">SCNTransaction</span><span class="p">.</span><span class="n">commit</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>Vemos además que podemos incluir un <code>completionBlock</code>, con el que podemos por ejemplo encadenar varias animaciones como vemos en el ejemplo anterior.</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="spritekit.html" title="SpriteKit" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Anterior
                </span>
                SpriteKit
              </span>
            </div>
          </a>
        
        
          <a href="cocos2d-x.html" title="Cocos2d-x" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Siguiente
                </span>
                Cocos2d-x
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="assets/javascripts/application.245445c6.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>